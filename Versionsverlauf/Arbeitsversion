// ==UserScript==
// @name         mydealz Manager
// @namespace    http://tampermonkey.net/
// @version      1.18.0_260106_1837
// @description  Blendet unerw√ºnschte Deals nach H√§ndler, W√∂rtern, Preis und Temperatur aus, entfernt H√§ndlernamen aus Titeln und bietet komfortable Listen zur Verwaltung von Filtern und blockierten Nutzern.
// @author       Flo (https://www.mydealz.de/profile/Basics0119) (https://github.com/9jS2PL5T) & Moritz Baumeister (https://www.mydealz.de/profile/BobBaumeister) (https://github.com/grapefruit89)
// @license      MIT
// @match        https://www.mydealz.de/*
// @match        https://www.preisjaeger.at/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=mydealz.de
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_deleteValue
// @grant        GM_registerMenuCommand
// @grant        GM_unregisterMenuCommand
// ==/UserScript==

// Versions-√Ñnderungen
// 202x-xx-xx - v1.18.0
// FIX: Beim Update des Scripts wurden manche gesetzten Einstellungen nicht korrekt √ºbernommen
// FIX: "H√§ndler im Titel ausblenden" funktionierte nicht f√ºr gecachte Deals - Cache-Logik optimiert
// FIX: "H√§ndler im Titel ausblenden" entfernt jetzt auch H√§ndlernamen in der Mitte des Titels (z.B. "(CB) K√§rcher Waschsauger" ‚Üí "(CB) Waschsauger")
// FIX: Wortfilter funktionierte nicht wenn "H√§ndler im Titel ausblenden" aktiv war - Ausf√ºhrungsreihenfolge korrigiert (hideMatchingMerchantNames l√§uft jetzt VOR Cache-Check)
// FIX: Wortfilter sieht jetzt die ge√§nderten Titel statt der Original-Titel - Cache-Key ber√ºcksichtigt hideMatchingMerchantNames-Status
// FIX: Preisfilter funktionierte nicht
// ADD: Wortfilter unterst√ºtzt jetzt Wildcards (*) f√ºr flexible Teilmatches im Titel
// ADD: UND-Filter (+) - Mehrere W√∂rter m√ºssen im Titel vorkommen (z.B. "discord+nitro")
// ADD: Negation-Filter (-) - Wort muss vorkommen, aber nicht ein anderes (z.B. "wei√üwein -glas")
// ADD: Sortierung der Filterlisten nach "Alphabet" und "Hinzugef√ºgt am"
// ADD: Timestamp-Anzeige f√ºr Filtereintr√§ge - Zeigt an, wann ein Wort/H√§ndler/User zur Filterliste hinzugef√ºgt wurde
// ADD: Whitelist f√ºr W√∂rter im Titel - Deals mit diesen W√∂rter werden nicht ausgeblendet
// ADD: Debug-Kontextmen√º mit √ºbersichtlichem Toggle-Panel f√ºr alle Debug-Flags (persistent gespeichert)
// ADD: Ausf√ºhrliches Debug-Logging f√ºr Wortfilter (zeigt rawTitle, normalizedTitle, alle Filter, Match-Details)
// CHANGE: Settings-Dialog zeigt nun Grip-Icon (‚ãÆ‚ãÆ) zur visuellen Kennzeichnung der Drag-Funktionalit√§t (nur Desktop)
// CHANGE: Settings-Dialog passt Gr√∂√üe dynamisch an aus-/eingeklappte Accordion-Sektionen an
// OPTIMIZATION: localStorage komplett entfernt - Script nutzt jetzt ausschlie√ülich GM Storage (au√üer externe Abh√§ngigkeiten)
// REMOVED: Funktion zum Ausblenden des Teilen-Buttons entfernt. Empfehlung: uBlock Origin oder √§hnliche Content-Blocker.

//#region --- 1. Initialisierung und Grundeinstellungen ---

// ===== Debug-Men√º Sichtbarkeit =====
// Nur f√ºr Debugging - auf true setzen um Debug-Men√º in Tampermonkey zu aktivieren
const SHOW_DEBUG_MENU = false;

// ===== Debug-Konfiguration =====
// Default-Werte (werden am Script-Ende durch loadDebugConfig() √ºberschrieben)
const DEBUG = {
  hideMatchingMerchantNames: false, // Debug-Logs f√ºr H√§ndlernamen-Feature
  priceFilter: false, // Debug-Logs f√ºr Preis-Filter
  priceFilterVerbose: false, // Sehr detaillierte PriceFilter-Logs (Parsing/Selector-Details)
  merchantFilter: false, // Debug-Logs f√ºr H√§ndlerfilter (zeigt H√§ndler-ID, Name und Match-Details)
  merchantInfoVerbose: false, // Detaillierte MerchantInfo-Logs (merchantId gefunden)
  userBlocking: false, // Debug-Logs f√ºr User-Blocking
  backup: false, // Debug-Logs f√ºr Backup/Restore
  criticalErrors: false, // Warnt bei fehlgeschlagenen Selektoren
  wordFilter: false, // Debug-Logs f√ºr Wortfilter
  wordFilterVerbose: false, // Sehr detaillierte WordFilter-Logs (Testing filters mit allen Details)
  dataLoading: false, // Debug-Logs f√ºr Laden von gespeicherten Daten (excludeWords, merchants, etc.)
  initialization: false, // Debug-Logs f√ºr Script-Initialisierung (init(), loadSettings())

  // üîç DELAY DEBUGGING: Deaktiviert alle Performance-Optimierungen f√ºr Tests
  disableOptimizations: false, // Wenn true: Kein Debounce, kein Throttle, kein Early Exit
  delayDebug: false, // Debug-Logs f√ºr Observer/Processing Delays (SKIPPED, EXECUTING, Observer-Trigger, etc.)

  // Performance Monitoring (granular)
  performance: {
    enabled: false, // Master-Toggle f√ºr alle Performance-Logs
    observer: false, // MutationObserver Callbacks
    processing: false, // processArticles() Durchl√§ufe
    filtering: false, // Filter-Operationen (Wort/H√§ndler/Preis)
    caching: false, // Cache-Hits/Misses
    domManipulation: false, // DOM-Updates (Titel, Verstecken)
    timing: false, // Detaillierte Timing-Messungen
    summary: false, // Performance-Zusammenfassung
    lazyRenderSummary: false, // Kurze Zusammenfassung bei verz√∂gert geladenen Deals
  },
};

// ===== Performance-Tracking-System =====
class PerformanceTracker {
  constructor() {
    this.metrics = {
      observer: { calls: 0, totalTime: 0, lastCall: null },
      processArticles: {
        calls: 0,
        totalTime: 0,
        articlesProcessed: 0,
        lastCall: null,
      },
      filtering: {
        wordFilter: { calls: 0, totalTime: 0, hits: 0 },
        merchantFilter: { calls: 0, totalTime: 0, hits: 0 },
        priceFilter: { calls: 0, totalTime: 0, hits: 0 },
      },
      caching: { hits: 0, misses: 0, size: 0 },
      domUpdates: { titleChanges: 0, hideActions: 0, showActions: 0 },
    };
    this.timers = new Map();
    // Batch-Tracking f√ºr aggregierte Logs
    this.currentBatch = {
      caching: { hits: 0, misses: 0, dealIds: { hits: [], misses: [] } },
      domUpdates: { hidden: 0, shown: 0, titleChanges: 0 },
      filtering: { wordMatches: 0, priceExceeded: 0 },
    };
  }

  // Starte einen Timer
  start(label) {
    if (!DEBUG.performance.enabled) return;
    this.timers.set(label, performance.now());
  }

  // Beende einen Timer und gib die Dauer zur√ºck
  end(label) {
    if (!DEBUG.performance.enabled) return 0;
    const startTime = this.timers.get(label);
    if (!startTime) return 0;
    const duration = performance.now() - startTime;
    this.timers.delete(label);
    return duration;
  }

  // Logge eine Metrik
  log(category, subcategory, data = {}) {
    if (!DEBUG.performance.enabled) return;

    const timestamp = new Date().toISOString().split("T")[1].split(".")[0];
    const logData = {
      time: timestamp,
      category,
      subcategory,
      ...data,
    };

    // Kategorie-spezifisches Logging
    if (DEBUG.performance[category]) {
      console.log(
        `[Performance ${timestamp}] ${category}/${subcategory}:`,
        logData
      );
    }
  }

  // Aktualisiere Metriken
  update(path, value) {
    const keys = path.split(".");
    let current = this.metrics;
    for (let i = 0; i < keys.length - 1; i++) {
      current = current[keys[i]];
    }
    const lastKey = keys[keys.length - 1];
    if (typeof current[lastKey] === "number") {
      current[lastKey] += value;
    } else {
      current[lastKey] = value;
    }
  }

  // Zeige Performance-Zusammenfassung
  showSummary() {
    if (!DEBUG.performance.enabled || !DEBUG.performance.summary) return;

    console.group("üìä Performance Summary - mydealz Manager");

    // Observer Stats
    const obs = this.metrics.observer;
    if (obs.calls > 0) {
      console.log("üîç Observer:", {
        calls: obs.calls,
        avgTime: `${(obs.totalTime / obs.calls).toFixed(2)}ms`,
        totalTime: `${obs.totalTime.toFixed(2)}ms`,
      });
    }

    // Processing Stats
    const proc = this.metrics.processArticles;
    if (proc.calls > 0) {
      console.log("‚öôÔ∏è Article Processing:", {
        runs: proc.calls,
        articlesProcessed: proc.articlesProcessed,
        avgArticlesPerRun: (proc.articlesProcessed / proc.calls).toFixed(1),
        avgTime: `${(proc.totalTime / proc.calls).toFixed(2)}ms`,
        totalTime: `${proc.totalTime.toFixed(2)}ms`,
      });
    }

    // Filter Stats
    const filters = this.metrics.filtering;
    console.log("üîé Filtering:", {
      wordFilter: {
        calls: filters.wordFilter.calls,
        hits: filters.wordFilter.hits,
        hitRate:
          filters.wordFilter.calls > 0
            ? `${(
                (filters.wordFilter.hits / filters.wordFilter.calls) *
                100
              ).toFixed(1)}%`
            : "0%",
        avgTime:
          filters.wordFilter.calls > 0
            ? `${(
                filters.wordFilter.totalTime / filters.wordFilter.calls
              ).toFixed(3)}ms`
            : "0ms",
      },
      merchantFilter: {
        calls: filters.merchantFilter.calls,
        hits: filters.merchantFilter.hits,
        hitRate:
          filters.merchantFilter.calls > 0
            ? `${(
                (filters.merchantFilter.hits / filters.merchantFilter.calls) *
                100
              ).toFixed(1)}%`
            : "0%",
      },
      priceFilter: {
        calls: filters.priceFilter.calls,
        hits: filters.priceFilter.hits,
        hitRate:
          filters.priceFilter.calls > 0
            ? `${(
                (filters.priceFilter.hits / filters.priceFilter.calls) *
                100
              ).toFixed(1)}%`
            : "0%",
      },
    });

    // Cache Stats
    const cache = this.metrics.caching;
    const cacheTotal = cache.hits + cache.misses;
    if (cacheTotal > 0) {
      console.log("üíæ Cache:", {
        hits: cache.hits,
        misses: cache.misses,
        hitRate: `${((cache.hits / cacheTotal) * 100).toFixed(1)}%`,
        size: cache.size,
      });
    }

    // DOM Updates
    const dom = this.metrics.domUpdates;
    console.log("üé® DOM Updates:", {
      titleChanges: dom.titleChanges,
      hidden: dom.hideActions,
      shown: dom.showActions,
    });

    console.groupEnd();
  }

  // Setze Metriken zur√ºck
  reset() {
    this.metrics = {
      observer: { calls: 0, totalTime: 0, lastCall: null },
      processArticles: {
        calls: 0,
        totalTime: 0,
        articlesProcessed: 0,
        lastCall: null,
      },
      filtering: {
        wordFilter: { calls: 0, totalTime: 0, hits: 0 },
        merchantFilter: { calls: 0, totalTime: 0, hits: 0 },
        priceFilter: { calls: 0, totalTime: 0, hits: 0 },
      },
      caching: { hits: 0, misses: 0, size: 0 },
      domUpdates: { titleChanges: 0, hideActions: 0, showActions: 0 },
    };
    this.timers.clear();
    console.log("[Performance] ‚ôªÔ∏è Metrics reset");
  }

  // Batch-Tracking Methoden
  resetBatch() {
    this.currentBatch = {
      caching: { hits: 0, misses: 0, dealIds: { hits: [], misses: [] } },
      domUpdates: { hidden: 0, shown: 0, titleChanges: 0 },
      filtering: { wordMatches: 0, priceExceeded: 0 },
    };
  }

  logBatch() {
    if (!DEBUG.performance.enabled) return;
    const timestamp = new Date().toISOString().split("T")[1].split(".")[0];

    // Cache Batch Log
    if (
      DEBUG.performance.caching &&
      (this.currentBatch.caching.hits > 0 ||
        this.currentBatch.caching.misses > 0)
    ) {
      console.log(`[Performance ${timestamp}] caching/batch:`, {
        hits: this.currentBatch.caching.hits,
        misses: this.currentBatch.caching.misses,
        hitRate: `${(
          (this.currentBatch.caching.hits /
            (this.currentBatch.caching.hits +
              this.currentBatch.caching.misses)) *
          100
        ).toFixed(1)}%`,
        sampleHits: this.currentBatch.caching.dealIds.hits.slice(0, 3),
        sampleMisses: this.currentBatch.caching.dealIds.misses.slice(0, 3),
      });
    }

    // DOM Updates Batch Log
    if (
      DEBUG.performance.domManipulation &&
      (this.currentBatch.domUpdates.hidden > 0 ||
        this.currentBatch.domUpdates.shown > 0 ||
        this.currentBatch.domUpdates.titleChanges > 0)
    ) {
      console.log(`[Performance ${timestamp}] domManipulation/batch:`, {
        hidden: this.currentBatch.domUpdates.hidden,
        shown: this.currentBatch.domUpdates.shown,
        titleChanges: this.currentBatch.domUpdates.titleChanges,
      });
    }

    // Filtering Batch Log
    if (
      DEBUG.performance.filtering &&
      (this.currentBatch.filtering.wordMatches > 0 ||
        this.currentBatch.filtering.priceExceeded > 0)
    ) {
      console.log(`[Performance ${timestamp}] filtering/batch:`, {
        wordMatches: this.currentBatch.filtering.wordMatches,
        priceExceeded: this.currentBatch.filtering.priceExceeded,
      });
    }

    this.resetBatch();
  }
}

// Globale Performance-Tracker-Instanz
const perfTracker = new PerformanceTracker();

// Performance-Summary alle 30 Sekunden (wenn enabled)
if (DEBUG.performance.enabled && DEBUG.performance.summary) {
  setInterval(() => {
    perfTracker.showSummary();
    // Optional: Metriken nach jeder Summary zur√ºcksetzen
    // perfTracker.reset();
  }, 30000);
}

// === Performance-Helper-Funktionen ===
// Manuelles Abrufen der Performance-Summary √ºber Console
(function () {
  "use strict";

  // Definiere Performance-API am globalen window-Objekt
  const api = {
    summary: () => perfTracker.showSummary(),
    reset: () => perfTracker.reset(),
    enable: () => {
      DEBUG.performance.enabled = false;
      console.log("‚úÖ Performance-Tracking aktiviert");
    },
    disable: () => {
      DEBUG.performance.enabled = false;
      console.log("‚ùå Performance-Tracking deaktiviert");
    },
    enableAll: () => {
      Object.keys(DEBUG.performance).forEach((key) => {
        if (typeof DEBUG.performance[key] === "boolean") {
          DEBUG.performance[key] = true;
        }
      });
      console.log("‚úÖ Alle Performance-Logs aktiviert");
    },
    disableAll: () => {
      Object.keys(DEBUG.performance).forEach((key) => {
        if (typeof DEBUG.performance[key] === "boolean") {
          DEBUG.performance[key] = false;
        }
      });
      console.log("‚ùå Alle Performance-Logs deaktiviert");
    },
    get config() {
      return DEBUG.performance;
    },
    // Hilfsfunktion zum Aktivieren spezifischer Kategorien
    enableCategory: (category) => {
      if (DEBUG.performance.hasOwnProperty(category)) {
        DEBUG.performance[category] = true;
        console.log(`‚úÖ ${category} aktiviert`);
      } else {
        console.warn(`‚ùå Kategorie "${category}" nicht gefunden`);
      }
    },
    // Zeige verf√ºgbare Kategorien
    categories: () => {
      console.log("üìã Verf√ºgbare Performance-Kategorien:");
      Object.keys(DEBUG.performance).forEach((key) => {
        console.log(`  - ${key}: ${DEBUG.performance[key]}`);
      });
    },
  };

  // Setze am globalen window-Objekt
  if (typeof unsafeWindow !== "undefined") {
    unsafeWindow.mdmPerformance = api;
  } else {
    window.mdmPerformance = api;
  }

  if (DEBUG.performance.enabled) {
    console.log("üìä Performance-Tracking verf√ºgbar: window.mdmPerformance");
    console.log(
      "   Befehle: .enable(), .disable(), .summary(), .reset(), .categories()"
    );
  }
})();

// ===== Konstanten und Konfiguration =====
// --- Storage Keys ---
const VERSION_PREFIX = "mdm_version_";
const HIDDEN_DEALS_KEY = "hiddenDeals";
const HIDE_COLD_DEALS_KEY = "hideColdDeals";
const MAX_PRICE_KEY = "maxPrice";
const PREFERRED_SORT_KEY = "mydealz_preferred_sort";
const PREFERRED_TIMEFRAME_KEY = "mydealz_preferred_timeframe";
const LAST_VERSION_KEY = "mdm_last_version";
const CHANGELOG_URL =
  "https://greasyfork.org/de/scripts/522038-mydealz-manager/versions";
const UPDATE_NOTICE_SHOWN_KEY = "mdm_update_notice_shown";
const WHITELIST_WORDS_KEY = "whitelistWords";

// --- Selektoren ---
const ARTICLE_SELECTOR = ".thread--deal, .thread--type--list";
const MERCHANT_PAGE_SELECTOR = ".merchant-banner";

const FEED_CONTAINER_SELECTORS = [
  '[data-t="threadList"]',
  ".threadList",
  ".thread-list",
  ".itemList",
  "#content",
];

// Text Normalisierung Map f√ºr Sonderzeichen
const CHAR_NORMALIZATION_MAP = {
  √§: "a",
  √°: "a",
  √†: "a",
  √¢: "a",
  √£: "a",
  √∂: "o",
  √≥: "o",
  √≤: "o",
  √¥: "o",
  √µ: "o",
  √º: "u",
  √∫: "u",
  √π: "u",
  √ª: "u",
  √©: "e",
  √®: "e",
  √™: "e",
  √´: "e",
  √≠: "i",
  √¨: "i",
  √Æ: "i",
  √Ø: "i",
  √Ω: "y",
  √ø: "y",
  √±: "n",
  √ü: "ss",
};

function normalizeForSearch(text) {
  if (!text) return "";

  // Zu Lowercase konvertieren
  let normalized = text.toLowerCase();

  // Non-breaking Spaces und andere unsichtbare Zeichen zu normalen Spaces konvertieren
  // Dies behandelt &nbsp; (\u00A0) und andere Unicode-Leerzeichen
  normalized = normalized.replace(
    /[\u00A0\u202F\u2000-\u200B\u205F\u3000]/g,
    " "
  );

  // Alle Apostroph-Varianten zu normalem Apostroph konvertieren
  // ' (U+2018 Left Single Quotation), ' (U+2019 Right Single Quotation), ` (U+0060 Grave Accent)
  normalized = normalized.replace(/[\u2018\u2019\u0060]/g, "'");

  // Sonderzeichen normalisieren
  normalized = normalized
    .split("")
    .map((char) => CHAR_NORMALIZATION_MAP[char] || char)
    .join("");

  // Unicode normalisieren (NFD) und dann alle diakritischen Zeichen entfernen
  normalized = normalized.normalize("NFD").replace(/[\u0300-\u036f]/g, "");

  // Mehrfache Leerzeichen zu einem Leerzeichen reduzieren
  normalized = normalized.replace(/\s+/g, " ").trim();

  return normalized;
}

function formatTimestamp(date = new Date()) {
  const pad = (n) => n.toString().padStart(2, "0");
  const day = pad(date.getDate());
  const month = pad(date.getMonth() + 1);
  const year = date.getFullYear();
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  return `${day}.${month}.${year} ${hours}:${minutes}`;
}

// Debug-Timestamp mit Millisekunden
function getDebugTimestamp() {
  const now = new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const pad3 = (n) => n.toString().padStart(3, "0");
  const hours = pad(now.getHours());
  const minutes = pad(now.getMinutes());
  const seconds = pad(now.getSeconds());
  const ms = pad3(now.getMilliseconds());
  return `${hours}:${minutes}:${seconds}.${ms}`;
}

function pruneTimestampMap(mapObj, allowedKeys) {
  let changed = false;
  const allowSet = new Set(allowedKeys);
  Object.keys(mapObj).forEach((key) => {
    if (!allowSet.has(key)) {
      delete mapObj[key];
      changed = true;
    }
  });
  return changed;
}

function ensureWordTimestamps(words, createMissing = false) {
  let changed = false;
  const now = formatTimestamp();
  const legacyTimestamp = GM_getValue("mdm_legacy_timestamp");
  words.forEach((word) => {
    const key = normalizeForSearch(word);
    if (!wordAddedAt[key]) {
      if (createMissing) {
        // Neue Eintr√§ge: Exakter aktueller Timestamp
        wordAddedAt[key] = { timestamp: now, isLegacy: false };
        changed = true;
      } else {
        // Alte Eintr√§ge: Legacy-Timestamp (ungenau, "vor dem")
        wordAddedAt[key] = { timestamp: legacyTimestamp, isLegacy: true };
        changed = true;
      }
    }
  });
  const removed = pruneTimestampMap(wordAddedAt, words.map(normalizeForSearch));
  if (changed || removed) {
    GM_setValue("wordAddedAt", wordAddedAt);
  }
}

function ensureMerchantTimestamps(merchants, createMissing = false) {
  let changed = false;
  const now = formatTimestamp();
  const legacyTimestamp = GM_getValue("mdm_legacy_timestamp");
  merchants.forEach((merchant) => {
    const key =
      merchant?.id !== undefined && merchant?.id !== null
        ? String(merchant.id)
        : normalizeForSearch(merchant?.name || "");
    if (key && !merchantAddedAt[key]) {
      if (createMissing) {
        // Neue Eintr√§ge: Exakter aktueller Timestamp
        merchantAddedAt[key] = { timestamp: now, isLegacy: false };
        changed = true;
      } else {
        // Alte Eintr√§ge: Legacy-Timestamp (ungenau, "vor dem")
        merchantAddedAt[key] = { timestamp: legacyTimestamp, isLegacy: true };
        changed = true;
      }
    }
  });
  const allowedKeys = merchants
    .map((m) =>
      m?.id !== undefined && m?.id !== null
        ? String(m.id)
        : normalizeForSearch(m?.name || "")
    )
    .filter(Boolean);
  const removed = pruneTimestampMap(merchantAddedAt, allowedKeys);
  if (changed || removed) {
    GM_setValue("merchantAddedAt", merchantAddedAt);
  }
}

function ensureUserTimestamps(users, createMissing = false) {
  let changed = false;
  const now = formatTimestamp();
  const legacyTimestamp = GM_getValue("mdm_legacy_timestamp");
  users.forEach((user) => {
    const key = (user || "").toLowerCase();
    if (key && !userAddedAt[key]) {
      if (createMissing) {
        // Neue Eintr√§ge: Exakter aktueller Timestamp
        userAddedAt[key] = { timestamp: now, isLegacy: false };
        changed = true;
      } else {
        // Alte Eintr√§ge: Legacy-Timestamp (ungenau, "vor dem")
        userAddedAt[key] = { timestamp: legacyTimestamp, isLegacy: true };
        changed = true;
      }
    }
  });
  const removed = pruneTimestampMap(
    userAddedAt,
    users.map((u) => (u || "").toLowerCase())
  );
  if (changed || removed) {
    GM_setValue("userAddedAt", userAddedAt);
  }
}

function ensureWhitelistTimestamps(words, createMissing = false) {
  let changed = false;
  const now = formatTimestamp();
  const legacyTimestamp = GM_getValue("mdm_legacy_timestamp");
  words.forEach((word) => {
    const key = normalizeForSearch(word);
    if (!whitelistAddedAt[key]) {
      if (createMissing) {
        whitelistAddedAt[key] = { timestamp: now, isLegacy: false };
      } else {
        whitelistAddedAt[key] = { timestamp: legacyTimestamp, isLegacy: true };
      }
      changed = true;
    } else if (typeof whitelistAddedAt[key] === "string") {
      whitelistAddedAt[key] = {
        timestamp: whitelistAddedAt[key],
        isLegacy: true,
      };
      changed = true;
    }
  });
  const removed = pruneTimestampMap(
    whitelistAddedAt,
    words.map(normalizeForSearch)
  );
  if (changed || removed) {
    GM_setValue("whitelistAddedAt", whitelistAddedAt);
  }
}

function rebuildWhitelistCache(words) {
  const list = Array.isArray(words) ? words : [];
  whitelistCache = list.map((word) => normalizeForSearch(word)).filter(Boolean);
}

function findDealContainer() {
  for (const selector of FEED_CONTAINER_SELECTORS) {
    const element = document.querySelector(selector);
    if (element) return element;
  }

  const firstArticle = document.querySelector(ARTICLE_SELECTOR);
  return firstArticle?.parentElement ?? null;
}

function isDealNode(node) {
  if (!node) return false;

  if (node.nodeType === 1) {
    // ELEMENT_NODE
    if (node.matches?.(ARTICLE_SELECTOR)) return true;
    if (node.querySelector?.(ARTICLE_SELECTOR)) return true;
  }

  if (node.nodeType === 11) {
    // DOCUMENT_FRAGMENT_NODE
    return !!node.querySelector?.(ARTICLE_SELECTOR);
  }

  return false;
}

function mutationsAffectDeals(mutations) {
  // Schnelle Pr√ºfung ohne Array-Konvertierung
  for (const mutation of mutations) {
    if (mutation.type !== "childList") continue;

    // Direkte NodeList/HTMLCollection Pr√ºfung
    if (mutation.addedNodes.length) {
      for (const node of mutation.addedNodes) {
        if (isDealNode(node)) {
          return true;
        }
      }
    }

    if (mutation.removedNodes.length) {
      for (const node of mutation.removedNodes) {
        if (isDealNode(node)) {
          return true;
        }
      }
    }

    // Effiziente Target-Pr√ºfung
    const target = mutation.target;
    if (target?.closest?.(ARTICLE_SELECTOR)) {
      return true;
    }
  }

  return false;
}

const observerTargets = new WeakMap();

function observeDealMutations(observerInstance) {
  // Suche prim√§r nach dem Deal-Container
  const target = findDealContainer();
  if (!target) return;

  const currentTarget = observerTargets.get(observerInstance);
  if (currentTarget === target) return;

  // Beobachter nur neu verbinden wenn n√∂tig
  observerInstance.disconnect();
  observerInstance.observe(target, {
    childList: true,
    subtree: true,
  });
  observerTargets.set(observerInstance, target);
}

// --- System/Performance Konstanten ---
const CLEANUP_TIME = 30000;
const IS_TOUCH_DEVICE =
  "ontouchstart" in window ||
  navigator.maxTouchPoints > 0 ||
  navigator.msMaxTouchPoints > 0;

let excludeWordCache = [];
let whitelistCache = [];

let excludeMerchantsCache = {
  ids: new Set(),
  normalizedNames: new Set(),
};

function rebuildExcludeMerchantCache(merchants) {
  const list = Array.isArray(merchants) ? merchants : [];

  excludeMerchantsCache.ids = new Set(
    list
      .map((merchant) => merchant?.id)
      .filter((id) => id !== undefined && id !== null)
      .map((id) => String(id))
  );

  excludeMerchantsCache.normalizedNames = new Set(
    list
      .map((merchant) => normalizeForSearch(merchant?.name || ""))
      .filter(Boolean)
  );
}

function getArticleMerchantInfo(article) {
  if (!article) {
    return { merchantId: null, merchantName: null };
  }

  const dealId = article.getAttribute?.("id") || "unknown";
  const ids = new Set();
  const dataset = article.dataset || {};
  ["merchantId", "threadMerchantId", "merchantid", "threadmerchantid"].forEach(
    (key) => {
      if (dataset[key]) {
        ids.add(dataset[key]);
      }
    }
  );

  [
    "data-merchant-id",
    "data-thread-merchant-id",
    "data-thread-merchantid",
  ].forEach((attr) => {
    const value = article.getAttribute?.(attr);
    if (value) {
      ids.add(value);
    }
  });

  const merchantLink =
    article.querySelector?.('a[data-t="merchantLink"]') || null;
  if (merchantLink) {
    const linkDataset = merchantLink.dataset || {};
    ["merchantId", "merchantid", "tMerchantId", "tmerchantid"].forEach(
      (key) => {
        if (linkDataset[key]) {
          ids.add(linkDataset[key]);
        }
      }
    );

    const href = merchantLink.getAttribute("href") || "";
    const match = href.match(/merchant-id=(\d+)/i);
    if (match) {
      ids.add(match[1]);
    }
  }

  const merchantName =
    merchantLink?.textContent?.trim() ||
    article
      .querySelector?.(
        ".color--text-TranslucentSecondary.size--all-xs span:last-child"
      )
      ?.textContent?.trim() ||
    null;

  const merchantId = ids.size ? String(Array.from(ids)[0]).trim() : null;

  // DEBUG: Logge wenn merchantId verf√ºgbar wird (nur bei verbose)
  if (DEBUG.merchantInfoVerbose && merchantId && merchantLink) {
    console.log(`[${getDebugTimestamp()}] [MDM MerchantInfo] merchantId gefunden:`, {
      dealId,
      merchantId,
      merchantName,
      merchantLinkPresent: !!merchantLink,
      source: ids.size > 0 ? "data-attributes" : "href-parsing"
    });
  }

  return {
    merchantId: merchantId || null,
    merchantName: merchantName || null,
  };
}

function escapeRegex(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function createExcludeWordEntry(word) {
  if (typeof word !== "string" || !word.trim()) return null;

  const normalized = normalizeForSearch(word);
  if (!normalized) return null;

  // Bracket-Filter haben h√∂chste Priorit√§t - unterst√ºtzt [] und ()
  if ((normalized.startsWith("[") && normalized.endsWith("]")) ||
      (normalized.startsWith("(") && normalized.endsWith(")"))) {
    return {
      original: word,
      type: "bracket",
      normalized,
      matcher: (title) => title.includes(normalized),
    };
  }

  // UND+NEGATION Kombination: "Fl√ºge+Stuttgart -Berlin"
  // Pr√ºfe ZUERST auf Kombination (+ UND " -"), dann einzelne Filter
  if (normalized.includes("+") && normalized.includes(" -")) {
    const negationParts = normalized.split(/\s+-/).map((p) => p.trim()).filter(Boolean);
    if (negationParts.length === 2) {
      const [andPart, mustNotHave] = negationParts;
      const andTerms = andPart.split("+").map((p) => p.trim()).filter(Boolean);

      if (andTerms.length > 1) {
        // Erstelle Regexes f√ºr AND-Terme
        const andRegexes = andTerms.map((part) => {
          if (part.includes("*")) {
            let pattern = escapeRegex(part).replace(/\\\*/g, ".*");
            if (!part.startsWith("*")) pattern = "\\b" + pattern;
            if (!part.endsWith("*")) pattern = pattern + "\\b";
            return new RegExp(pattern, "i");
          }
          return new RegExp(escapeRegex(part), "i");
        });

        // Erstelle Regex f√ºr Negation-Term
        const createNegationRegex = (part) => {
          if (part.includes("*")) {
            let pattern = escapeRegex(part).replace(/\\\*/g, ".*");
            if (!part.startsWith("*")) pattern = "\\b" + pattern;
            if (!part.endsWith("*")) pattern = pattern + "\\b";
            return new RegExp(pattern, "i");
          }
          return new RegExp(escapeRegex(part), "i");
        };
        const mustNotHaveRegex = createNegationRegex(mustNotHave);

        return {
          original: word,
          type: "and-negation",
          normalized,
          andTerms,
          mustNotHave,
          matcher: (title) => {
            // ALLE UND-Terme m√ºssen vorkommen
            if (!andRegexes.every((regex) => regex.test(title))) return false;
            // ABER NICHT das Negations-Wort
            if (mustNotHaveRegex.test(title)) return false;
            return true;
          },
        };
      }
    }
  }

  // NEGATION-Filter (UND-Verkn√ºpfung): Alle Negations-W√∂rter m√ºssen vorkommen
  // Syntax: "Fritz!Fon -bundle+-router" ‚Üí matched "Fritz!Fon" ABER NICHT wenn "bundle" UND "router" BEIDE vorkommen
  // WICHTIG: Muss VOR dem normalen UND-Filter gepr√ºft werden!
  if (normalized.includes(" -") && normalized.match(/-[^-\s]+\+-/)) {
    const mainPart = normalized.split(" -")[0].trim();
    const negationPart = normalized.substring(mainPart.length).trim();
    const negationTerms = negationPart
      .split(/\s+-/) // Split bei " -"
      .map(p => p.trim())
      .filter(Boolean)
      .flatMap(group => group.split("+").map(t => t.trim()).filter(Boolean))
      .map(term => term.startsWith("-") ? term.substring(1) : term); // Entferne f√ºhrendes "-"

    if (DEBUG.wordFilter) {
      console.log("[MDM WordFilter] üîß Parsing negation-and filter:", {
        original: word,
        normalized,
        mainPart,
        negationPart,
        negationTerms
      });
    }

    if (negationTerms.length >= 2) {
      const createRegex = (part) => {
        if (part.includes("*")) {
          let pattern = escapeRegex(part).replace(/\\\*/g, ".*");
          if (!part.startsWith("*")) pattern = "\\b" + pattern;
          if (!part.endsWith("*")) pattern = pattern + "\\b";
          return new RegExp(pattern, "i");
        }
        return new RegExp(escapeRegex(part), "i");
      };

      const mustHaveRegex = createRegex(mainPart);
      const negationRegexes = negationTerms.map(createRegex);

      return {
        original: word,
        type: "negation-and",
        normalized,
        mustHave: mainPart,
        mustNotHave: negationTerms.join(" UND "),
        matcher: (title) => {
          const hasMainWord = mustHaveRegex.test(title);
          const allNegationsPresent = negationRegexes.every((regex) => regex.test(title));

          if (DEBUG.wordFilter) {
            console.log("[MDM WordFilter] üéØ Testing negation-and filter:", {
              filter: word,
              title: title.substring(0, 100),
              hasMainWord,
              allNegationsPresent,
              negationTests: negationRegexes.map((regex, i) => ({
                term: negationTerms[i],
                regex: regex.source,
                matches: regex.test(title)
              })),
              willFilter: hasMainWord && allNegationsPresent
            });
          }

          // Muss Hauptwort enthalten
          if (!hasMainWord) return false;
          // Filtere NUR wenn ALLE Negations-W√∂rter vorkommen
          if (allNegationsPresent) return true;
          return false;
        },
      };
    }
  }

  // UND-Filter: Alle W√∂rter m√ºssen vorkommen (egal in welcher Reihenfolge)
  if (normalized.includes("+")) {
    const parts = normalized
      .split("+")
      .map((p) => p.trim())
      .filter(Boolean);
    if (parts.length > 1) {
      // Unterst√ºtzung f√ºr Wildcards in UND-Filter-Teilen
      const regexes = parts.map((part) => {
        if (part.includes("*")) {
          let pattern = escapeRegex(part).replace(/\\\*/g, ".*");
          if (!part.startsWith("*")) pattern = "\\b" + pattern;
          if (!part.endsWith("*")) pattern = pattern + "\\b";
          return new RegExp(pattern, "i");
        }
        // Normale Teile AUCH mit Wortgrenzen
        return new RegExp(`\\b${escapeRegex(part)}\\b`, "i");
      });
      return {
        original: word,
        type: "and",
        normalized,
        parts,
        matcher: (title) => regexes.every((regex) => regex.test(title)),
      };
    }
  }

  // NEGATION-Filter (UND-Verkn√ºpfung): Alle Negations-W√∂rter m√ºssen vorkommen
  // Syntax: "Fritz!Fon -bundle+-router" ‚Üí matched "Fritz!Fon" ABER NICHT wenn "bundle" UND "router" BEIDE vorkommen
  if (normalized.includes(" -") && normalized.match(/-[^-\s]+\+-/)) {
    const mainPart = normalized.split(" -")[0].trim();
    const negationPart = normalized.substring(mainPart.length).trim();
    const negationTerms = negationPart
      .split(/\s+-/)
      .map(p => p.trim())
      .filter(Boolean)
      .flatMap(group => group.split("+").map(t => t.trim()).filter(Boolean));

    if (DEBUG.wordFilter) {
      console.log("[MDM WordFilter] üîß Parsing negation-and filter:", {
        original: word,
        normalized,
        mainPart,
        negationPart,
        negationTerms
      });
    }

    if (negationTerms.length >= 2) {
      const createRegex = (part) => {
        if (part.includes("*")) {
          let pattern = escapeRegex(part).replace(/\\\*/g, ".*");
          if (!part.startsWith("*")) pattern = "\\b" + pattern;
          if (!part.endsWith("*")) pattern = pattern + "\\b";
          return new RegExp(pattern, "i");
        }
        return new RegExp(escapeRegex(part), "i");
      };

      const mustHaveRegex = createRegex(mainPart);
      const negationRegexes = negationTerms.map(createRegex);

      return {
        original: word,
        type: "negation-and",
        normalized,
        mustHave: mainPart,
        mustNotHave: negationTerms.join(" UND "),
        matcher: (title) => {
          const hasMainWord = mustHaveRegex.test(title);
          const allNegationsPresent = negationRegexes.every((regex) => regex.test(title));

          if (DEBUG.wordFilter) {
            console.log("[MDM WordFilter] üéØ Testing negation-and filter:", {
              filter: word,
              title: title.substring(0, 100),
              hasMainWord,
              allNegationsPresent,
              negationTests: negationRegexes.map((regex, i) => ({
                term: negationTerms[i],
                regex: regex.source,
                matches: regex.test(title)
              })),
              willFilter: hasMainWord && allNegationsPresent
            });
          }

          // Muss Hauptwort enthalten
          if (!hasMainWord) return false;
          // Filtere NUR wenn ALLE Negations-W√∂rter vorkommen
          if (allNegationsPresent) return true;
          return false;
        },
      };
    }
  }

  // NEGATION-Filter (ODER-Verkn√ºpfung): Eines der Negations-W√∂rter reicht
  // Syntax: "Fritz!Fon -bundle -router" ‚Üí matched "Fritz!Fon" ABER NICHT wenn "bundle" ODER "router" vorkommt
  if (normalized.includes(" -")) {
    const parts = normalized
      .split(/\s+-/)
      .map((p) => p.trim())
      .filter(Boolean);
    if (parts.length >= 2) {
      const mustHave = parts[0];
      const mustNotHaveList = parts.slice(1);

      const createRegex = (part) => {
        if (part.includes("*")) {
          let pattern = escapeRegex(part).replace(/\\\*/g, ".*");
          if (!part.startsWith("*")) pattern = "\\b" + pattern;
          if (!part.endsWith("*")) pattern = pattern + "\\b";
          return new RegExp(pattern, "i");
        }
        return new RegExp(escapeRegex(part), "i");
      };

      const mustHaveRegex = createRegex(mustHave);
      const mustNotHaveRegexes = mustNotHaveList.map(createRegex);

      return {
        original: word,
        type: "negation-or",
        normalized,
        mustHave,
        mustNotHave: mustNotHaveList.join(" ODER "),
        matcher: (title) => {
          const hasMainWord = mustHaveRegex.test(title);
          const anyNegationPresent = mustNotHaveRegexes.some((regex) => regex.test(title));

          if (DEBUG.wordFilter) {
            console.log("[MDM WordFilter] üéØ Testing negation-or filter:", {
              filter: word,
              title: title.substring(0, 100),
              hasMainWord,
              anyNegationPresent,
              negationTests: mustNotHaveRegexes.map((regex, i) => ({
                term: mustNotHaveList[i],
                regex: regex.source,
                matches: regex.test(title)
              })),
              willFilter: hasMainWord && anyNegationPresent
            });
          }

          // Muss Hauptwort enthalten
          if (!hasMainWord) return false;
          // Filtere wenn EINES der Negations-W√∂rter vorkommt
          if (anyNegationPresent) return true;
          return false;
        },
      };
    }
  }

  // Wildcard-Logik: * als Platzhalter (NUR wenn keine Kombination mit + oder - vorliegt)
  if (normalized.includes("*")) {
    // Escape Regex-Sonderzeichen au√üer *
    let pattern = escapeRegex(normalized).replace(/\\\*/g, ".*");
    // Wortgrenzen nur setzen, wenn kein * am Anfang/Ende
    if (!normalized.startsWith("*")) pattern = "\\b" + pattern;
    if (!normalized.endsWith("*")) pattern = pattern + "\\b";
    const regex = new RegExp(pattern, "i");
    return {
      original: word,
      type: "wildcard",
      normalized,
      regex,
      matcher: (title) => regex.test(title),
    };
  }

  if (normalized.includes(" ") || normalized.includes("-")) {
    const parts = normalized.split(" ").filter(Boolean);
    const firstWord = parts[0] || normalized;
    const firstWordRegex = new RegExp(`\\b${escapeRegex(firstWord)}\\b`, "i");
    return {
      original: word,
      type: "phrase",
      normalized,
      firstWordRegex,
      matcher: (title) => {
        if (firstWordRegex && !firstWordRegex.test(title)) {
          return false;
        }
        return title.includes(normalized);
      },
    };
  }

  const regex = new RegExp(`\\b${escapeRegex(normalized)}\\b`, "i");
  return {
    original: word,
    type: "simple",
    normalized,
    regex,
    matcher: (title) => regex.test(title),
  };
}

function rebuildExcludeWordCache(words) {
  const list = Array.isArray(words) ? words : [];
  excludeWordCache = list.map(createExcludeWordEntry).filter(Boolean);

  // Hash √ºber alle Filter-Inhalte berechnen f√ºr Cache-Invalidierung
  excludeWordsHash = simpleHash(list.join('|'));

  if (DEBUG.wordFilter) {
    const fritzfonFilters = excludeWordCache.filter(f =>
      f.original.toLowerCase().includes('fritz') ||
      f.normalized.toLowerCase().includes('fritz')
    );

    console.log("[MDM WordFilter] üìã Rebuilt filter cache:", {
      totalWords: list.length,
      totalFilters: excludeWordCache.length,
      excludeWordsHash,
      filterTypes: excludeWordCache.reduce((acc, f) => {
        acc[f.type] = (acc[f.type] || 0) + 1;
        return acc;
      }, {}),
      fritzfonFilters: fritzfonFilters
    });
  }
}

// --- Feature Flags ---
const FEATURES = {
  hideMatchingMerchantNames: "hideMatchingMerchantNames",
  rememberSort: "rememberSort",
};

// ===== Instanzerkennung und Cleanup =====
(function detectMultipleInstances() {
  const currentVersion = GM_info.script.version;
  const now = Date.now();

  try {
    // Setze Marker f√ºr diese Version
    const myKey = VERSION_PREFIX + currentVersion;
    localStorage.setItem(myKey, now.toString());

    // Pr√ºfe auf alle aktiven Versionen
    const activeVersions = new Set();
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key?.startsWith(VERSION_PREFIX)) continue;

      const version = key.replace(VERSION_PREFIX, "");
      const timestamp = parseInt(localStorage.getItem(key) || "0");

      if (now - timestamp < CLEANUP_TIME) {
        activeVersions.add(version);
      }
    }

    if (activeVersions.size > 1) {
      const warningMsg = `‚ö†Ô∏è Warnung: Es wurden mehrere Versionen des mydealz Managers gefunden!\n\nAktive Versionen:\n${Array.from(
        activeVersions
      ).join(
        "\n"
      )}\n\nBitte deaktiviere alle Versionen bis auf eine in deinem Script-Manager.`;
      alert(warningMsg);
    }
  } catch (e) {
    console.error("Error in instance detection:", e);
  }
})();

(function notifyOnUpdate() {
  const currentVersion = GM_info?.script?.version ?? "unbekannt";

  try {
    const previousGMVersion = GM_getValue(LAST_VERSION_KEY, null);
    const previousLSVersion = localStorage.getItem(LAST_VERSION_KEY);
    const previousVersion = previousGMVersion || previousLSVersion;

    // Wenn es keine vorherige Version gibt oder sich die Version ge√§ndert hat
    if (!previousVersion || previousVersion !== currentVersion) {
      // Setze Flag dass Update-Hinweis angezeigt werden soll
      GM_setValue(UPDATE_NOTICE_SHOWN_KEY, false);
    }

    GM_setValue(LAST_VERSION_KEY, currentVersion);
    localStorage.setItem(LAST_VERSION_KEY, currentVersion);
  } catch (error) {
    console.error("Update-Check konnte nicht ausgef√ºhrt werden:", error);
  }
})();

// Cleanup beim Entladen der Seite
window.addEventListener("unload", () => {
  try {
    localStorage.removeItem(VERSION_PREFIX + GM_info.script.version);
  } catch (e) {
    // Ignoriere Fehler beim Cleanup
  }
});

// ===== UI-Ressourcen =====
// --- Font Awesome Einbindung ---
const fontAwesomeLink = document.createElement("link");
fontAwesomeLink.rel = "stylesheet";
fontAwesomeLink.href =
  "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css";
document.head.appendChild(fontAwesomeLink);

// --- Style Elemente ---
const preventAutoCloseStyle = document.createElement("style");
preventAutoCloseStyle.textContent = ``;
document.head.appendChild(preventAutoCloseStyle);

const managerHideStyle = document.createElement("style");
managerHideStyle.textContent = `.mydealz-manager-hidden, article[data-hidden-by-mydealz-manager="true"] { display: none !important; }`;
document.head.appendChild(managerHideStyle);

// ===== UI-Konfiguration =====
// --- Titel-Speicher ---
const ORIGINAL_TITLES = new Map();

// DEBUG: ORIGINAL_TITLES global verf√ºgbar machen (nur f√ºr Debugging)
if (typeof unsafeWindow !== "undefined") {
  unsafeWindow.ORIGINAL_TITLES = ORIGINAL_TITLES;
} else {
  window.ORIGINAL_TITLES = ORIGINAL_TITLES;
}

// ===== Observer-Konfiguration =====
let processingScheduled = false;

const observer = new MutationObserver(
  throttle(
    (mutations) => {
      perfTracker.start("observer");
      perfTracker.update("observer.calls", 1);

      if (DEBUG.delayDebug) {
        console.log(
          `[${getDebugTimestamp()}] üîç [DELAY DEBUG] Observer triggered:`,
          { mutationCount: mutations.length, throttleDelay: '1500ms' }
        );
      }

      if (DEBUG.performance.observer) {
        perfTracker.log("observer", "triggered", {
          mutationCount: mutations.length,
          types: mutations.map((m) => m.type).join(", "),
        });
      }

      // DEBUG: Logge Merchant-Link √Ñnderungen
      if (DEBUG.merchantFilter) {
        for (const mutation of mutations) {
          if (mutation.type === "childList" && mutation.addedNodes.length) {
            for (const node of mutation.addedNodes) {
              // Pr√ºfe ob ein merchantLink hinzugef√ºgt wurde
              if (node.nodeType === 1) { // Element node
                const merchantLinks = node.matches?.('a[data-t="merchantLink"]')
                  ? [node]
                  : node.querySelectorAll?.('a[data-t="merchantLink"]') || [];

                if (merchantLinks.length > 0) {
                  merchantLinksChangedSinceLastBatch = true;
                  const deal = node.closest?.(ARTICLE_SELECTOR);
                  const dealId = deal?.getAttribute?.("id") || "unknown";
                  console.log(`[${getDebugTimestamp()}] [MDM Observer] merchantLink hinzugef√ºgt:`, {
                    dealId,
                    merchantLinks: merchantLinks.length,
                    willTriggerReprocess: true
                  });
                }
              }
            }
          }
        }
      }

      // Schnelle Vorpr√ºfung auf relevante √Ñnderungen
      if (!mutations.some((m) => m.type === "childList")) {
        const duration = perfTracker.end("observer");
        if (DEBUG.performance.observer) {
          perfTracker.log("observer", "skipped-no-childList", {
            duration: `${duration.toFixed(2)}ms`,
          });
        }
        return;
      }

      observeDealMutations(observer);
      if (!mutationsAffectDeals(mutations)) {
        const duration = perfTracker.end("observer");
        if (DEBUG.performance.observer) {
          perfTracker.log("observer", "skipped-no-deals", {
            duration: `${duration.toFixed(2)}ms`,
          });
        }
        return;
      }

      // Verhindere doppelte Verarbeitung
      if (processingScheduled) {
        const duration = perfTracker.end("observer");
        if (DEBUG.performance.observer) {
          perfTracker.log("observer", "skipped-already-scheduled", {
            duration: `${duration.toFixed(2)}ms`,
          });
        }
        return;
      }

      processingScheduled = true;

      if (DEBUG.delayDebug) {
        console.log(
          `[${getDebugTimestamp()}] üìÖ [DELAY DEBUG] processArticles scheduled via requestAnimationFrame`
        );
      }

      // Verz√∂gerte Verarbeitung um mehrere √Ñnderungen zu b√ºndeln
      requestAnimationFrame(() => {
        if (DEBUG.delayDebug) {
          console.log(
            `[${getDebugTimestamp()}] ‚ñ∂Ô∏è [DELAY DEBUG] requestAnimationFrame executing`
          );
        }
        processArticles();
        addSettingsButton();
        addHideButtons();

        processingScheduled = false;

        const duration = perfTracker.end("observer");
        perfTracker.update("observer.totalTime", duration);

        if (DEBUG.performance.observer) {
          perfTracker.log("observer", "completed", {
            duration: `${duration.toFixed(2)}ms`,
          });
        }
      });
    },
    1500,
    { leading: true, trailing: true }
  )
);

// ===== UI-Zustand =====
// --- Hauptfenster ---
let isSettingsOpen = false;
let activeSubUI = null;
let dealThatOpenedSettings = null;

// --- UI-Elemente ---
let settingsDiv = null;
let merchantListDiv = null;
let wordsListDiv = null;
let blockedUsersDiv = null;
let uiClickOutsideHandler = null;

// ===== Filter-Zustand =====
// --- Ausschlusslisten ---
let excludeWords = [];
let whitelistWords = [];
let excludeMerchantIDs = [];
let hiddenDeals = [];

// --- Filter-Einstellungen ---
let hideColdDeals = false;
let maxPrice = 0;

// ===== Tempor√§re Daten =====
// --- Vorschl√§ge ---
let suggestedWords = [];
let suggestionClickHandler = null;

// ===== Men√º-Commands =====
// --- Command IDs ---
let menuCommandId;
let restoreCommandId;

// --- Feature-Flags ---
let hideMatchingMerchantNames = GM_getValue("hideMatchingMerchantNames", false);
// WICHTIG: Sofort auf window setzen, BEVOR Observer triggern kann!
window.hideMatchingMerchantNames = hideMatchingMerchantNames;

// --- Tempor√§re Listen ---
let recentHiddenDeals = [];

// ===== Initialisierungs-Schutz =====
// Verhindert mehrfache Ausf√ºhrung von init() pro Seitenladung
let initHasRun = false;

// ===== Delayed Re-Check Schutz =====
// Verhindert mehrfache parallele Delayed Re-Checks f√ºr Merchant-Filter
let delayedMerchantRecheckScheduled = false;
// Intelligente Guards gegen unn√∂tige Re-Checks
let lastSuccessfulMerchantRecheck = 0;
let lastKnownDealCount = 0;

// ===== processArticles() Debounce =====
// Verhindert redundante Batches wenn sich nichts ge√§ndert hat
let lastProcessArticlesTime = 0;
let lastProcessArticlesDealCount = 0;
let merchantLinksChangedSinceLastBatch = false;

// --- Sortier-States f√ºr Filterlisten ---
let listSortStates = {
  words: { mode: "added", ascending: false }, // Standard: Neu ‚Üí Alt entspricht Speicher-Reihenfolge
  merchants: { mode: "added", ascending: false },
  users: { mode: "added", ascending: false },
};

// --- Timestamps f√ºr Filtereintr√§ge ---
let wordAddedAt = GM_getValue("wordAddedAt", {}); // key: normalized word
let merchantAddedAt = GM_getValue("merchantAddedAt", {}); // key: merchant id (string)
let userAddedAt = GM_getValue("userAddedAt", {}); // key: username lowercased
let whitelistAddedAt = GM_getValue("whitelistAddedAt", {}); // key: normalized word

// --- Legacy Timestamp (f√ºr Eintr√§ge aus √§lteren Script-Versionen ohne Timestamp) ---
// Wird einmalig beim ersten Laden des Scripts in dieser Version gesetzt und bleibt dann dauerhaft
// Dies wird verwendet, um alte Eintr√§ge zu markieren mit "Hinzugef√ºgt VOR DEM [Datum]" (ungenau)
// w√§hrend neue Eintr√§ge mit "Hinzugef√ºgt AM [Datum]" (genau) markiert werden
if (!GM_getValue("mdm_legacy_timestamp_initialized")) {
  const legacyTimestamp = formatTimestamp();
  GM_setValue("mdm_legacy_timestamp", legacyTimestamp);
  GM_setValue("mdm_legacy_timestamp_initialized", true);
}
//#endregion

//#region --- 2. Hilfsfunktionen (Utility Functions) ---
// ===== HTML & Text Verarbeitung =====
// HTML dekodieren
function decodeHtml(html) {
  const txt = document.createElement("textarea");
  txt.innerHTML = html;
  return txt.value;
}

// Regex-Sonderzeichen escapen
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// ===== Performance Optimierung =====
// Funktion zur Begrenzung der Ausf√ºhrungsh√§ufigkeit (Throttling)
function throttle(func, limit, options = { leading: true, trailing: false }) {
  let inThrottle;
  let lastArgs;
  let lastThis;
  let trailingTimeoutId;

  return function (...args) {
    lastArgs = args;
    lastThis = this;

    if (!inThrottle) {
      // F√ºhre sofort aus (leading)
      if (options.leading) {
        func.apply(this, args);
      }

      inThrottle = true;

      setTimeout(() => {
        // Wenn trailing aktiviert und es gab weitere Aufrufe
        if (options.trailing && lastArgs) {
          func.apply(lastThis, lastArgs);
        }

        inThrottle = false;
        lastArgs = null;
        lastThis = null;
      }, limit);
    }
  };
}

// === Sortierung ===
// Zentrale Sortierfunktion f√ºr Listen
function sortFilterList(list, mode, ascending = true) {
  if (mode === "alphabetical") {
    const sorted = [...list].sort((a, b) => {
      const valA = (a.name || a.word || a.username || a)
        .toString()
        .toLowerCase();
      const valB = (b.name || b.word || b.username || b)
        .toString()
        .toLowerCase();
      return valA.localeCompare(valB, "de", { sensitivity: "base" });
    });
    return ascending ? sorted : sorted.reverse();
  }

  // mode === 'added': Preserve stored order = Neu ‚Üí Alt; flip only when explicitly requested
  const addedOrder = [...list];
  return ascending ? addedOrder.reverse() : addedOrder;
}

// Liefert Theme-spezifische Farben basierend auf aktuellem Theme
function getThemeColors() {
  // Theme-Erkennung inline
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const htmlElement = document.documentElement;
  const bodyElement = document.body;

  const isDark =
    htmlElement.classList.contains("dark") ||
    bodyElement.classList.contains("dark") ||
    htmlElement.getAttribute("data-theme") === "dark" ||
    document.querySelector('html[data-theme="dark"]') !== null ||
    (prefersDark && !htmlElement.classList.contains("light"));

  // Direkt die entsprechenden Farben zur√ºckgeben
  return isDark ? THEME_COLORS.dark : THEME_COLORS.light;
}

// === Text-Analyse ===
// W√∂rter aus Deal-Titel extrahieren
function getWordsFromTitle(deal) {
  const titleElement = deal.querySelector(".thread-title a");
  if (!titleElement) return [];

  // WICHTIG: Verwende ORIGINAL_TITLES f√ºr Wortvorschl√§ge, damit H√§ndlernamen verf√ºgbar bleiben
  const dealId = deal.id || deal.getAttribute("data-thread-id");
  let rawTitle;

  if (dealId && ORIGINAL_TITLES.has(dealId)) {
    // Nutze den gespeicherten Originaltitel
    rawTitle = ORIGINAL_TITLES.get(dealId);
  } else {
    // Fallback: Hole Titel aus DOM
    rawTitle =
      titleElement.querySelector("a")?.getAttribute("title") ||
      titleElement.innerText ||
      "";
  }

  const keepWords = [
    "von",
    "der",
    "die",
    "das",
    "bei",
    "mit",
    "und",
    "oder",
    "auf",
    "f√ºr",
    "durch",
    "bis",
    "ab",
  ];
  const ignoreWords = [
    "Euro",
    "EUR",
    "VSK",
    "‚Ç¨",
    "VGP",
    "cent",
    "Cent",
    "o.", // oder
    "z.B.",
    "z.b.", // zum Beispiel
    "inkl.", // inklusive
    "max.", // maximal
    "min.", // minimal
    "ca.", // circa
    "vs.", // versus
    "eff.", // effektiv
    "mtl.", // monatlich
    "bzw.", // beziehungsweise
    "evtl.", // eventuell
    "uvm.", // und vieles mehr
    "etc.", // et cetera
    "zzgl.", // zuz√ºglich
    "Nr.",
    "nr.", // Nummer
    "St.",
    "st.", // St√ºck
    "usw.", // und so weiter
    "u.a.", // unter anderem
    "u.U.", // unter Umst√§nden
    "ggf.", // gegebenenfalls
    "p.", // pro/per
  ];
  const ignoreChars = ["&", "+", "!", "-", "/", "%", "‚Äì"];
  const units = ["MB/s", "GB/s", "KB/s", "Mbit/s", "Gbit/s", "Kbit/s"];
  const priceContextWords = ["effektiv"];
  const specialBrands = ["RTL+"];

  const isDate = (word) => {
    return /^\d{1,2}[.,]\d{1,2}(?:[.,]\d{2,4})?$/.test(word);
  };

  const isPriceContext = (word) => {
    if (!priceContextWords.includes(word.toLowerCase())) return false;
    // Pr√ºfe ob im Titel ein Preis vorkommt
    const hasPricePattern = /\d+(?:[.,]\d{2})?(?:‚Ç¨|EUR|Euro)/i;
    return hasPricePattern.test(rawTitle);
  };

  const isPrice = (word) => {
    return (
      /^~?\d+(?:[.,]\d{2})?(?:‚Ç¨|EUR)?$/.test(word) ||
      /^\d+(?:[.,]\d{2})?(?:\s*cent|\s*Cent)$/i.test(word)
    );
  };

  const isPercentage = (word) => {
    return /^\d+\s*%?$/.test(word) && rawTitle.includes("%");
  };

  const cleanWord = (word) => {
    // Check for special brands first
    if (specialBrands.includes(word)) {
      return word;
    }

    // Rest of the existing cleanWord function
    if (units.some((unit) => word.includes(unit))) {
      const cleanedWord = word.trim();
      return cleanedWord.replace(/[,;:!?.]+$/, "");
    }

    return word
      .trim()
      .replace(/^[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]+|[^a-zA-Z0-9√§√∂√º√Ñ√ñ√ú√ü]+$/g, "")
      .replace(/^[&+!%‚Äì]+$/, "")
      .replace(/[-,]+$/, "");
  };

  const shouldKeepWord = (word) => {
    const lowerWord = word.toLowerCase();

    if (!word || word.length === 0) return false;
    if (ignoreChars.includes(word)) return false;
    if (ignoreWords.some((ignore) => ignore.toLowerCase() === lowerWord)) return false;
    if (isDate(word)) return false;
    if (isPrice(word)) return false;
    if (isPercentage(word)) return false;
    if (isPriceContext(word)) return false;

    // Behalte spezielle W√∂rter
    if (keepWords.includes(lowerWord)) return true;
    if (units.some((unit) => word === unit)) return true;

    return true;
  };

  const splitTitle = (title) => {
    // Tempor√§r Einheiten und Abk√ºrzungen sch√ºtzen
    let tempTitle = title;
    const replacements = new Map();

    // Erst die Einheiten sch√ºtzen
    units.forEach((unit, index) => {
      const placeholder = `__UNIT${index}__`;
      while (tempTitle.includes(unit)) {
        tempTitle = tempTitle.replace(unit, placeholder);
        replacements.set(placeholder, unit);
      }
    });

    // Dann die Abk√ºrzungen sch√ºtzen (z.B. "o." als ganzes Wort)
    ignoreWords.forEach((word, index) => {
      if (word.includes(".")) {
        const placeholder = `__ABBR${index}__`;
        // Verbesserte Regex f√ºr Abk√ºrzungen, die auch Zahlen ber√ºcksichtigt
        const regex = new RegExp(
          `\\b${word.replace(".", "\\.")}\\s*(?=\\d|\\s|$)`,
          "g"
        );
        while (regex.test(tempTitle)) {
          tempTitle = tempTitle.replace(regex, (match) => {
            const replacement = " "; // Ersetze Abk√ºrzung durch Leerzeichen
            return replacement;
          });
        }
      }
    });

    // Split und Platzhalter wiederherstellen
    return tempTitle
      .split(/[\s\/]+/)
      .map((word) => {
        replacements.forEach((original, placeholder) => {
          if (word.includes(placeholder)) {
            word = word.replace(placeholder, original);
          }
        });
        return word;
      })
      .filter((word) => word.length > 0); // Entferne leere Strings
  };

  return splitTitle(rawTitle)
    .map(cleanWord)
    .filter(shouldKeepWord)
    .filter((word, index, self) => self.indexOf(word) === index);
}

//#endregion

//#region --- 3. Datenverwaltung ---
// ===== Einstellungen laden/speichern =====
// Laden aller gespeicherten Einstellungen
function loadSettings() {
  if (DEBUG.initialization) {
    console.log("[MDM] üì• loadSettings() called, DEBUG.wordFilter =", DEBUG.wordFilter);
  }

  if (DEBUG.priceFilter) {
    console.log("[MDM PriceFilter] ‚öôÔ∏è loadSettings() called - loading maxPrice...");
  }

  // Lade Wortfilter und H√§ndlerfilter
  excludeWords = loadExcludeWords();

  if (DEBUG.wordFilter) {
    console.log("[MDM WordFilter] üì• Loading exclude words:", {
      count: excludeWords.length,
      sample: excludeWords.slice(0, 5)
    });
  }

  rebuildExcludeWordCache(excludeWords);
  whitelistWords = loadWhitelistWords();
  rebuildWhitelistCache(whitelistWords);
  const merchantsData = loadExcludeMerchants();
  excludeMerchantIDs = merchantsData.map((m) => m.id);
  rebuildExcludeMerchantCache(merchantsData);

  // Lade Preisfilter
  maxPrice = parseFloat(GM_getValue("maxPrice", 0)) || 0;

  if (DEBUG.priceFilter) {
    console.log("[MDM PriceFilter] ‚öôÔ∏è loadSettings: maxPrice loaded:", {
      storedValue: GM_getValue("maxPrice", 0),
      parsedValue: maxPrice,
      type: typeof maxPrice,
      willFilter: maxPrice > 0
    });
  }

  // Lade UI-Einstellungen
  hideColdDeals = GM_getValue("hideColdDeals", false);
  hideMatchingMerchantNames = GM_getValue("hideMatchingMerchantNames", false);

  // Lade versteckte Deals
  hiddenDeals = GM_getValue("hiddenDeals", []);

  // Migriere alte User-Array-Daten zu Object-Format
  const blockedUsersData = GM_getValue("blockedUsers", null);
  if (Array.isArray(blockedUsersData)) {
    // Alte Array-Struktur ‚Üí Konvertiere zu Object
    const blockedUsersObj = {};
    blockedUsersData.forEach(username => {
      const normalized = username.toLowerCase();
      blockedUsersObj[normalized] = {
        displayName: username,
        normalizedUsername: normalized,
        timestamp: Date.now()
      };
    });
    GM_setValue("blockedUsers", blockedUsersObj);
    if (DEBUG.userBlocking) {
      console.log('[MDM UserBlock] Migrated old array to object format:', blockedUsersObj);
    }
  } else if (!blockedUsersData) {
    // Initialisiere mit leerem Object
    GM_setValue("blockedUsers", {});
  }

  // Lade Sortierungsspeicher-Einstellung
  window.rememberSort = GM_getValue("rememberSort", true);
}

const combinedObserver = new MutationObserver(
  throttle((mutations) => {
    observeDealMutations(combinedObserver);
    if (!mutationsAffectDeals(mutations)) return;

    processArticles();
    // addSettingsButton und addHideButtons werden bereits IN processArticles() aufgerufen
  }, 500)
);

// Observer starten
observeDealMutations(combinedObserver);

// ===== Wortfilter-Verwaltung =====
// Speichern von Wortfiltern
function saveExcludeWords(words, createMissingTimestamps = false) {
  // Normalisiere Gro√ü-/Kleinschreibung und entferne Duplikate
  const normalizedWords = words.reduce((acc, word) => {
    const lowerWord = word.toLowerCase();
    const exists = acc.some((w) => w.toLowerCase() === lowerWord);
    if (!exists) {
      acc.push(word);
    }
    return acc;
  }, []);

  excludeWords = normalizedWords;
  rebuildExcludeWordCache(excludeWords);

  ensureWordTimestamps(excludeWords, createMissingTimestamps);

  // Cache leeren wenn Filter sich √§ndern
  if (DEBUG.wordFilter) {
    console.log("[MDM WordFilter] saveExcludeWords called - clearing cache", {
      oldCacheSize: processedDealsCache.size,
      newFilterCount: excludeWords.length,
      sampleWords: excludeWords.slice(0, 5)
    });
  }
  processedDealsCache.clear();
  if (DEBUG.wordFilter) {
    console.log("[MDM WordFilter] Cache cleared, new size:", processedDealsCache.size);
  }

  GM_setValue("excludeWords", normalizedWords);

  // Deals sofort neu evaluieren damit √Ñnderungen sofort sichtbar werden
  const hiddenDeals = document.querySelectorAll('.mydealz-manager-hidden');
  hiddenDeals.forEach(deal => {
    deal.classList.remove('mydealz-manager-hidden');
    deal.setAttribute('data-hidden-by-mydealz-manager', 'false');
    deal.style.display = '';
  });

  // ProcessArticles filtert dann alles neu (inkl. Preis-Filter)
  if (typeof processArticles === 'function') {
    setTimeout(() => processArticles(), 50);
  }
}

// Laden von Wortfiltern
function loadExcludeWords() {
  const result = GM_getValue("excludeWords", []);

  if (DEBUG.wordFilter) {
    console.log("[MDM WordFilter] üìÇ GM_getValue('excludeWords'):", {
      type: typeof result,
      isArray: Array.isArray(result),
      length: result?.length,
      sample: result?.slice ? result.slice(0, 5) : result
    });
  }

  ensureWordTimestamps(result, false);
  return result;
}

// ===== Whitelist-Verwaltung =====
// Speichern von Whitelist-W√∂rtern
function saveWhitelistWords(words, createMissingTimestamps = false) {
  const normalizedWords = words.reduce((acc, word) => {
    const lowerWord = word.toLowerCase();
    const exists = acc.some((w) => w.toLowerCase() === lowerWord);
    if (!exists) {
      acc.push(word);
    }
    return acc;
  }, []);

  whitelistWords = normalizedWords;
  rebuildWhitelistCache(whitelistWords);

  ensureWhitelistTimestamps(whitelistWords, createMissingTimestamps);

  // Cache leeren wenn Filter sich √§ndern
  processedDealsCache.clear();

  GM_setValue("whitelistWords", normalizedWords);
}

// Laden von Whitelist-W√∂rtern
function loadWhitelistWords() {
  const result = GM_getValue("whitelistWords", []);
  ensureWhitelistTimestamps(result, false);
  return result;
}

// ===== Deal-Verwaltung =====
// Speichern ausgeblendeter Deals
function saveHiddenDeals() {
  GM_setValue("hiddenDeals", hiddenDeals);
}

// ===== H√§ndler-Verwaltung =====
// Speichern von H√§ndlerfiltern
function saveExcludeMerchants(merchantsData, createMissingTimestamps = false) {
  const validMerchants = merchantsData.filter(
    (m) =>
      m &&
      typeof m.id !== "undefined" &&
      m.id !== null &&
      typeof m.name !== "undefined" &&
      m.name !== null
  );
  const ids = validMerchants.map((m) => m.id);

  ensureMerchantTimestamps(validMerchants, createMissingTimestamps);

  GM_setValue("excludeMerchantIDs", ids);
  GM_setValue("excludeMerchantsData", validMerchants);

  // Cache leeren wenn H√§ndler-Filter sich √§ndern
  processedDealsCache.clear();

  excludeMerchantIDs = ids;
  rebuildExcludeMerchantCache(validMerchants);
}

// Laden von H√§ndlerfiltern
function loadExcludeMerchants() {
  const merchantsData = GM_getValue("excludeMerchantsData", []);
  const legacyIds = GM_getValue("excludeMerchantIDs", []);

  // Filter out invalid entries
  const validMerchants = merchantsData.filter(
    (m) =>
      m &&
      typeof m.id !== "undefined" &&
      m.id !== null &&
      typeof m.name !== "undefined" &&
      m.name !== null
  );

  ensureMerchantTimestamps(validMerchants, false);

  // Convert legacy IDs if needed
  if (validMerchants.length === 0 && legacyIds.length > 0) {
    const legacyMerchants = legacyIds
      .filter((id) => id && typeof id !== "undefined")
      .map((id) => ({ id, name: id }));
    ensureMerchantTimestamps(legacyMerchants);
    return legacyMerchants;
  }

  return validMerchants;
}

// ===== Preis-Verwaltung =====
// Speichern des Maximalpreises
function saveMaxPrice(price) {
  // Convert to number if it's a string
  if (typeof price === "string") {
    price = parseFloat(price.replace(",", ".")) || 0;
  }

  if (DEBUG.priceFilter) {
    console.log("[MDM PriceFilter] saveMaxPrice called:", {
      input: arguments[0],
      converted: price,
      type: typeof price
    });
  }

  GM_setValue("maxPrice", price);
  maxPrice = price;

  // Cache leeren wenn Preis-Filter sich √§ndert
  processedDealsCache.clear();

  if (DEBUG.priceFilter) {
    console.log("[MDM PriceFilter] saveMaxPrice SAVED:", {
      savedValue: price,
      gmValue: GM_getValue("maxPrice"),
      globalMaxPrice: maxPrice,
      cacheCleared: true
    });
  }

  // Deals sofort neu evaluieren
  const hiddenDeals = document.querySelectorAll('.mydealz-manager-hidden');
  hiddenDeals.forEach(deal => {
    deal.classList.remove('mydealz-manager-hidden');
    deal.setAttribute('data-hidden-by-mydealz-manager', 'false');
    deal.style.display = '';
  });

  // ProcessArticles filtert dann alles neu (inkl. Wort-Filter)
  if (typeof processArticles === 'function') {
    setTimeout(() => processArticles(), 50);
  }
}
//#endregion

//#region --- 4. UI-System ---
// ===== Basis UI-Funktionen =====

// Container, Styles, Theme
function initUIContainers() {
  settingsDiv = document.createElement("div");
  merchantListDiv = document.createElement("div");
  wordsListDiv = document.createElement("div");
  blockedUsersDiv = document.createElement("div");
}

function updateUITheme() {
  const colors = getThemeColors();

  [settingsDiv, merchantListDiv, wordsListDiv].forEach((div) => {
    if (div?.parentNode) {
      div.style.background = colors.background;
      div.style.border = `1px solid ${colors.border}`;
      div.style.color = colors.text;

      // Update all buttons and inputs
      div.querySelectorAll('button:not([id*="close"])').forEach((btn) => {
        btn.style.background = colors.buttonBg;
        btn.style.border = `1px solid ${colors.buttonBorder}`;
        btn.style.color = colors.text;
      });

      div.querySelectorAll("input").forEach((input) => {
        input.style.background = colors.inputBg;
        input.style.border = `1px solid ${colors.border}`;
        input.style.color = colors.text;
      });
    }
  });
}

// === UI-Komponenten ===
// --- Dialog-Erstellung ---
function createSettingsUI() {
  // UI erstellen
  if (isSettingsOpen) {
    return;
  }
  isSettingsOpen = true;

  // Lade versteckte Deals neu
  hiddenDeals = GM_getValue("hiddenDeals", []);

  // Initialize containers
  initUIContainers();

  const colors = getThemeColors();

  // Get merchant info from current deal
  let merchantName = null;
  let showMerchantButton = false;
  let userButtonHTML = "";

  settingsDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: ${IS_TOUCH_DEVICE ? "300px" : "350px"};
        height: auto;
        max-width: 90vw;
        max-height: 90vh;
        background: ${colors.background};
        border: 1px solid ${colors.border};
        border-radius: 5px;
        padding: 8px 15px;
        z-index: 1000;
        color: ${colors.text};
        display: flex;
        flex-direction: column;
    `;

  if (dealThatOpenedSettings) {
    // Merchant Info
    const merchantLink = dealThatOpenedSettings.querySelector(
      'a[data-t="merchantLink"]'
    );
    if (merchantLink) {
      merchantName = merchantLink.textContent.trim();
      showMerchantButton = true;
    }

    // User Info - Use data-md-author for original case
    const userName = dealThatOpenedSettings.getAttribute('data-md-author');

    if (userName) {
      userButtonHTML = `
                <button id="hideUserDealsButton" style="
                	display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 8px;
                    background: ${colors.buttonBg};
                    border: 1px solid ${colors.buttonBorder};
                    border-radius: 3px;
                    color: ${colors.text};
                    cursor: pointer;
                    width: 100%;
                ">
                    <i class="fas fa-user-slash"></i> <span style="font-weight: bold">${userName}</span>
                </button>
            `;
    }
  }

  // Header
  const header = document.createElement("div");
  header.className = "accordion-header"; // Klasse f√ºr Drag-Funktionalit√§t
  header.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        flex-shrink: 0;
        cursor: ${IS_TOUCH_DEVICE ? "default" : "move"};
        padding: 10px;
        user-select: none;
        background: ${colors.background};
        border-bottom: 1px solid ${colors.border};
    `;

  // Header-Inhalt mit Grip-Icon und Titel (nur auf Desktop)
  header.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px;">
            ${
              !IS_TOUCH_DEVICE
                ? `<span style="
                color: ${colors.text};
                opacity: 0.4;
                font-size: 14px;
                line-height: 1;
                cursor: move;
            " title="Zum Verschieben ziehen">‚ãÆ‚ãÆ</span>`
                : ""
            }
            <h3 style="margin: 0; font-size: 16px; font-weight: bold;">mydealz Manager</h3>
        </div>
    `;

  // Scrollbarer Content-Container
  const contentContainer = document.createElement("div");
  contentContainer.style.cssText = `
        flex-grow: 1;
        overflow-y: auto;
        margin-right: -5px;
        padding-right: 5px;
        margin-bottom: 5px;
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
    `;
  contentContainer.id = "mdm-settings-content"; // ID hinzuf√ºgen f√ºr einfacheres Debugging

  const updateNoticeShown = GM_getValue(UPDATE_NOTICE_SHOWN_KEY, true);
  const currentVersion = GM_info?.script?.version ?? "unbekannt";

  if (!updateNoticeShown) {
    // Hintergrundfarbe abh√§ngig vom Theme (nutze die vorhandene Theme-Erkennung)
    const themeColors = getThemeColors();
    const isDarkTheme = themeColors === THEME_COLORS.dark;
    const updateBgColor = isDarkTheme ? "#2d5a3a" : "#e9f6ec";

    const updateNotice = document.createElement("div");
    updateNotice.style.cssText = `
            margin: 0 0 8px 0;
            padding: 10px;
            background: ${updateBgColor};
            border: 1px solid #32cb5c;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            cursor: default;
        `;

    updateNotice.innerHTML = `
            <span style="flex-grow: 1; cursor: default;">
                mydealz Manager wurde auf Version ${currentVersion} aktualisiert
            </span>
            <div style="display: flex; align-items: center; gap: 10px;">
                <button id="mdmChangelogBtn" class="button button--type-primary button--mode-default" style="
                    padding: 4px 8px;
                    font-size: 12px;
                    background: #32cb5c;
                    border: 1px solid #32cb5c;
                    border-radius: 4px;
                    color: white;
                    cursor: pointer;
                ">Changelog</button>
                <button id="mdmCloseUpdateBtn" style="
                    background: none;
                    border: none;
                    cursor: pointer;
                    padding: 4px;
                    display: flex;
                    align-items: center;
                "><i class="fas fa-times"></i></button>
            </div>
        `;

    // F√ºge Notice zum Content-Container hinzu
    contentContainer.insertBefore(updateNotice, contentContainer.firstChild);

    // Event Handler f√ºr Buttons
    const changelogBtn = updateNotice.querySelector("#mdmChangelogBtn");
    const closeUpdateBtn = updateNotice.querySelector("#mdmCloseUpdateBtn");

    if (changelogBtn) {
      changelogBtn.addEventListener("click", (e) => {
        e.stopPropagation(); // Verhindere Event-Propagation
        window.open(CHANGELOG_URL, "_blank", "noopener");
        GM_setValue(UPDATE_NOTICE_SHOWN_KEY, true);
        updateNotice.remove();
      });
    }

    if (closeUpdateBtn) {
      closeUpdateBtn.addEventListener("click", (e) => {
        e.stopPropagation(); // Verhindere Event-Propagation
        GM_setValue(UPDATE_NOTICE_SHOWN_KEY, true);
        updateNotice.remove();
      });
    }
  }

  // Accordion-Sektionen definieren und hinzuf√ºgen
  const sections = {
    quickActions: createAccordionSection("Schnellaktionen", "bolt"),
    filter: createAccordionSection("Filter", "filter"),
    features: createAccordionSection("Funktionen", "toggle-on"),
    backup: createAccordionSection("Backup", "save"),
  };

  // Quick Actions Section (standardm√§√üig offen)
  sections.quickActions.content.innerHTML = `
    <div class="section-content" style="display: flex; flex-direction: column; gap: 6px;">
        <!-- Word Input - mit nativer mydealz Suchfeld-Optik -->
        <div style="margin-bottom: 6px;">
            <div style="display: flex; align-items: center; gap: 4px;">
                <div class="search-box" style="
                    flex: 1;
                    position: relative;
                    display: flex;
                    align-items: center;
                    background: ${colors.inputBg};
                    border: 1px solid ${colors.border};
                    border-radius: 8px;
                    padding: 0 8px;
                    height: 36px;
                    transition: all 0.2s ease;
                    overflow: hidden;
                ">
                    <input id="newWordInput"
                        autocomplete="off"
                        ${IS_TOUCH_DEVICE ? "readonly" : ""}
                        placeholder="Neues Wort..."
                        title="Wortfilter - Deals mit bestimmten Begriffen ausblenden\n\nüìå BEISPIELE:\n\nWildcard (*):\n  Kaffee*     ‚Üí Kaffeemaschine, Kaffeetasse\n  *maschine   ‚Üí Kaffeemaschine, Waschmaschine\n\nUND (+):\n  apple+watch     ‚Üí Apple Watch\n  iphone+15+pro   ‚Üí alle 3 W√∂rter m√ºssen vorkommen\n\nNegation ODER ( -):\n  iphone -h√ºlle   ‚Üí iPhone JA, aber NICHT mit H√ºlle\n  wein -glas      ‚Üí Wein JA, aber NICHT Weinglas\n  Fritz!Fon -bundle -router   ‚Üí Fritz!Fon JA, OHNE bundle ODER router\nüí°Leerzeichen vor dem Minus (-) ist wichtig!\n\nNegation UND (+-): \n  Fritz!Fon -bundle+-router   ‚Üí Fritz!Fon JA, AUSSER wenn bundle UND router BEIDE vorkommen\n\nKOMBINATIONEN:\n  Fl√ºge+Stuttgart -Berlin   ‚Üí Fl√ºge UND Stuttgart, OHNE Berlin\n  apple+*watch* -ultra      ‚Üí Apple UND watch*, OHNE ultra\n  *kaffee*+vollautomat      ‚Üí *kaffee* UND Vollautomat"
                        style="
                            flex: 1;
                            border: none;
                            background: transparent;
                            color: ${colors.text};
                            font-size: 14px;
                            outline: none;
                        ">
                    ${IS_TOUCH_DEVICE ? `<button id="filterInfoButton" style="
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 32px;
                        height: 32px;
                        margin-left: 8px;
                        padding: 0;
                        background: ${colors.linkColor};
                        border: none;
                        border-radius: 50%;
                        color: ${colors.bg};
                        cursor: pointer;
                        font-size: 16px;
                        font-weight: bold;
                        flex-shrink: 0;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    " title="Hilfe anzeigen">‚ìò</button>` : ''}
                </div>
                ${
                  IS_TOUCH_DEVICE
                    ? `
                    <button id="enableKeyboardButton" style="
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 8px;
                        background: ${colors.buttonBg};
                        border: 1px solid ${colors.buttonBorder};
                        border-radius: 3px;
                        color: ${colors.text};
                        cursor: pointer;
                    ">
                        <i class="fas fa-keyboard"></i>
                    </button>
                `
                    : ""
                }
                <button id="addWordButton" style="...">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
        </div>

            ${
              showMerchantButton
                ? `
                <div style="display: flex; align-items: center;">
                    <button id="hideMerchantButton" style="
                        width: 100%;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        padding: 0;
                        background: none;
                        border: none;
                        color: ${colors.text};
                        cursor: pointer;
                    " title="Blendet alle aktuellen und zuk√ºnftigen Deals dieses H√§ndlers aus">
                        <i class="fas fa-store-slash"></i>
                        <span>${merchantName}</span>
                    </button>
                </div>
            `
                : ""
            }

            <!-- Button zum Ausblenden von User-Deals -->
            ${
              dealThatOpenedSettings
                ? (() => {
                    const userSpan = dealThatOpenedSettings.querySelector(
                      ".color--text-TranslucentSecondary.overflow--wrap-off span.overflow--ellipsis"
                    );
                    const userName = userSpan?.textContent.match(
                      /Ver√∂ffentlicht von\s+(\S+)/
                    )?.[1];

                    return userName
                      ? `
                    <div style="display: flex; align-items: center;">
                        <button id="hideUserDealsButton" style="
                            width: 100%;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                            padding: 0;
                            background: none;
                            border: none;
                            color: ${colors.text};
                            cursor: pointer;
                        " title="Blendet alle aktuellen und zuk√ºnftigen Deals dieses Benutzers aus">
                            <i class="fas fa-user-slash"></i>
                            <span>${userName}</span>
                        </button>
                    </div>
                `
                      : "";
                  })()
                : ""
            }

        </div>
    `;

  // Filter Section
  sections.filter.content.innerHTML = `
        <div class="section-content" style="display: flex; flex-direction: column; gap: 6px;">
            <button id="showWordsListButton" class="menu-button">
                <i class="fas fa-list"></i> Wortfilter verwalten
            </button>

            <!-- Separator -->
            <div style="height: 1px; background: ${
              colors.border
            }; opacity: 0.3; margin: 4px 0;"></div>

            <button id="showWhitelistButton" class="menu-button">
                <i class="fas fa-shield-alt"></i> Whitelist verwalten
            </button>

            <!-- Separator -->
            <div style="height: 1px; background: ${
              colors.border
            }; opacity: 0.3; margin: 4px 0;"></div>

            <button id="showMerchantListButton" class="menu-button">
                <i class="fas fa-store"></i> H√§ndlerfilter verwalten
            </button>

            <!-- Separator -->
            <div style="height: 1px; background: ${
              colors.border
            }; opacity: 0.3; margin: 4px 0;"></div>

            <!-- Button f√ºr Benutzerfilter -->
            <button id="showBlockedUsersButton" class="menu-button">
                <i class="fas fa-user-slash"></i> Benutzerfilter verwalten
            </button>

            <!-- Separator -->
            <div style="height: 1px; background: ${
              colors.border
            }; opacity: 0.3; margin: 4px 0;"></div>

            <div class="toggle-option" style="display: flex; justify-content: space-between; align-items: center;">
                <span style="display: flex; align-items: center; gap: 4px; ${!IS_TOUCH_DEVICE ? 'cursor: help;' : ''}" title="${!IS_TOUCH_DEVICE ? 'Deals unter 0¬∞ werden ausgeblendet' : ''}">
                    Kalte Deals
                    ${IS_TOUCH_DEVICE ? '<button class="feature-info-btn" data-info="Deals unter 0¬∞ werden ausgeblendet" style="background: none; border: none; color: ' + colors.linkColor + '; cursor: pointer; padding: 0; font-size: 12px; width: 16px; height: 16px;">‚ìò</button>' : ''}
                </span>
                <button type="button" id="hideColdDeals" class="eye-toggle" style="...">
                    <i class="fas ${
                      hideColdDeals ? "fa-eye-slash" : "fa-eye"
                    }"></i>
                </button>
            </div>

            <!-- Separator -->
            <div style="height: 1px; background: ${
              colors.border
            }; opacity: 0.3; margin: 4px 0;"></div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="flex-grow: 1; display: flex; align-items: center; gap: 4px; ${!IS_TOUCH_DEVICE ? 'cursor: help;' : ''}" title="${!IS_TOUCH_DEVICE ? 'Deals √ºber diesem Preis werden ausgeblendet' : ''}">
                    Teure Deals
                    ${IS_TOUCH_DEVICE ? '<button class="feature-info-btn" data-info="Deals √ºber diesem Preis werden ausgeblendet" style="background: none; border: none; color: ' + colors.linkColor + '; cursor: pointer; padding: 0; font-size: 12px; width: 16px; height: 16px;">‚ìò</button>' : ''}
                </label>
                <input
                    type="text"
                    inputmode="decimal"
                    pattern="[0-9]*[.,]?[0-9]*"
                    id="settingsMaxPrice"
                    value="${maxPrice.toLocaleString("de-DE", {
                      minimumFractionDigits: 0,
                      maximumFractionDigits: 2,
                    })}"
                    placeholder="‚Ç¨"
                    style="
                        width: 80px;
                        padding: 4px 8px;
                        text-align: right;
                        background: ${colors.inputBg};
                        border: 1px solid ${colors.border};
                        border-radius: 3px;
                        color: ${colors.text};
                    "
                >
            </div>
        </div>
    `;

  // Features Section
  sections.features.content.innerHTML = `
        <div class="section-content" style="display: flex; flex-direction: column; gap: 6px;">

            <div class="toggle-option" style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                position: relative;
            ">

            </div>

            <div class="toggle-option" style="display: flex; justify-content: space-between; align-items: center;">
                <span style="display: flex; align-items: center; gap: 4px; ${!IS_TOUCH_DEVICE ? 'cursor: help;' : ''}" title="${!IS_TOUCH_DEVICE ? 'Gibt es zu dem Deal einen hinterlegten H√§ndler und befindet sich der Name des H√§ndlers im Titel, so wird dieser Name aus dem Titel ausgeblendet.' : ''}">
                    H√§ndler im Titel
                    ${IS_TOUCH_DEVICE ? '<button class="feature-info-btn" data-info="Gibt es zu dem Deal einen hinterlegten H√§ndler und befindet sich der Name des H√§ndlers im Titel, so wird dieser Name aus dem Titel ausgeblendet." style="background: none; border: none; color: ' + colors.linkColor + '; cursor: pointer; padding: 0; font-size: 12px; width: 16px; height: 16px;">‚ìò</button>' : ''}
                </span>
                <button type="button" id="hideMatchingMerchantNames" class="eye-toggle" style="
                    background: none;
                    border: none;
                    cursor: pointer;
                    font-size: 18px;
                    color: ${colors.text};
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                ">
                    <i class="fas ${
                      window.hideMatchingMerchantNames
                        ? "fa-eye-slash"
                        : "fa-eye"
                    }"
                    aria-label="${
                      window.hideMatchingMerchantNames
                        ? "H√§ndlernamen versteckt"
                        : "H√§ndlernamen sichtbar"
                    }"></i>
                </button>
            </div>

            <!-- Separator -->
            <div style="height: 1px; background: ${
              colors.border
            }; opacity: 0.3; margin: 6px 0;"></div>

            <!-- Toggle-Option f√ºr Speicherun der Sucheinstellungen -->
            <div class="toggle-option" style="display: flex; justify-content: space-between; align-items: center;">
                <span style="display: flex; align-items: center; gap: 4px; ${!IS_TOUCH_DEVICE ? 'cursor: help;' : ''}" title="${!IS_TOUCH_DEVICE ? 'Mit dieser Funktion werden die Werte f√ºr \'Sortieren\' und \'Datumsbereich\' gespeichert und bei zuk√ºnftigen Suchen sofort angewandt.' : ''}">
                    Sucheinstellungen speichern
                    ${IS_TOUCH_DEVICE ? '<button class="feature-info-btn" data-info="Mit dieser Funktion werden die Werte f√ºr \'Sortieren\' und \'Datumsbereich\' gespeichert und bei zuk√ºnftigen Suchen sofort angewandt." style="background: none; border: none; color: ' + colors.linkColor + '; cursor: pointer; padding: 0; font-size: 12px; width: 16px; height: 16px;">‚ìò</button>' : ''}
                </span>
                <button type="button" id="rememberSort" class="toggle-switch" style="
                    background: none;
                    border: none;
                    cursor: pointer;
                    font-size: 18px;
                    color: ${colors.text};
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                ">
                    <i class="fas ${
                      window.rememberSort ? "fa-toggle-on" : "fa-toggle-off"
                    }"
                    aria-label="${
                      window.rememberSort
                        ? "Sortierung wird gespeichert"
                        : "Sortierung wird nicht gespeichert"
                    }"></i>
                </button>
            </div>
        </div>
    `;

  // Backup Section
  sections.backup.content.innerHTML = `
        <div class="section-content" style="display: flex; flex-direction: column; gap: 6px;">
            <button id="backupDataButton" class="menu-button">
                <i class="fas fa-download"></i> Backup erstellen
            </button>

            <!-- Separator -->
            <div style="height: 1px; background: ${colors.border}; opacity: 0.3; margin: 4px 0;"></div>

            <button id="restoreDataButton" class="menu-button">
                <i class="fas fa-upload"></i> Backup wiederherstellen
            </button>
            <input type="file"
                id="restoreFileInput"
                accept=".json"
                style="display: none;">
        </div>
    `;

  // Add sections to container
  Object.values(sections).forEach(({ section }) => {
    contentContainer.appendChild(section);
  });

  // Erste Sektion automatisch √∂ffnen und andere schlie√üen
  Object.values(sections).forEach(({ section }, index) => {
    const header = section.querySelector(".accordion-header");
    const content = section.querySelector(".accordion-content");
    const icon = header.querySelector(".fa-chevron-down");

    if (index === 0) {
      // Schnellaktionen
      content.style.display = "block";
      icon.style.transform = "rotate(180deg)";
    } else {
      content.style.display = "none";
      icon.style.transform = "";
    }
  });

  // Footer mit fixem Schlie√üen-Button - weniger Abstand zum Content
  const footer = document.createElement("div");
  footer.style.cssText = `
        margin-top: 0px;
        flex-shrink: 0;
        display: flex;
        justify-content: center;
        padding-top: 8px;
    `;

  footer.innerHTML = `
        <button id="closeSettingsButton" class="button button--type-secondary button--mode-default button--shape-circle">
            <span>Schlie√üen</span>
        </button>
    `;

  // Zusammenbau der UI
  settingsDiv.appendChild(header);
  settingsDiv.appendChild(contentContainer);
  settingsDiv.appendChild(footer);
  document.body.appendChild(settingsDiv);

  // Sammle alle Cleanup-Funktionen
  const cleanupFunctions = [];

  // F√ºge Draggable Cleanup hinzu
  const cleanupDraggable = makeDraggable(settingsDiv);
  if (cleanupDraggable) cleanupFunctions.push(cleanupDraggable);

  // Erweitere die Hauptcleanup-Funktion einmalig
  const oldCleanup = cleanup;
  cleanup = () => {
    // F√ºhre alle registrierten Cleanup-Funktionen aus
    cleanupFunctions.forEach((fn) => fn());
    // F√ºhre original Cleanup aus
    oldCleanup();
  };

  // Nach dem Hinzuf√ºgen zum DOM den Button anpassen
  document.getElementById("closeSettingsButton").style.cssText = `
        padding: 8px 16px;
        display: inline-block;
        width: auto;
        min-width: 100px;
        text-align: center;
    `;

  // Event-Listener f√ºr den Sortierung Button:
  document
    .getElementById("rememberSort")
    ?.addEventListener("click", async (e) => {
      // Toggle state
      const newState = !window.rememberSort;
      window.rememberSort = newState;
      GM_setValue("rememberSort", newState);

      // Wenn Feature deaktiviert wurde, gespeicherte Sortierung entfernen
      if (!newState && localStorage.getItem(PREFERRED_SORT_KEY)) {
        localStorage.removeItem(PREFERRED_SORT_KEY);
      }

      // Update icon
      const icon = e.currentTarget.querySelector("i");
      if (icon) {
        icon.className = `fas ${newState ? "fa-toggle-on" : "fa-toggle-off"}`;
        icon.setAttribute(
          "aria-label",
          newState
            ? "Sortierung wird gespeichert"
            : "Sortierung wird nicht gespeichert"
        );
      }
    });

  // Accordion section styling - reduce padding and margins
  const accordionSectionStyle = document.createElement("style");
  accordionSectionStyle.textContent = `
        .accordion-section {
            margin-bottom: 4px;
        }
        .accordion-header {
            font-size: 18px;
            font-weight: bold;
            padding: 6px 8px !important;
            color: var(--primary-color, #24a300) !important;
        }
        .accordion-content {
            padding: 6px 8px !important;
        }
    `;
  document.head.appendChild(accordionSectionStyle);

  // Backup/Restore Buttons korrekt referenzieren
  const backupButton = document.getElementById("backupDataButton");
  const restoreButton = document.getElementById("restoreDataButton");
  const restoreFileInput = document.getElementById("restoreFileInput");

  // Event Listener f√ºr den versteckten Datei-Input
  if (restoreFileInput) {
    restoreFileInput.addEventListener("change", (e) => {
      restoreData(e);
    });
  }

  if (backupButton) {
    backupButton.addEventListener("click", () => {
      console.log("[MDM] Backup button clicked");
      backupData();
    });
  }

  if (restoreButton) {
    restoreButton.addEventListener("click", () => {
      if (restoreFileInput) {
        restoreFileInput.click();
      } else {
      }
    });
  }

  // Add Word Button
  const addWordButton = document.getElementById("addWordButton");
  if (addWordButton) {
    addWordButton.addEventListener("click", () => {
      const newWordInput = document.getElementById("newWordInput");
      const newWord = newWordInput.value.trim();

      // Lade aktuelle W√∂rter neu um sicherzustellen dass wir die komplette Liste haben
      excludeWords = loadExcludeWords();

      // Pr√ºfe ob das Wort (unabh√§ngig von Gro√ü-/Kleinschreibung) bereits existiert
      const wordExists = excludeWords.some(
        (word) => word.toLowerCase() === newWord.toLowerCase()
      );

      if (newWord && !wordExists) {
        excludeWords.unshift(newWord); // F√ºge neues Wort zur bestehenden Liste hinzu

        const normalizedNew = normalizeForSearch(newWord);
        wordAddedAt[normalizedNew] = {
          timestamp: formatTimestamp(),
          isLegacy: false,
        };
        GM_setValue("wordAddedAt", wordAddedAt);

        saveExcludeWords(excludeWords);
        newWordInput.value = "";
        processArticles();
        cleanup();

        suggestedWords = [];
        const suggestionList = document.getElementById("wordSuggestionList");
        if (suggestionList) {
          suggestionList.remove();
        }
      } else if (wordExists) {
        // Erstelle und zeige Fehlermeldung
        const errorMsg = document.createElement("div");
        errorMsg.style.cssText = `
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    padding: 8px;
                    margin-top: 4px;
                    background: #ffebee;
                    color: #c62828;
                    border: 1px solid #ef9a9a;
                    border-radius: 3px;
                    font-size: 12px;
                    z-index: 1003;
                `;
        errorMsg.textContent = `"${newWord}" ist bereits in der Liste vorhanden.`;

        // F√ºge Fehlermeldung zum Input-Container hinzu
        const inputContainer = newWordInput.parentElement;
        inputContainer.style.position = "relative";
        inputContainer.appendChild(errorMsg);

        // Entferne Fehlermeldung nach 3 Sekunden
        setTimeout(() => {
          errorMsg.remove();
        }, 3000);

        // Selektiere den Text im Input f√ºr einfaches √úberschreiben
        newWordInput.select();
      }
    });
  }

  // Enable Keyboard Button (f√ºr Touch-Ger√§te)
  const enableKeyboardButton = document.getElementById("enableKeyboardButton");
  if (enableKeyboardButton) {
    enableKeyboardButton.addEventListener("click", () => {
      const newWordInput = document.getElementById("newWordInput");
      if (newWordInput) {
        newWordInput.readOnly = false;
        newWordInput.focus();
      }
    });
  }

  // Hide Merchant Button
  const hideMerchantButton = document.getElementById("hideMerchantButton");
  if (hideMerchantButton && showMerchantButton) {
    hideMerchantButton.addEventListener("click", () => {
      if (!dealThatOpenedSettings) return;

      const merchantLink = dealThatOpenedSettings.querySelector(
        'a[href*="merchant-id="]'
      );
      if (!merchantLink) return;

      const merchantIDMatch = merchantLink
        .getAttribute("href")
        .match(/merchant-id=(\d+)/);
      if (!merchantIDMatch) return;

      const merchantID = merchantIDMatch[1];
      const merchantName = dealThatOpenedSettings
        .querySelector('a[data-t="merchantLink"]')
        .textContent.trim();

      const merchantsData = loadExcludeMerchants();
      if (!merchantsData.some((m) => m.id === merchantID)) {
        merchantsData.unshift({ id: merchantID, name: merchantName });
        const key = String(merchantID);
        merchantAddedAt[key] = {
          timestamp: formatTimestamp(),
          isLegacy: false,
        };
        GM_setValue("merchantAddedAt", merchantAddedAt);

        saveExcludeMerchants(merchantsData);
        processArticles();
        cleanup(); // Close settings UI

        // Aktualisiere Listen wenn UI offen
        if (activeSubUI === "merchant") {
          updateActiveLists();
        }
      }
    });
  }

  // Event Listener f√ºr den Button zum Ausblenden von User-Deals
  const hideUserDealsButton = document.getElementById("hideUserDealsButton");
  console.log(
    "[MDM] hideUserDealsButton found:",
    !!hideUserDealsButton,
    "dealThatOpenedSettings:",
    dealThatOpenedSettings?.id
  );
  if (hideUserDealsButton) {
    hideUserDealsButton.addEventListener("click", () => {
      console.log("[MDM] hideUserDealsButton clicked");
      console.log("[MDM] dealThatOpenedSettings:", dealThatOpenedSettings);
      console.log("[MDM] dealThatOpenedSettings truthy:", !!dealThatOpenedSettings);
      console.log("[MDM] typeof handleUserBlock:", typeof handleUserBlock);

      try {
        if (dealThatOpenedSettings) {
          console.log("[MDM] Calling handleUserBlock with:", dealThatOpenedSettings.id);
          handleUserBlock(dealThatOpenedSettings);
          console.log("[MDM] handleUserBlock returned, calling cleanup");
          cleanup();
        } else {
          console.log("[MDM] No dealThatOpenedSettings available");
        }
      } catch (error) {
        console.error("[MDM] ERROR in hideUserDealsButton click handler:", error);
        console.error("[MDM] Error stack:", error.stack);
      }
    });
  }

  // Show Words List Button
  const showWordsListButton = document.getElementById("showWordsListButton");
  if (showWordsListButton) {
    showWordsListButton.addEventListener("click", () => {
      if (switchSubUI("words")) {
        createExcludeWordsUI();
      }
    });
  }

  // Show Whitelist Button
  const showWhitelistButton = document.getElementById("showWhitelistButton");
  if (showWhitelistButton) {
    showWhitelistButton.addEventListener("click", () => {
      if (switchSubUI("whitelist")) {
        createWhitelistUI();
      }
    });
  }

  // Show Merchant List Button
  const showMerchantListButton = document.getElementById(
    "showMerchantListButton"
  );
  if (showMerchantListButton) {
    showMerchantListButton.addEventListener("click", () => {
      if (switchSubUI("merchant")) {
        createMerchantListUI();
      }
    });
  }

  // Button f√ºr Blockierte Benutzer:
  const showBlockedUsersButton = document.getElementById(
    "showBlockedUsersButton"
  );
  if (showBlockedUsersButton) {
    showBlockedUsersButton.addEventListener("click", () => {
      if (switchSubUI("users")) {
        createBlockedUsersUI();
      }
    });
  }

  // Add event listeners only if newWordInput exists
  const newWordInput = document.getElementById("newWordInput");
  if (newWordInput) {
    // Enter Key Handler f√ºr das Eingabefeld
    newWordInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        const word = newWordInput.value.trim();
        if (word && word.length > 0) {
          // Add to excludeWords if not already in the list
          if (!excludeWords.includes(word)) {
            excludeWords.unshift(word);
            const normalizedNew = normalizeForSearch(word);
            wordAddedAt[normalizedNew] = {
              timestamp: formatTimestamp(),
              isLegacy: false,
            };
            GM_setValue("wordAddedAt", wordAddedAt);

            saveExcludeWords(excludeWords);
            processArticles();
          }

          // Clear the input field
          newWordInput.value = "";
          // Close suggestion list
          document.getElementById("wordSuggestionList")?.remove();
        }
      }
    });

    // Unified focus handler
    newWordInput.addEventListener(
      "focus",
      () => {
        // Get fresh words from current deal if none exist
        if (suggestedWords.length === 0) {
          suggestedWords = getWordsFromTitle(dealThatOpenedSettings);
        }

        // Always show suggestion list if words exist
        if (suggestedWords.length > 0) {
          updateSuggestionList();
        }
      },
      { once: false }
    ); // Allow multiple focus events
  }

  // Filter Info Button (Mobile)
  const filterInfoButton = document.getElementById("filterInfoButton");
  if (filterInfoButton) {
    filterInfoButton.addEventListener("click", (e) => {
      e.stopPropagation();

      // Erstelle Hilfe-Overlay
      const helpOverlay = document.createElement("div");
      helpOverlay.id = "filterHelpOverlay";
      helpOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;

      const helpBox = document.createElement("div");
      helpBox.style.cssText = `
        background: ${colors.contentBg};
        color: ${colors.text};
        border-radius: 12px;
        padding: 20px;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      `;

      helpBox.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <h3 style="margin: 0; font-size: 18px; color: ${colors.text};">üìö Wortfilter Hilfe</h3>
          <button id="closeHelpButton" style="
            background: ${colors.buttonBg};
            border: 1px solid ${colors.buttonBorder};
            color: ${colors.text};
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
          ">‚úï</button>
        </div>

        <div style="font-size: 14px; line-height: 1.6;">
          <h4 style="margin: 12px 0 8px; color: ${colors.linkColor};">Wildcard (*)</h4>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">Kaffee*</code> ‚Üí Kaffeemaschine, Kaffeetasse<br>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">*maschine</code> ‚Üí Kaffeemaschine, Waschmaschine

          <h4 style="margin: 12px 0 8px; color: ${colors.linkColor};">UND-Filter (+)</h4>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">apple+watch</code> ‚Üí Apple Watch<br>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">iphone+15+pro</code> ‚Üí alle 3 W√∂rter

          <h4 style="margin: 12px 0 8px; color: ${colors.linkColor};">Negation ODER ( -)</h4>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">iphone -h√ºlle</code> ‚Üí iPhone ohne H√ºlle<br>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">Fritz!Fon -bundle -router</code> ‚Üí Fritz!Fon ohne bundle ODER router

          <h4 style="margin: 12px 0 8px; color: ${colors.linkColor};">Negation UND (+-)</h4>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">Fritz!Fon -bundle+-router</code><br>
          ‚Üí Fritz!Fon JA, AUSSER wenn bundle UND router BEIDE vorkommen

          <h4 style="margin: 12px 0 8px; color: ${colors.linkColor};">Kombinationen</h4>
          <code style="background: ${colors.inputBg}; padding: 2px 6px; border-radius: 3px;">Fl√ºge+Stuttgart -Berlin</code><br>
          ‚Üí Fl√ºge UND Stuttgart, OHNE Berlin

          <p style="margin-top: 12px; padding: 12px; background: ${colors.inputBg}; border-radius: 6px; font-size: 13px;">
            üí° <strong>Tipp:</strong> Leerzeichen vor dem Minus (-) ist wichtig!<br>
            ‚úì <code>wein -glas</code> funktioniert<br>
            ‚úó <code>wein-glas</code> sucht nach "wein-glas" als Ganzes
          </p>
        </div>
      `;

      helpOverlay.appendChild(helpBox);
      document.body.appendChild(helpOverlay);

      // Schlie√üen-Handler
      const closeHelp = () => {
        helpOverlay.remove();
      };

      document.getElementById("closeHelpButton").addEventListener("click", closeHelp);
      helpOverlay.addEventListener("click", (e) => {
        if (e.target === helpOverlay) closeHelp();
      });
    });
  }

  // Feature Info Buttons (Mobile) - f√ºr Kalte Deals, Teure Deals, H√§ndler im Titel, Sucheinstellungen
  const featureInfoButtons = document.querySelectorAll(".feature-info-btn");
  featureInfoButtons.forEach((button) => {
    button.addEventListener("click", (e) => {
      e.stopPropagation();

      const infoText = button.getAttribute("data-info");

      // Erstelle Info-Overlay
      const infoOverlay = document.createElement("div");
      infoOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      `;

      const infoBox = document.createElement("div");
      infoBox.style.cssText = `
        background: ${colors.contentBg};
        color: ${colors.text};
        border-radius: 12px;
        padding: 20px;
        max-width: 400px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      `;

      infoBox.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
          <h3 style="margin: 0; font-size: 18px; color: ${colors.text};">‚ÑπÔ∏è Information</h3>
          <button id="closeInfoButton" style="
            background: ${colors.buttonBg};
            border: 1px solid ${colors.buttonBorder};
            color: ${colors.text};
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
          ">‚úï</button>
        </div>

        <div style="font-size: 14px; line-height: 1.6;">
          ${infoText}
        </div>
      `;

      infoOverlay.appendChild(infoBox);
      document.body.appendChild(infoOverlay);

      // Schlie√üen-Handler
      const closeInfo = () => {
        infoOverlay.remove();
      };

      document.getElementById("closeInfoButton").addEventListener("click", closeInfo);
      infoOverlay.addEventListener("click", (e) => {
        if (e.target === infoOverlay) closeInfo();
      });
    });
  });

  // Click Outside Handler anpassen
  createSuggestionClickHandler();

  // Cleanup bei UI-Schlie√üung
  document
    .getElementById("closeSettingsButton")
    .addEventListener("click", () => {
      document.removeEventListener("click", suggestionClickHandler);
      cleanup();
    });

  // Add cleanup to window unload
  window.addEventListener("unload", cleanup);

  const maxPriceInput = document.getElementById("settingsMaxPrice"); // Korrekter ID
  if (maxPriceInput) {
    // Focus-Handler hinzuf√ºgen, der den Inhalt markiert
    maxPriceInput.addEventListener("focus", () => {
      maxPriceInput.select();
    });

    // Formatierer f√ºr die Eingabe
    const formatPrice = (value) => {
      let cleaned = value.replace(/[^\d.,]/g, "");
      const parts = cleaned.split(",");

      // Begrenze Nachkommastellen auf 2
      if (parts.length > 1) {
        parts[1] = parts[1].slice(0, 2); // Maximal 2 Stellen nach dem Komma
        cleaned = parts[0] + "," + parts[1];
      }

      if (parts.length > 2) {
        cleaned =
          parts.slice(0, -1).join("") + "," + parts.slice(-1)[0].slice(0, 2);
      }

      if (parts.length === 2) {
        const intPart = parts[0].replace(/\./g, "");
        return Number(intPart).toLocaleString("de-DE") + "," + parts[1];
      } else {
        const intPart = cleaned.replace(/\./g, "");
        return Number(intPart).toLocaleString("de-DE");
      }
    };

    // Input-Handler hinzuf√ºgen f√ºr die Live-Formatierung
    maxPriceInput.addEventListener("input", (e) => {
      e.stopPropagation();
      e.target.value = formatPrice(e.target.value);
    });

    // Beim Verlassen des Feldes den Wert speichern
    maxPriceInput.addEventListener("blur", (e) => {
      const value = e.target.value;
      const numStr = value.replace(/\./g, "").replace(",", ".");
      const numericValue = parseFloat(numStr);

      if (!isNaN(numericValue) && numericValue >= 0) {
        const oldValue = maxPrice;
        saveMaxPrice(numericValue);

        // Auch filtern wenn Wert gleich blieb (z.B. bei Enter ohne √Ñnderung)
        if (oldValue === numericValue) {
          processArticles();
        }
      }
    });

    // Enter-Taste zum √úbernehmen
    maxPriceInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        maxPriceInput.blur(); // Triggert blur-Event, das den Wert speichert
      }
    });

    // Behandlung f√ºr Touch-Ger√§te
    if (IS_TOUCH_DEVICE) {
      maxPriceInput.addEventListener("focus", () => {
        // √ñffnet die numerische Tastatur auf Touch-Ger√§ten
        maxPriceInput.setAttribute("inputmode", "decimal");

        // Markiert den Text f√ºr einfaches √úberschreiben
        maxPriceInput.select();
      });
    }
  }

  // Get initial word suggestions
  suggestedWords = dealThatOpenedSettings
    ? getWordsFromTitle(dealThatOpenedSettings)
    : [];

  // Event-Listener f√ºr die "Zur√ºck"-Buttons bei k√ºrzlich ausgeblendeten Deals
  document
    .querySelector(".restore-deal-button")
    ?.addEventListener("click", (e) => {
      const dealId = e.currentTarget.dataset.dealId;

      // Deal aus hiddenDeals entfernen
      hiddenDeals = hiddenDeals.filter((id) => id !== dealId);
      saveHiddenDeals();

      // UI aktualisieren
      document.getElementById("lastHiddenDealSection").style.display = "none";

      // Finde den wiederhergestellten Deal
      const restoredDeal = document.getElementById(dealId);
      if (restoredDeal) {
        // Hide-Button Container zur√ºcksetzen
        const hideButtonContainer = restoredDeal.querySelector(
          ".cept-vote-temp div"
        );
        if (hideButtonContainer) {
          hideButtonContainer.style.display = "none";
        }
      }

      // Deals neu verarbeiten
      processArticles();
    });

  // Setup ClickOutsideHandler f√ºr das Settings-UI
  setupClickOutsideHandler();

  document
    .getElementById("hideMatchingMerchantNames")
    ?.addEventListener("click", async (e) => {
      // Toggle state
      const newState = !window.hideMatchingMerchantNames;
      window.hideMatchingMerchantNames = newState;
      GM_setValue("hideMatchingMerchantNames", newState);

      // Cache leeren da sich die Titel √§ndern werden
      processedDealsCache.clear();

      // Bei DEAKTIVIERUNG: Sofort alle Originaltitel wiederherstellen
      if (!newState && ORIGINAL_TITLES.size > 0) {
        ORIGINAL_TITLES.forEach((originalTitle, dealId) => {
          const deal = document.getElementById(dealId);
          if (deal) {
            const titleLink = deal.querySelector(".thread-title a");
            if (titleLink) {
              titleLink.textContent = originalTitle;
              titleLink.setAttribute("title", originalTitle);
            }
          }
        });
        if (DEBUG.hideMatchingMerchantNames) {
          console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Restored ${ORIGINAL_TITLES.size} original titles immediately`);
        }
      }

      // ORIGINAL_TITLES IMMER leeren (bei Aktivierung UND Deaktivierung)
      // Damit werden Deals beim n√§chsten processArticles() neu verarbeitet
      ORIGINAL_TITLES.clear();

      if (DEBUG.hideMatchingMerchantNames) {
        console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Feature toggled, ORIGINAL_TITLES cleared:`, {
          newState,
          reason: "Force re-processing of all deals with new setting"
        });
      }

      // Update icon
      const icon = e.currentTarget.querySelector("i");
      if (icon) {
        icon.className = `fas ${newState ? "fa-eye-slash" : "fa-eye"}`;
        icon.setAttribute(
          "aria-label",
          newState ? "H√§ndlernamen versteckt" : "H√§ndlernamen sichtbar"
        );
      }

      // Update visibility
      await Promise.resolve();
      processArticles();
    });

  document
    .getElementById("hideColdDeals")
    ?.addEventListener("click", async (e) => {
      // Toggle state
      hideColdDeals = !hideColdDeals;

      // Save to storage
      GM_setValue("hideColdDeals", hideColdDeals);

      // Update icon
      const icon = e.currentTarget.querySelector("i");
      if (icon) {
        icon.className = `fas ${hideColdDeals ? "fa-eye-slash" : "fa-eye"}`;
        icon.setAttribute(
          "aria-label",
          hideColdDeals ? "Kalte Deals versteckt" : "Kalte Deals sichtbar"
        );
      }

      // Reprocess articles to apply the change
      await Promise.resolve();
      processArticles();
    });
}

function makeDraggable(element) {
  // Don't make draggable on touch devices
  if (IS_TOUCH_DEVICE) return;

  let isDragging = false;
  let offsetX = 0,
    offsetY = 0;
  let wasMoved = false;

  // Header f√ºr Drag-Funktionalit√§t
  const header = element.querySelector(".accordion-header:first-child");
  if (!header) return;

  header.style.cursor = "move";
  header.style.userSelect = "none";

  const startDrag = (e) => {
    // Nur bei linker Maustaste
    if (e.button !== 0) return;

    isDragging = true;
    const rect = element.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;

    // Initial position setzen wenn noch nicht verschoben
    if (!wasMoved) {
      element.style.left = rect.left + "px";
      element.style.top = rect.top + "px";
      element.style.transform = "none";
      element.style.right = "auto";
      element.style.bottom = "auto";
      wasMoved = true;
    }

    // Prevent text selection during drag
    document.body.style.userSelect = "none";
  };

  const drag = (e) => {
    if (!isDragging) return;

    const newLeft = e.clientX - offsetX;
    const newTop = e.clientY - offsetY;

    const rect = element.getBoundingClientRect();
    const maxX = window.innerWidth - rect.width;
    const maxY = window.innerHeight - rect.height;

    // Hauptfenster Position aktualisieren
    const finalLeft = Math.min(Math.max(0, newLeft), maxX);
    const finalTop = Math.min(Math.max(0, newTop), maxY);

    element.style.left = finalLeft + "px";
    element.style.top = finalTop + "px";

    // Direkt die Sub-UIs aktualisieren
    const settingsRect = element.getBoundingClientRect();
    const mainUIHeight = settingsRect.height;
    const mainUICenter = settingsRect.top + (mainUIHeight / 2);
    [
      wordsListDiv,
      merchantListDiv,
      blockedUsersDiv,
      window.whitelistDiv,
      document.getElementById("wordSuggestionList"),
    ].forEach((ui) => {
      if (ui?.parentNode) {
        ui.style.position = "fixed";
        ui.style.top = `${mainUICenter}px`;
        ui.style.left = `${settingsRect.right + 10}px`;
        ui.style.transform = "translateY(-50%)";
      }
    });
  };

  const stopDrag = () => {
    if (!isDragging) return;

    isDragging = false;
    document.body.style.userSelect = "";

    // Position speichern
    const rect = element.getBoundingClientRect();
    GM_setValue(
      "mdmSettingsPos",
      JSON.stringify({
        left: rect.left,
        top: rect.top,
        wasMoved: true,
      })
    );

    // Finale Position der Sub-UIs aktualisieren
    const settingsRect = element.getBoundingClientRect();
    const mainUIHeight = settingsRect.height;
    const mainUICenter = settingsRect.top + (mainUIHeight / 2);
    [
      wordsListDiv,
      merchantListDiv,
      blockedUsersDiv,
      window.whitelistDiv,
      document.getElementById("wordSuggestionList"),
    ].forEach((ui) => {
      if (ui?.parentNode) {
        ui.style.position = "fixed";
        ui.style.top = `${mainUICenter}px`;
        ui.style.left = `${settingsRect.right + 10}px`;
        ui.style.transform = "translateY(-50%)";
      }
    });
  };

  header.addEventListener("mousedown", startDrag);
  document.addEventListener("mousemove", drag);
  document.addEventListener("mouseup", stopDrag);

  // Gespeicherte Position wiederherstellen
  const savedPos = GM_getValue("mdmSettingsPos");
  if (savedPos) {
    try {
      if (DEBUG.criticalErrors) {
        console.log("[MDM Settings] Restoring position from storage:", {
          savedPosType: typeof savedPos,
          savedPosValue: savedPos,
          savedPosLength: savedPos?.length
        });
      }
      const pos = JSON.parse(savedPos);
      if (pos.wasMoved) {
        wasMoved = true;
        element.style.left = pos.left + "px";
        element.style.top = pos.top + "px";
        element.style.transform = "none";
        element.style.right = "auto";
        element.style.bottom = "auto";

        // Auch die Sub-UIs an die gespeicherte Position anpassen
        const settingsRect = element.getBoundingClientRect();
        const mainUIHeight = settingsRect.height;
        const mainUICenter = settingsRect.top + (mainUIHeight / 2);
        [
          wordsListDiv,
          merchantListDiv,
          blockedUsersDiv,
          window.whitelistDiv,
          document.getElementById("wordSuggestionList"),
        ].forEach((ui) => {
          if (ui?.parentNode) {
            ui.style.position = "fixed";
            ui.style.top = `${mainUICenter}px`;
            ui.style.left = `${settingsRect.right + 10}px`;
            ui.style.transform = "translateY(-50%)";
          }
        });
      }
    } catch (e) {
      console.error("Error restoring settings position:", e);
    }
  }

  // Resize-Handler f√ºr Fenstergr√∂√üen√§nderungen
  const handleResize = () => {
    if (!element || !element.parentElement) return;

    const rect = element.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    let newLeft = rect.left;
    let newTop = rect.top;
    let needsUpdate = false;

    // Pr√ºfe rechten Rand
    if (rect.right > vw) {
      newLeft = Math.max(0, vw - rect.width);
      needsUpdate = true;
    }

    // Pr√ºfe unteren Rand
    if (rect.bottom > vh) {
      newTop = Math.max(0, vh - rect.height);
      needsUpdate = true;
    }

    // Pr√ºfe linken Rand
    if (rect.left < 0) {
      newLeft = 0;
      needsUpdate = true;
    }

    // Pr√ºfe oberen Rand
    if (rect.top < 0) {
      newTop = 0;
      needsUpdate = true;
    }

    // Position aktualisieren falls n√∂tig
    if (needsUpdate) {
      element.style.left = newLeft + "px";
      element.style.top = newTop + "px";
      element.style.transform = "none";

      // Aktualisierte Position speichern
      GM_setValue("mdmSettingsPos", {
        left: newLeft,
        top: newTop,
      });
    }
  };

  // Resize-Event-Listener hinzuf√ºgen
  window.addEventListener("resize", handleResize);

  // Cleanup-Funktion zur√ºckgeben
  return () => {
    header.removeEventListener("mousedown", startDrag);
    document.removeEventListener("mousemove", drag);
    document.removeEventListener("mouseup", stopDrag);
    window.removeEventListener("resize", handleResize);
  };
}

// Accordion-Sektion erstellen
function createAccordionSection(title, iconName) {
  const section = document.createElement("div");
  section.className = "accordion-section";
  const colors = getThemeColors();

  section.innerHTML = `
        <div class="accordion-header" style="
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            user-select: none;
            background: ${colors.background};
            border-bottom: 1px solid ${colors.border};
            position: relative;
            z-index: 1;
        ">
            <i class="fas fa-${iconName}" style="margin-right: 10px;"></i>
            <span>${title}</span>
            <i class="fas fa-chevron-down" style="margin-left: auto; transition: transform 0.3s"></i>
        </div>
        <div class="accordion-content" style="
            display: none;
            padding: 10px;
            position: relative;
            z-index: 0;
            border-bottom: 1px solid ${colors.border};
        ">
            <div class="accordion-inner" style="
                display: flex;
                flex-direction: column;
                gap: 12px;
            ">
            </div>
        </div>
    `;

  // Hole Referenzen
  const header = section.querySelector(".accordion-header");
  const content = section.querySelector(".accordion-content");

  header.onclick = () => {
    // Schlie√üe alle anderen Sektionen
    document.querySelectorAll(".accordion-section").forEach((otherSection) => {
      if (otherSection !== section) {
        const otherContent = otherSection.querySelector(".accordion-content");
        const otherIcon = otherSection.querySelector(".fa-chevron-down");
        if (otherContent) {
          otherContent.style.display = "none";
        }
        if (otherIcon) {
          otherIcon.style.transform = "";
        }
      }
    });

    // √ñffne/Schlie√üe aktuelle Sektion
    const isOpen = content.style.display === "block";
    content.style.display = isOpen ? "none" : "block";
    header.querySelector(".fa-chevron-down").style.transform = isOpen
      ? ""
      : "rotate(180deg)";
  };

  return {
    section,
    content: section.querySelector(".accordion-inner"),
  };
}

// --- Filterlisten-Erstellung ---
// H√§ndlerliste erstellen
function createMerchantListUI() {
  const colors = getThemeColors();
  merchantListDiv.style.cssText = `
        ${getSubUIPosition()}
        padding: 15px;
        background: ${colors.background};
        border: 1px solid ${colors.border};
        border-radius: 5px;
        width: 300px;
        max-height: 90vh;
        overflow-y: auto;
        color: ${colors.text};
    `;

  const loadedMerchants = loadExcludeMerchants();
  const sortState = listSortStates.merchants;
  const currentMerchants = sortFilterList(
    loadedMerchants,
    sortState.mode,
    sortState.ascending
  );

  const merchantListHTML = currentMerchants
    .map((merchant) => {
      const key =
        merchant?.id !== undefined && merchant?.id !== null
          ? String(merchant.id)
          : normalizeForSearch(merchant?.name || "");
      let timestampText;
      if (key && merchantAddedAt[key]) {
        const data = merchantAddedAt[key];
        if (typeof data === "object") {
          // Neues Format mit { timestamp, isLegacy }
          const prefix = data.isLegacy
            ? "Hinzugef√ºgt vor dem"
            : "Hinzugef√ºgt am";
          timestampText = `${prefix} ${data.timestamp}`;
        } else {
          // Altes Format (nur Timestamp-String) - behandle als Legacy
          timestampText = `Hinzugef√ºgt vor dem ${data}`;
        }
      } else {
        timestampText = "Hinzugef√ºgt am Unbekannt";
      }
      return `
        <div class="merchant-item" style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 5px;
            background: ${colors.itemBg};
            color: ${colors.text};
            border: 1px solid ${colors.border};
            border-radius: 3px;
            position: relative;">
            <span class="merchant-text" style="${
              IS_TOUCH_DEVICE ? "cursor: pointer;" : ""
            }" title="${timestampText}">${merchant.name}</span>
            ${
              IS_TOUCH_DEVICE
                ? `<span class="timestamp-tooltip" style="
                display: none;
                position: absolute;
                background: ${colors.background};
                border: 1px solid ${colors.border};
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 11px;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">${timestampText}</span>`
                : ""
            }
            <button class="delete-merchant" data-id="${merchant.id}" style="
                background: none;
                border: none;
                cursor: pointer;
                color: ${colors.text};
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;">
                <svg width="16" height="16">
                    <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                </svg>
            </button>
        </div>
    `;
    })
    .join("");

  merchantListDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Ausgeblendete H√§ndler (${
              currentMerchants.length
            })</h4>
            <div style="position: relative;">
                <button id="sortMerchantsDropdown" class="sort-dropdown-btn" style="
                    background: ${colors.buttonBg};
                    border: 1px solid ${colors.buttonBorder};
                    color: ${colors.text};
                    cursor: pointer;
                    padding: 6px 10px;
                    border-radius: 3px;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 14px;
                " title="Sortierung">
                    ${
                      sortState.mode === "alphabetical"
                        ? '<span style="font-weight: bold;">AZ</span>'
                        : '<i class="fas fa-clock"></i>'
                    }
                    <i class="fas fa-chevron-down" style="font-size: 10px; margin-left: 2px;"></i>
                </button>
                <div id="sortMerchantsMenu" style="
                    display: none;
                    position: absolute;
                    top: 100%;
                    right: 0;
                    margin-top: 4px;
                    background: ${colors.background};
                    border: 1px solid ${colors.border};
                    border-radius: 3px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    z-index: 1000;
                    min-width: 160px;
                ">
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">AZ</span>
                        <span style="flex: 1;">Aufsteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">ZA</span>
                        <span style="flex: 1;">Absteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">Neueste zuerst</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">√Ñlteste zuerst</span>
                    </button>
                </div>
            </div>
        </div>
        <input type="text" id="merchantSearch" placeholder="H√§ndler suchen..."
            style="
                width: 100%;
                padding: 5px;
                margin-bottom: 10px;
                background: ${colors.inputBg};
                border: 1px solid ${colors.border};
                color: ${colors.text};
                border-radius: 3px;">
        <div style="margin-bottom: 15px;">
            <div id="merchantList" style="
                margin-bottom: 10px;
                max-height: 60vh;
                overflow-y: auto;
                padding-right: 5px;
                touch-action: pan-y;
                -webkit-overflow-scrolling: touch;">
                ${merchantListHTML}
            </div>
            <button id="clearMerchantListButton" style="
                width: 100%;
                padding: 5px 10px;
                background: ${colors.buttonBg};
                border: 1px solid ${colors.buttonBorder};
                color: ${colors.text};
                border-radius: 3px;
                cursor: pointer;
                margin-top: 10px;">
                <span style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="16" height="16">
                        <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                    </svg>
                    Alle H√§ndler entfernen
                </span>
            </button>
        </div>
        <div style="
            margin-top: 20px;
            display: flex;
            justify-content: center;
        ">
            <button id="closeMerchantListButton" class="button button--type-secondary button--mode-default button--shape-circle">
                <span>Schlie√üen</span>
            </button>
        </div>
    `;

  // Add the div to the document body
  document.body.appendChild(merchantListDiv);
  setupClickOutsideHandler();

  // Nach dem Hinzuf√ºgen zum DOM den Button anpassen
  document.getElementById("closeMerchantListButton").style.cssText = `
        padding: 8px 16px;
        display: inline-block;
        width: auto;
        min-width: 100px;
        text-align: center;
    `;

  // Sortier-Dropdown Event-Listener
  const merchantsDropdownBtn = document.getElementById("sortMerchantsDropdown");
  const merchantsDropdownMenu = document.getElementById("sortMerchantsMenu");

  merchantsDropdownBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    merchantsDropdownMenu.style.display =
      merchantsDropdownMenu.style.display === "none" ? "block" : "none";
  });

  // Schlie√üe Dropdown bei Klick au√üerhalb
  const closeMerchantsDropdown = (e) => {
    if (
      !merchantsDropdownBtn.contains(e.target) &&
      !merchantsDropdownMenu.contains(e.target)
    ) {
      merchantsDropdownMenu.style.display = "none";
    }
  };
  document.addEventListener("click", closeMerchantsDropdown);

  // Men√º-Items Event-Listener
  merchantsDropdownMenu.querySelectorAll(".sort-menu-item").forEach((item) => {
    item.addEventListener("click", (e) => {
      e.stopPropagation();
      const mode = item.dataset.mode;
      const ascending = item.dataset.asc === "true";
      listSortStates.merchants.mode = mode;
      listSortStates.merchants.ascending = ascending;
      document.removeEventListener("click", closeMerchantsDropdown);
      // UI neu aufbauen ohne activeSubUI zu √§ndern
      const oldDiv = merchantListDiv;
      if (oldDiv && oldDiv.parentNode) {
        oldDiv.parentNode.removeChild(oldDiv);
      }
      createMerchantListUI();
    });
    // Hover-Effekt
    item.addEventListener("mouseenter", () => {
      item.style.background = colors.itemBg;
    });
    item.addEventListener("mouseleave", () => {
      item.style.background = "none";
    });
  });

  // Add search functionality
  const searchInput = document.getElementById("merchantSearch");
  searchInput.addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    let visibleCount = 0;
    // Hole aktuelle H√§ndler statt die urspr√ºngliche Liste zu verwenden
    const currentMerchants = loadExcludeMerchants();
    const totalCount = currentMerchants.length;

    document.querySelectorAll(".merchant-item").forEach((item) => {
      const merchantName = item.querySelector("span").textContent.toLowerCase();
      const isVisible = merchantName.includes(searchTerm);
      item.style.display = isVisible ? "flex" : "none";
      if (isVisible) visibleCount++;
    });

    // Update heading counter
    const heading = merchantListDiv.querySelector("h4");
    if (heading) {
      heading.textContent = searchTerm
        ? `Ausgeblendete H√§ndler (${visibleCount}/${totalCount})`
        : `Ausgeblendete H√§ndler (${totalCount})`;
    }
  });

  // Alle H√§ndler entfernen Button
  document
    .getElementById("clearMerchantListButton")
    .addEventListener("click", () => {
      if (
        confirm("M√∂chten Sie wirklich alle H√§ndler aus der Liste entfernen?")
      ) {
        saveExcludeMerchants([]);
        merchantAddedAt = {};
        GM_setValue("merchantAddedAt", merchantAddedAt);
        document.getElementById("merchantList").innerHTML = "";
        excludeMerchantIDs = [];
        rebuildExcludeMerchantCache([]);
        processArticles();

        // Immediately update counter in heading
        const heading = merchantListDiv.querySelector("h4");
        if (heading) {
          heading.textContent = "Ausgeblendete H√§ndler (0)";
        }
      }
    });

  document.querySelectorAll(".delete-merchant").forEach((button) => {
    button.addEventListener("click", function (e) {
      handleMerchantDelete(e);
    });
  });

  // Touch-Handler f√ºr Timestamp-Anzeige auf mobilen Ger√§ten
  if (IS_TOUCH_DEVICE) {
    console.log(
      "[MDM Touch] Setting up touch handlers for merchant timestamps"
    );
    const merchantTexts = document.querySelectorAll(".merchant-text");
    console.log(
      "[MDM Touch] Found merchant-text elements:",
      merchantTexts.length
    );

    merchantTexts.forEach((merchantText, index) => {
      merchantText.addEventListener("click", function (e) {
        e.stopPropagation();
        const tooltip = this.nextElementSibling;

        if (tooltip && tooltip.classList.contains("timestamp-tooltip")) {
          // Check visibility BEFORE hiding all tooltips
          const computedDisplay = window.getComputedStyle(tooltip).display;
          const isVisible = computedDisplay === "block";

          // Hide all tooltips
          document.querySelectorAll(".timestamp-tooltip").forEach((t) => {
            t.style.display = "none";
          });

          // Show this tooltip only if it wasn't visible before
          if (!isVisible) {
            const item = this.closest(".merchant-item");
            const itemRect = item.getBoundingClientRect();
            const tooltipHeight = 30;
            const spaceAbove = itemRect.top;
            const spaceBelow = window.innerHeight - itemRect.bottom;

            if (spaceAbove < tooltipHeight && spaceBelow > tooltipHeight) {
              tooltip.style.bottom = "auto";
              tooltip.style.top = "100%";
              tooltip.style.marginTop = "4px";
              tooltip.style.marginBottom = "0";
            } else {
              tooltip.style.top = "auto";
              tooltip.style.bottom = "100%";
              tooltip.style.marginBottom = "4px";
              tooltip.style.marginTop = "0";
            }
            tooltip.style.display = "block";
          }
        }
      });
    });
  }

  // Update close button handlers in createMerchantListUI
  document
    .getElementById("closeMerchantListButton")
    .addEventListener("click", (e) => {
      e.stopPropagation(); // Prevent event bubbling
      closeActiveSubUI();
    });
}
// W√∂rterliste erstellen
function createExcludeWordsUI() {
  const colors = getThemeColors();
  wordsListDiv.style.cssText = `
        ${getSubUIPosition()}
        padding: 15px;
        background: ${colors.background};
        border: 1px solid ${colors.border};
        border-radius: 5px;
        width: 300px;
        max-height: 90vh;
        overflow-y: auto;
        color: ${colors.text};
    `;

  const loadedWords = loadExcludeWords();
  const sortState = listSortStates.words;
  const currentWords = sortFilterList(
    loadedWords,
    sortState.mode,
    sortState.ascending
  );

  const wordsListHTML = currentWords
    .map((word) => {
      const normalized = normalizeForSearch(word);
      const data = wordAddedAt[normalized];
      let timestampText;
      if (data && typeof data === "object") {
        // Neues Format mit { timestamp, isLegacy }
        const prefix = data.isLegacy ? "Hinzugef√ºgt vor dem" : "Hinzugef√ºgt am";
        timestampText = `${prefix} ${data.timestamp}`;
      } else if (data) {
        // Altes Format (nur Timestamp-String) - behandle als Legacy
        timestampText = `Hinzugef√ºgt vor dem ${data}`;
      } else {
        timestampText = "Hinzugef√ºgt am Unbekannt";
      }
      return `
        <div class="word-item" style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 5px;
            background: ${colors.itemBg};
            color: ${colors.text};
            border: 1px solid ${colors.border};
            border-radius: 3px;
            position: relative;">
            <span class="word-text" style="word-break: break-word; ${
              IS_TOUCH_DEVICE ? "cursor: pointer;" : ""
            }" title="${timestampText}">${word}</span>
            ${
              IS_TOUCH_DEVICE
                ? `<span class="timestamp-tooltip" style="
                display: none;
                position: absolute;
                background: ${colors.background};
                border: 1px solid ${colors.border};
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 11px;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">${timestampText}</span>`
                : ""
            }
            <button class="delete-word" data-word="${word}" style="
                background: none;
                border: none;
                cursor: pointer;
                color: ${colors.text};
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;">
                <svg width="16" height="16">
                    <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                </svg>
            </button>
        </div>
    `;
    })
    .join("");

  wordsListDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Ausgeblendete W√∂rter (${
              currentWords.length
            })</h4>
            <div style="position: relative;">
                <button id="sortWordsDropdown" class="sort-dropdown-btn" style="
                    background: ${colors.buttonBg};
                    border: 1px solid ${colors.buttonBorder};
                    color: ${colors.text};
                    cursor: pointer;
                    padding: 6px 10px;
                    border-radius: 3px;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 14px;
                " title="Sortierung">
                    ${
                      sortState.mode === "alphabetical"
                        ? '<span style="font-weight: bold;">AZ</span>'
                        : '<i class="fas fa-clock"></i>'
                    }
                    <i class="fas fa-chevron-down" style="font-size: 10px; margin-left: 2px;"></i>
                </button>
                <div id="sortWordsMenu" style="
                    display: none;
                    position: absolute;
                    top: 100%;
                    right: 0;
                    margin-top: 4px;
                    background: ${colors.background};
                    border: 1px solid ${colors.border};
                    border-radius: 3px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    z-index: 1000;
                    min-width: 160px;
                ">
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">AZ</span>
                        <span style="flex: 1;">Aufsteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">ZA</span>
                        <span style="flex: 1;">Absteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">Neueste zuerst</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">√Ñlteste zuerst</span>
                    </button>
                </div>
            </div>
        </div>
        <input type="text" id="wordSearch" placeholder="W√∂rter suchen..."
            style="
                width: 100%;
                padding: 5px;
                margin-bottom: 10px;
                background: ${colors.inputBg};
                border: 1px solid ${colors.border};
                color: ${colors.text};
                border-radius: 3px;">
        <div style="margin-bottom: 15px;">
            <div id="wordsList" style="
                margin-bottom: 10px;
                max-height: 60vh;
                overflow-y: auto;
                padding-right: 5px;
                touch-action: pan-y;
                -webkit-overflow-scrolling: touch;">
                ${wordsListHTML}
            </div>
            <button id="clearWordsListButton" style="
                width: 100%;
                padding: 5px 10px;
                background: ${colors.buttonBg};
                border: 1px solid ${colors.buttonBorder};
                color: ${colors.text};
                border-radius: 3px;
                cursor: pointer;
                margin-top: 10px;">
                <span style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="16" height="16">
                        <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                    </svg>
                    Alle W√∂rter entfernen
                </span>
            </button>
        </div>
        <div style="
            margin-top: 20px;
            display: flex;
            justify-content: center;
        ">
            <button id="closeWordsListButton" class="button button--type-secondary button--mode-default button--shape-circle">
                <span>Schlie√üen</span>
            </button>
        </div>
    `;

  // Add the div to the document body
  document.body.appendChild(wordsListDiv);
  setupClickOutsideHandler();

  // Nach dem Hinzuf√ºgen zum DOM den Button anpassen
  document.getElementById("closeWordsListButton").style.cssText = `
        padding: 8px 16px;
        display: inline-block;
        width: auto;
        min-width: 100px;
        text-align: center;
    `;

  // Sortier-Dropdown Event-Listener
  const wordsDropdownBtn = document.getElementById("sortWordsDropdown");
  const wordsDropdownMenu = document.getElementById("sortWordsMenu");

  wordsDropdownBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    wordsDropdownMenu.style.display =
      wordsDropdownMenu.style.display === "none" ? "block" : "none";
  });

  // Schlie√üe Dropdown bei Klick au√üerhalb
  const closeWordsDropdown = (e) => {
    if (
      !wordsDropdownBtn.contains(e.target) &&
      !wordsDropdownMenu.contains(e.target)
    ) {
      wordsDropdownMenu.style.display = "none";
    }
  };
  document.addEventListener("click", closeWordsDropdown);

  // Men√º-Items Event-Listener
  wordsDropdownMenu.querySelectorAll(".sort-menu-item").forEach((item) => {
    item.addEventListener("click", (e) => {
      e.stopPropagation();
      const mode = item.dataset.mode;
      const ascending = item.dataset.asc === "true";
      listSortStates.words.mode = mode;
      listSortStates.words.ascending = ascending;
      document.removeEventListener("click", closeWordsDropdown);
      // UI neu aufbauen ohne activeSubUI zu √§ndern
      const oldDiv = wordsListDiv;
      if (oldDiv && oldDiv.parentNode) {
        oldDiv.parentNode.removeChild(oldDiv);
      }
      createExcludeWordsUI();
    });
    // Hover-Effekt
    item.addEventListener("mouseenter", () => {
      item.style.background = colors.itemBg;
    });
    item.addEventListener("mouseleave", () => {
      item.style.background = "none";
    });
  });

  // Add search functionality
  const searchInput = document.getElementById("wordSearch");
  searchInput.addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    let visibleCount = 0;
    // Hole aktuelle W√∂rter statt die urspr√ºngliche Liste zu verwenden
    const currentWords = loadExcludeWords();
    const totalCount = currentWords.length;

    document.querySelectorAll(".word-item").forEach((item) => {
      const word = item.querySelector("span").textContent.toLowerCase();
      const isVisible = word.includes(searchTerm);
      item.style.display = isVisible ? "flex" : "none";
      if (isVisible) visibleCount++;
    });

    // Update heading counter
    const heading = wordsListDiv.querySelector("h4");
    if (heading) {
      heading.textContent = searchTerm
        ? `Ausgeblendete W√∂rter (${visibleCount}/${totalCount})`
        : `Ausgeblendete W√∂rter (${totalCount})`;
    }
  });

  // Alle W√∂rter entfernen Button
  document
    .getElementById("clearWordsListButton")
    .addEventListener("click", () => {
      if (
        confirm("M√∂chten Sie wirklich alle W√∂rter aus der Liste entfernen?")
      ) {
        saveExcludeWords([]);
        wordAddedAt = {};
        GM_setValue("wordAddedAt", wordAddedAt);
        document.getElementById("wordsList").innerHTML = "";
        excludeWords = [];
        processArticles();

        // Immediately update counter in heading
        const heading = wordsListDiv.querySelector("h4");
        if (heading) {
          heading.textContent = "Ausgeblendete W√∂rter (0)";
        }
      }
    });

  // Add delete handlers
  document.querySelectorAll(".delete-word").forEach((button) => {
    button.addEventListener("click", function (e) {
      handleWordDelete(e);
    });
  });

  // Touch-Handler f√ºr Timestamp-Anzeige auf mobilen Ger√§ten
  if (IS_TOUCH_DEVICE) {
    console.log(
      "[MDM Touch] Setting up touch handlers for word timestamps, IS_TOUCH_DEVICE:",
      IS_TOUCH_DEVICE
    );
    const wordTexts = document.querySelectorAll(".word-text");

    wordTexts.forEach((wordText, index) => {
      wordText.addEventListener("click", function (e) {
        e.stopPropagation();
        const tooltip = this.nextElementSibling;

        if (tooltip && tooltip.classList.contains("timestamp-tooltip")) {
          // Check visibility BEFORE hiding all tooltips
          const computedDisplay = window.getComputedStyle(tooltip).display;
          const isVisible = computedDisplay === "block";

          // Hide all tooltips
          document.querySelectorAll(".timestamp-tooltip").forEach((t) => {
            t.style.display = "none";
          });

          // Show this tooltip only if it wasn't visible before
          if (!isVisible) {
            // Positioniere Tooltip dynamisch: oben oder unten
            const item = this.closest(".word-item");
            const itemRect = item.getBoundingClientRect();
            const container = document.getElementById("wordsList");
            const containerRect = container.getBoundingClientRect();
            const tooltipHeight = 30; // Gesch√§tzte H√∂he
            const spaceAbove = itemRect.top - containerRect.top;
            const spaceBelow = containerRect.bottom - itemRect.bottom;

            if (spaceAbove < tooltipHeight && spaceBelow > tooltipHeight) {
              tooltip.style.bottom = "auto";
              tooltip.style.top = "100%";
              tooltip.style.marginTop = "4px";
              tooltip.style.marginBottom = "0";
            } else {
              tooltip.style.top = "auto";
              tooltip.style.bottom = "100%";
              tooltip.style.marginBottom = "4px";
              tooltip.style.marginTop = "0";
            }
            tooltip.style.display = "block";
          }
        }
      });
    });
  }

  // Update close button handlers in createExcludeWordsUI
  document
    .getElementById("closeWordsListButton")
    .addEventListener("click", (e) => {
      e.stopPropagation(); // Prevent event bubbling
      closeActiveSubUI();
    });
  // Before adding to DOM
  document.body.appendChild(wordsListDiv);

  setupClickOutsideHandler();
}

// Whitelist UI erstellen
function createWhitelistUI() {
  const colors = getThemeColors();

  // Erstelle Container wenn nicht vorhanden
  if (!window.whitelistDiv) {
    window.whitelistDiv = document.createElement("div");
  }

  window.whitelistDiv.style.cssText = `
        ${getSubUIPosition()}
        padding: 15px;
        background: ${colors.background};
        border: 1px solid ${colors.border};
        border-radius: 5px;
        width: 300px;
        max-height: 90vh;
        overflow-y: auto;
        color: ${colors.text};
    `;

  const loadedWords = loadWhitelistWords();
  const sortState = listSortStates.whitelist || {
    mode: "added",
    ascending: false,
  };
  listSortStates.whitelist = sortState;
  const currentWords = sortFilterList(
    loadedWords,
    sortState.mode,
    sortState.ascending
  );

  const wordsListHTML = currentWords
    .map((word) => {
      const normalized = normalizeForSearch(word);
      const data = whitelistAddedAt[normalized];
      let timestampText;
      if (data && typeof data === "object") {
        const prefix = data.isLegacy ? "Hinzugef√ºgt vor dem" : "Hinzugef√ºgt am";
        timestampText = `${prefix} ${data.timestamp}`;
      } else if (data) {
        timestampText = `Hinzugef√ºgt vor dem ${data}`;
      } else {
        timestampText = "Hinzugef√ºgt am Unbekannt";
      }
      return `
        <div class="word-item" style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 5px;
            background: ${colors.itemBg};
            color: ${colors.text};
            border: 1px solid ${colors.border};
            border-radius: 3px;
            position: relative;">
            <span class="word-text" style="word-break: break-word; ${
              IS_TOUCH_DEVICE ? "cursor: pointer;" : ""
            }" title="${timestampText}">${word}</span>
            ${
              IS_TOUCH_DEVICE
                ? `<span class="timestamp-tooltip" style="
                display: none;
                position: absolute;
                background: ${colors.background};
                border: 1px solid ${colors.border};
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 11px;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">${timestampText}</span>`
                : ""
            }
            <button class="delete-whitelist-word" data-word="${word}" style="
                background: none;
                border: none;
                cursor: pointer;
                color: ${colors.text};
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;">
                <svg width="16" height="16">
                    <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                </svg>
            </button>
        </div>
    `;
    })
    .join("");

  window.whitelistDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Whitelist-W√∂rter (${
              currentWords.length
            })</h4>
            <div style="position: relative;">
                <button id="sortWhitelistDropdown" class="sort-dropdown-btn" style="
                    background: ${colors.buttonBg};
                    border: 1px solid ${colors.buttonBorder};
                    color: ${colors.text};
                    cursor: pointer;
                    padding: 6px 10px;
                    border-radius: 3px;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 14px;
                " title="Sortierung">
                    ${
                      sortState.mode === "alphabetical"
                        ? '<span style="font-weight: bold;">AZ</span>'
                        : '<i class="fas fa-clock"></i>'
                    }
                    <i class="fas fa-chevron-down" style="font-size: 10px; margin-left: 2px;"></i>
                </button>
                <div id="sortWhitelistMenu" style="
                    display: none;
                    position: absolute;
                    top: 100%;
                    right: 0;
                    margin-top: 4px;
                    background: ${colors.background};
                    border: 1px solid ${colors.border};
                    border-radius: 3px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    z-index: 1000;
                    min-width: 160px;
                ">
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">AZ</span>
                        <span style="flex: 1;">Aufsteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">ZA</span>
                        <span style="flex: 1;">Absteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">Neueste zuerst</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">√Ñlteste zuerst</span>
                    </button>
                </div>
            </div>
        </div>
        <input type="text" id="whitelistSearch" placeholder="W√∂rter suchen..."
            style="
                width: 100%;
                padding: 5px;
                margin-bottom: 10px;
                background: ${colors.inputBg};
                border: 1px solid ${colors.border};
                color: ${colors.text};
                border-radius: 3px;">
        <div style="margin-bottom: 15px;">
            <div id="whitelistWordsList" style="
                margin-bottom: 10px;
                max-height: 60vh;
                overflow-y: auto;
                padding-right: 5px;
                touch-action: pan-y;
                -webkit-overflow-scrolling: touch;">
                ${wordsListHTML}
            </div>
            <button id="clearWhitelistButton" style="
                width: 100%;
                padding: 5px 10px;
                background: ${colors.buttonBg};
                border: 1px solid ${colors.buttonBorder};
                color: ${colors.text};
                border-radius: 3px;
                cursor: pointer;
                margin-top: 10px;">
                <span style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="16" height="16">
                        <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                    </svg>
                    Alle W√∂rter entfernen
                </span>
            </button>
        </div>
        <div style="
            margin-top: 20px;
            display: flex;
            justify-content: center;
        ">
            <button id="closeWhitelistButton" class="button button--type-secondary button--mode-default button--shape-circle">
                <span>Schlie√üen</span>
            </button>
        </div>
    `;

  document.body.appendChild(window.whitelistDiv);
  activeSubUI = "whitelist";
  setupClickOutsideHandler();

  // Nach dem Hinzuf√ºgen zum DOM den Button anpassen
  document.getElementById("closeWhitelistButton").style.cssText = `
        padding: 8px 16px;
        display: inline-block;
        width: auto;
        min-width: 100px;
        text-align: center;
    `;

  // Sortier-Dropdown Event-Listener
  const whitelistDropdownBtn = document.getElementById("sortWhitelistDropdown");
  const whitelistDropdownMenu = document.getElementById("sortWhitelistMenu");

  whitelistDropdownBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    whitelistDropdownMenu.style.display =
      whitelistDropdownMenu.style.display === "none" ? "block" : "none";
  });

  // Schlie√üe Dropdown bei Klick au√üerhalb
  const closeWhitelistDropdown = (e) => {
    if (
      !whitelistDropdownBtn.contains(e.target) &&
      !whitelistDropdownMenu.contains(e.target)
    ) {
      whitelistDropdownMenu.style.display = "none";
    }
  };
  document.addEventListener("click", closeWhitelistDropdown);

  // Men√º-Items Event-Listener
  whitelistDropdownMenu.querySelectorAll(".sort-menu-item").forEach((item) => {
    item.addEventListener("click", (e) => {
      e.stopPropagation();
      const mode = item.dataset.mode;
      const ascending = item.dataset.asc === "true";
      listSortStates.whitelist.mode = mode;
      listSortStates.whitelist.ascending = ascending;
      document.removeEventListener("click", closeWhitelistDropdown);
      // UI neu aufbauen ohne activeSubUI zu √§ndern
      const oldDiv = window.whitelistDiv;
      if (oldDiv && oldDiv.parentNode) {
        oldDiv.parentNode.removeChild(oldDiv);
      }
      createWhitelistUI();
    });
    // Hover-Effekt
    item.addEventListener("mouseenter", () => {
      item.style.background = colors.itemBg;
    });
    item.addEventListener("mouseleave", () => {
      item.style.background = "none";
    });
  });

  // Add search functionality
  const searchInput = document.getElementById("whitelistSearch");
  searchInput.addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    let visibleCount = 0;
    const currentWords = loadWhitelistWords();
    const totalCount = currentWords.length;

    document.querySelectorAll(".word-item").forEach((item) => {
      const word = item.querySelector("span").textContent.toLowerCase();
      const isVisible = word.includes(searchTerm);
      item.style.display = isVisible ? "flex" : "none";
      if (isVisible) visibleCount++;
    });

    // Update heading counter
    const heading = window.whitelistDiv.querySelector("h4");
    if (heading) {
      heading.textContent = searchTerm
        ? `Whitelist-W√∂rter (${visibleCount}/${totalCount})`
        : `Whitelist-W√∂rter (${totalCount})`;
    }
  });

  // Alle W√∂rter entfernen Button
  document
    .getElementById("clearWhitelistButton")
    .addEventListener("click", () => {
      if (
        confirm("M√∂chten Sie wirklich alle W√∂rter aus der Whitelist entfernen?")
      ) {
        saveWhitelistWords([]);
        whitelistAddedAt = {};
        GM_setValue("whitelistAddedAt", whitelistAddedAt);
        document.getElementById("whitelistWordsList").innerHTML = "";
        whitelistWords = [];
        processArticles();

        // Immediately update counter in heading
        const heading = window.whitelistDiv.querySelector("h4");
        if (heading) {
          heading.textContent = "Whitelist-W√∂rter (0)";
        }
      }
    });

  // Add delete handlers
  document.querySelectorAll(".delete-whitelist-word").forEach((button) => {
    button.addEventListener("click", function (e) {
      e.stopPropagation();
      const word = button.dataset.word;
      const currentList = loadWhitelistWords();
      const filtered = currentList.filter((w) => w !== word);
      saveWhitelistWords(filtered);

      // Remove normalized timestamp
      const normalized = normalizeForSearch(word);
      delete whitelistAddedAt[normalized];
      GM_setValue("whitelistAddedAt", whitelistAddedAt);

      createWhitelistUI();
    });
  });

  // Touch-Handler f√ºr Timestamp-Anzeige auf mobilen Ger√§ten
  if (IS_TOUCH_DEVICE) {
    const wordTexts = document.querySelectorAll(".word-text");

    wordTexts.forEach((wordText) => {
      wordText.addEventListener("click", function (e) {
        e.stopPropagation();
        const tooltip = this.nextElementSibling;

        if (tooltip && tooltip.classList.contains("timestamp-tooltip")) {
          // Check visibility BEFORE hiding all tooltips
          const computedDisplay = window.getComputedStyle(tooltip).display;
          const isVisible = computedDisplay === "block";

          // Hide all tooltips
          document.querySelectorAll(".timestamp-tooltip").forEach((t) => {
            t.style.display = "none";
          });

          // Show this tooltip only if it wasn't visible before
          if (!isVisible) {
            // Positioniere Tooltip dynamisch: oben oder unten
            const item = this.closest(".word-item");
            const itemRect = item.getBoundingClientRect();
            const container = document.getElementById("whitelistWordsList");
            const containerRect = container.getBoundingClientRect();
            const tooltipHeight = 30; // Gesch√§tzte H√∂he
            const spaceAbove = itemRect.top - containerRect.top;
            const spaceBelow = containerRect.bottom - itemRect.bottom;

            if (spaceAbove < tooltipHeight && spaceBelow > tooltipHeight) {
              tooltip.style.bottom = "auto";
              tooltip.style.top = "100%";
              tooltip.style.marginTop = "4px";
              tooltip.style.marginBottom = "0";
            } else {
              tooltip.style.top = "auto";
              tooltip.style.bottom = "100%";
              tooltip.style.marginBottom = "4px";
              tooltip.style.marginTop = "0";
            }
            tooltip.style.display = "block";
          }
        }
      });
    });
  }

  // Close button handler
  document
    .getElementById("closeWhitelistButton")
    .addEventListener("click", (e) => {
      e.stopPropagation();
      closeActiveSubUI();
    });
}

// Blockierte Benutzer UI erstellen
function createBlockedUsersUI() {
  const colors = getThemeColors();
  blockedUsersDiv.id = "blockedUsersDiv";
  blockedUsersDiv.style.cssText = `
        ${getSubUIPosition()}
        padding: 15px;
        background: ${colors.background};
        border: 1px solid ${colors.border};
        border-radius: 5px;
        width: 300px;
        max-height: 90vh;
        overflow-y: auto;
        color: ${colors.text};
    `;

  // Lade blockierte Benutzer (Object-Format)
  const blockedUsersObj = GM_getValue("blockedUsers", {});

  // Konvertiere Object zu Array f√ºr Sortierung (displayName)
  const loadedUsers = Object.values(blockedUsersObj).map(user => {
    // Fallback f√ºr alte Array-Eintr√§ge (nur String)
    if (typeof user === 'string') {
      return { displayName: user, normalizedUsername: user.toLowerCase() };
    }
    return user;
  });

  ensureUserTimestamps(loadedUsers.map(u => u.normalizedUsername), false);
  const sortState = listSortStates.users;
  const blockedUsers = sortFilterList(
    loadedUsers.map(u => u.normalizedUsername),
    sortState.mode,
    sortState.ascending
  ).map(normalizedKey => {
    // Finde Original-Objekt f√ºr displayName
    const userObj = loadedUsers.find(u => u.normalizedUsername === normalizedKey);
    return userObj || { displayName: normalizedKey, normalizedUsername: normalizedKey };
  });

  if (DEBUG.userBlocking) {
    console.log(
      "[MDM UserBlock] Loading blocked users UI, count:",
      blockedUsers.length,
      "users:",
      blockedUsers
    );
  }

  const blockedUsersHTML = blockedUsers
    .map((userObj) => {
      const key = userObj.normalizedUsername;
      const displayName = userObj.displayName;
      let timestampText;
      if (key && userAddedAt[key]) {
        const data = userAddedAt[key];
        if (typeof data === "object") {
          // Neues Format mit { timestamp, isLegacy }
          const prefix = data.isLegacy
            ? "Hinzugef√ºgt vor dem"
            : "Hinzugef√ºgt am";
          timestampText = `${prefix} ${data.timestamp}`;
        } else {
          // Altes Format (nur Timestamp-String) - behandle als Legacy
          timestampText = `Hinzugef√ºgt vor dem ${data}`;
        }
      } else {
        timestampText = "Hinzugef√ºgt am Unbekannt";
      }
      return `
        <div class="user-item" style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            padding: 5px;
            background: ${colors.itemBg};
            color: ${colors.text};
            border: 1px solid ${colors.border};
            border-radius: 3px;
            position: relative;">
            <span class="user-text" style="${
              IS_TOUCH_DEVICE ? "cursor: pointer;" : ""
            }" title="${timestampText}">${displayName}</span>
            ${
              IS_TOUCH_DEVICE
                ? `<span class="timestamp-tooltip" style="
                display: none;
                position: absolute;
                background: ${colors.background};
                border: 1px solid ${colors.border};
                padding: 4px 8px;
                border-radius: 3px;
                font-size: 11px;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            ">${timestampText}</span>`
                : ""
            }
            <button class="delete-user" data-user="${key}" style="
                background: none;
                border: none;
                cursor: pointer;
                color: ${colors.text};
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;">
                <svg width="16" height="16">
                    <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                </svg>
            </button>
        </div>
    `;
    })
    .join("");

  blockedUsersDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="margin: 0;">Ausgeblendete Benutzer (${
              blockedUsers.length
            })</h4>
            <div style="position: relative;">
                <button id="sortUsersDropdown" class="sort-dropdown-btn" style="
                    background: ${colors.buttonBg};
                    border: 1px solid ${colors.buttonBorder};
                    color: ${colors.text};
                    cursor: pointer;
                    padding: 6px 10px;
                    border-radius: 3px;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 14px;
                " title="Sortierung">
                    ${
                      sortState.mode === "alphabetical"
                        ? '<span style="font-weight: bold;">AZ</span>'
                        : '<i class="fas fa-clock"></i>'
                    }
                    <i class="fas fa-chevron-down" style="font-size: 10px; margin-left: 2px;"></i>
                </button>
                <div id="sortUsersMenu" style="
                    display: none;
                    position: absolute;
                    top: 100%;
                    right: 0;
                    margin-top: 4px;
                    background: ${colors.background};
                    border: 1px solid ${colors.border};
                    border-radius: 3px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    z-index: 1000;
                    min-width: 160px;
                ">
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">AZ</span>
                        <span style="flex: 1;">Aufsteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="alphabetical" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'alphabetical' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <span style="font-weight: bold; width: 20px;">ZA</span>
                        <span style="flex: 1;">Absteigend</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="false" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === false ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === false ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                        border-bottom: 1px solid ${colors.border};
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">Neueste zuerst</span>
                    </button>
                    <button class="sort-menu-item" data-mode="added" data-asc="true" style="
                        width: 100%;
                        padding: 8px 12px;
                        background: none;
                        border: none;
                        color: ${sortState.mode === 'added' && sortState.ascending === true ? '#4cb748' : colors.text};
                        font-weight: ${sortState.mode === 'added' && sortState.ascending === true ? 'bold' : 'normal'};
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        font-size: 13px;
                    ">
                        <i class="fas fa-clock" style="width: 20px;"></i>
                        <span style="flex: 1;">√Ñlteste zuerst</span>
                    </button>
                </div>
            </div>
        </div>
        <input type="text" id="userSearch" placeholder="Benutzer suchen..."
            style="
                width: 100%;
                padding: 5px;
                margin-bottom: 10px;
                background: ${colors.inputBg};
                border: 1px solid ${colors.border};
                color: ${colors.text};
                border-radius: 3px;">
        <div style="margin-bottom: 15px;">
            <div id="usersList" style="
                margin-bottom: 10px;
                max-height: 60vh;
                overflow-y: auto;
                padding-right: 5px;
                touch-action: pan-y;
                -webkit-overflow-scrolling: touch;">
                ${blockedUsersHTML}
            </div>
            <button id="clearBlockedUsersButton" style="
                width: 100%;
                padding: 5px 10px;
                background: ${colors.buttonBg};
                border: 1px solid ${colors.buttonBorder};
                color: ${colors.text};
                border-radius: 3px;
                cursor: pointer;
                margin-top: 10px;">
                <span style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="16" height="16">
                        <use xlink:href="https://www.mydealz.de/assets/img/ico_632f5.svg#trash"></use>
                    </svg>
                    Alle Benutzer entfernen
                </span>
            </button>
        </div>
        <div style="
            margin-top: 20px;
            display: flex;
            justify-content: center;
        ">
            <button id="closeBlockedUsersButton" class="button button--type-secondary button--mode-default button--shape-circle">
                <span>Schlie√üen</span>
            </button>
        </div>
    `;

  document.body.appendChild(blockedUsersDiv);
  setupClickOutsideHandler();

  // Nach dem Hinzuf√ºgen zum DOM den Button anpassen
  document.getElementById("closeBlockedUsersButton").style.cssText = `
        padding: 8px 16px;
        display: inline-block;
        width: auto;
        min-width: 100px;
        text-align: center;
    `;

  // Sortier-Dropdown Event-Listener
  const usersDropdownBtn = document.getElementById("sortUsersDropdown");
  const usersDropdownMenu = document.getElementById("sortUsersMenu");

  if (usersDropdownBtn && usersDropdownMenu) {
    usersDropdownBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      usersDropdownMenu.style.display =
        usersDropdownMenu.style.display === "none" ? "block" : "none";
    });

    // Schlie√üe Dropdown bei Klick au√üerhalb
    const closeUsersDropdown = (e) => {
      if (
        !usersDropdownBtn.contains(e.target) &&
        !usersDropdownMenu.contains(e.target)
      ) {
        usersDropdownMenu.style.display = "none";
      }
    };
    document.addEventListener("click", closeUsersDropdown);

    // Men√º-Items Event-Listener
    usersDropdownMenu.querySelectorAll(".sort-menu-item").forEach((item) => {
      item.addEventListener("click", (e) => {
        e.stopPropagation();
        const mode = item.dataset.mode;
        const ascending = item.dataset.asc === "true";
        listSortStates.users.mode = mode;
        listSortStates.users.ascending = ascending;
        document.removeEventListener("click", closeUsersDropdown);
        // UI neu aufbauen ohne activeSubUI zu √§ndern
        const oldDiv = blockedUsersDiv;
        if (oldDiv && oldDiv.parentNode) {
          oldDiv.parentNode.removeChild(oldDiv);
        }
        createBlockedUsersUI();
      });
      // Hover-Effekt
      item.addEventListener("mouseenter", () => {
        item.style.background = colors.itemBg;
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "none";
      });
    });
  }

  // Suchfunktionalit√§t
  const searchInput = document.getElementById("userSearch");
  searchInput.addEventListener("input", (e) => {
    const searchTerm = e.target.value.toLowerCase();
    let visibleCount = 0;
    const totalCount = blockedUsers.length;

    document.querySelectorAll(".user-item").forEach((item) => {
      const userName = item.querySelector("span").textContent.toLowerCase();
      const isVisible = userName.includes(searchTerm);
      item.style.display = isVisible ? "flex" : "none";
      if (isVisible) visibleCount++;
    });

    // Update heading counter
    const heading = blockedUsersDiv.querySelector("h4");
    if (heading) {
      heading.textContent = searchTerm
        ? `Ausgeblendete Benutzer (${visibleCount}/${totalCount})`
        : `Ausgeblendete Benutzer (${totalCount})`;
    }
  });

  // Alle Benutzer entfernen Button
  document
    .getElementById("clearBlockedUsersButton")
    .addEventListener("click", () => {
      if (
        confirm("M√∂chten Sie wirklich alle Benutzer aus der Liste entfernen?")
      ) {
        GM_setValue("blockedUsers", {});
        userAddedAt = {};
        GM_setValue("userAddedAt", userAddedAt);
        document.getElementById("usersList").innerHTML = "";
        processArticles();

        // Immediately update counter in heading
        const heading = blockedUsersDiv.querySelector("h4");
        if (heading) {
          heading.textContent = "Ausgeblendete Benutzer (0)";
        }
      }
    });

  // Einzelne Benutzer entfernen
  document.querySelectorAll(".delete-user").forEach((button) => {
    button.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();

      const userToDelete = button.dataset.user;
      const userItem = button.closest(".user-item");
      const blockedUsers = GM_getValue("blockedUsers", {});

      // Delete user from object (userToDelete is already normalized)
      delete blockedUsers[userToDelete];
      GM_setValue("blockedUsers", blockedUsers);

      const normalized = (userToDelete || "").toLowerCase();
      if (normalized && userAddedAt[normalized]) {
        delete userAddedAt[normalized];
        GM_setValue("userAddedAt", userAddedAt);
      }

      // Update UI
      userItem.remove();
      processArticles(true); // forceRun=true um Early Exit zu √ºberspringen

      // Update counter in heading
      const heading = blockedUsersDiv.querySelector("h4");
      if (heading) {
        heading.textContent = `Ausgeblendete Benutzer (${Object.keys(blockedUsers).length})`;
      }
    });
  });

  // Touch-Handler f√ºr Timestamp-Anzeige auf mobilen Ger√§ten
  if (IS_TOUCH_DEVICE) {
    const userTexts = document.querySelectorAll(".user-text");

    userTexts.forEach((userText, index) => {
      userText.addEventListener("click", function (e) {
        e.stopPropagation();
        const tooltip = this.nextElementSibling;

        if (tooltip && tooltip.classList.contains("timestamp-tooltip")) {
          // Check visibility BEFORE hiding all tooltips
          const computedDisplay = window.getComputedStyle(tooltip).display;
          const isVisible = computedDisplay === "block";

          // Hide all tooltips
          document.querySelectorAll(".timestamp-tooltip").forEach((t) => {
            t.style.display = "none";
          });

          // Show this tooltip only if it wasn't visible before
          if (!isVisible) {
            const item = this.closest(".user-item");
            const itemRect = item.getBoundingClientRect();
            const tooltipHeight = 30;
            const spaceAbove = itemRect.top;
            const spaceBelow = window.innerHeight - itemRect.bottom;

            if (spaceAbove < tooltipHeight && spaceBelow > tooltipHeight) {
              tooltip.style.bottom = "auto";
              tooltip.style.top = "100%";
              tooltip.style.marginTop = "4px";
              tooltip.style.marginBottom = "0";
            } else {
              tooltip.style.top = "auto";
              tooltip.style.bottom = "100%";
              tooltip.style.marginBottom = "4px";
              tooltip.style.marginTop = "0";
            }
            tooltip.style.display = "block";
          }
        }
      });
    });
  }

  // Schlie√üen Button
  document
    .getElementById("closeBlockedUsersButton")
    .addEventListener("click", (e) => {
      e.stopPropagation();
      closeActiveSubUI();
    });
}

// === UI-Updates ===
// --- Listen & Status ---
// Liste der H√§ndler/W√∂rter aktualisieren
function updateActiveLists() {
  const colors = getThemeColors();

  if (activeSubUI === "merchant" && merchantListDiv) {
    const merchantList = document.getElementById("merchantList");
    if (merchantList) {
      const currentMerchants = loadExcludeMerchants();
      merchantList.innerHTML = currentMerchants
        .map(
          (merchant) => `
                <div class="merchant-item" style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 5px;
                    padding: 5px;
                    background: ${colors.itemBg};
                    color: ${colors.text};
                    border: 1px solid ${colors.border};
                    border-radius: 3px;">
                    <div style="display: flex; flex-direction: column;">
                        <span title="${(() => {
                          const key =
                            merchant?.id !== undefined && merchant?.id !== null
                              ? String(merchant.id)
                              : normalizeForSearch(merchant?.name || "");
                          let title;
                          if (key && merchantAddedAt[key]) {
                            const data = merchantAddedAt[key];
                            if (typeof data === "object") {
                              const prefix = data.isLegacy
                                ? "Hinzugef√ºgt vor dem"
                                : "Hinzugef√ºgt am";
                              title = `${prefix} ${data.timestamp}`;
                            } else {
                              title = `Hinzugef√ºgt vor dem ${data}`;
                            }
                          } else {
                            title = "Hinzugef√ºgt am Unbekannt";
                          }
                          return title;
                        })()}">${merchant.name}</span>
                        <span style="color: ${
                          colors.text
                        }; opacity: 0.7; font-size: 0.8em;">ID: ${
            merchant.id
          }</span>
                    </div>
                    <button class="delete-merchant" data-id="${
                      merchant.id
                    }" style="
                        background: none;
                        border: none;
                        cursor: pointer;
                        color: ${colors.text};">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `
        )
        .join("");

      // Event Listener neu hinzuf√ºgen
      document.querySelectorAll(".delete-merchant").forEach((button) => {
        button.addEventListener("click", function (e) {
          handleMerchantDelete(e);
        });
      });
    }
  } else if (activeSubUI === "words" && wordsListDiv) {
    const wordsList = document.getElementById("wordsList");
    if (wordsList) {
      const currentWords = loadExcludeWords();
      wordsList.innerHTML = currentWords
        .map(
          (word) => `
                <div class="word-item" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; padding: 5px; background: #f0f0f0; border-radius: 3px;">
                    <span style="word-break: break-word;" title="${(() => {
                      const key = normalizeForSearch(word);
                      let title;
                      if (wordAddedAt[key]) {
                        const data = wordAddedAt[key];
                        if (typeof data === "object") {
                          const prefix = data.isLegacy
                            ? "Hinzugef√ºgt vor dem"
                            : "Hinzugef√ºgt am";
                          title = `${prefix} ${data.timestamp}`;
                        } else {
                          title = `Hinzugef√ºgt vor dem ${data}`;
                        }
                      } else {
                        title = "Hinzugef√ºgt am Unbekannt";
                      }
                      return title;
                    })()}">${word}</span>
                    <button class="delete-word" data-word="${word}" style="background: none; border: none; cursor: pointer; color: #666;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `
        )
        .join("");

      // Event Listener neu hinzuf√ºgen
      document.querySelectorAll(".delete-word").forEach((button) => {
        button.addEventListener("click", handleWordDelete);
      });
    }
  }
}
function updateSuggestionList() {
  // Save scroll position if list exists
  const oldList = document.getElementById("wordSuggestionList");
  const scrollPosition = oldList?.scrollTop || 0;

  // Remove old list if exists
  if (oldList) oldList.remove();

  // Filter and check for words
  suggestedWords = suggestedWords.filter(
    (word) => !excludeWords.includes(word)
  );
  if (!suggestedWords.length) return;

  const inputField = document.getElementById("newWordInput");
  const inputRect = inputField.getBoundingClientRect();
  const colors = getThemeColors();

  // Create suggestion list with fixed positioning
  const wordSuggestionList = document.createElement("div");
  wordSuggestionList.id = "wordSuggestionList";
  wordSuggestionList.style.cssText = `
        position: fixed;
        top: ${inputRect.bottom}px;
        left: ${inputRect.left}px;
        width: ${inputRect.width}px;
        max-height: 200px;
        overflow-y: auto;
        background: ${colors.background};
        border: 1px solid ${colors.border};
        color: ${colors.text};
        border-radius: 3px;
        z-index: 1002;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        display: block;
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
    `;

  // Add touch event handlers for mobile scrolling
  if (IS_TOUCH_DEVICE) {
    let touchStartY = 0;
    let scrollStartY = 0;

    wordSuggestionList.addEventListener(
      "touchstart",
      (e) => {
        touchStartY = e.touches[0].pageY;
        scrollStartY = wordSuggestionList.scrollTop;
        // Verhindern dass der Touch-Event die Liste schlie√üt
        e.stopPropagation();
      },
      { passive: true }
    );

    wordSuggestionList.addEventListener(
      "touchmove",
      (e) => {
        const touchY = e.touches[0].pageY;
        const deltaY = touchStartY - touchY;
        wordSuggestionList.scrollTop = scrollStartY + deltaY;

        // Verhindern dass die Seite scrollt w√§hrend in der Liste gescrollt wird
        if (wordSuggestionList.scrollHeight > wordSuggestionList.clientHeight) {
          const isAtTop = wordSuggestionList.scrollTop === 0;
          const isAtBottom =
            wordSuggestionList.scrollTop + wordSuggestionList.clientHeight >=
            wordSuggestionList.scrollHeight;

          if ((isAtTop && deltaY < 0) || (isAtBottom && deltaY > 0)) {
            e.preventDefault();
          }
        }
      },
      { passive: false }
    );

    wordSuggestionList.addEventListener(
      "touchend",
      (e) => {
        e.stopPropagation();
      },
      { passive: true }
    );
  }

  wordSuggestionList.innerHTML = suggestedWords
    .map(
      (word) => `
            <div class="word-suggestion-item" style="padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; transition: background-color 0.2s;">
                ${word}
            </div>
        `
    )
    .join("");

  document.body.appendChild(wordSuggestionList);
  wordSuggestionList.scrollTop = scrollPosition;

  // Add event listeners for items
  wordSuggestionList
    .querySelectorAll(".word-suggestion-item")
    .forEach((item) => {
      item.addEventListener("mouseenter", () => {
        item.style.backgroundColor = colors.itemBg;
      });
      item.addEventListener("mouseleave", () => {
        item.style.backgroundColor = colors.background;
      });
      item.addEventListener("click", handleWordSelection);
    });

  // Update position on scroll/resize
  const updatePosition = () => {
    const newRect = inputField.getBoundingClientRect();
    wordSuggestionList.style.top = `${newRect.bottom}px`;
    wordSuggestionList.style.left = `${newRect.left}px`;
  };

  window.addEventListener("scroll", updatePosition, true);
  window.addEventListener("resize", updatePosition);

  // Clean up event listeners when list is removed
  const cleanupListeners = () => {
    window.removeEventListener("scroll", updatePosition, true);
    window.removeEventListener("resize", updatePosition);
  };
}

// === Event-Handler ===
// --- Click & Touch ---
// Klick-Handler au√üerhalb der UI
function setupClickOutsideHandler() {
  if (uiClickOutsideHandler) {
    document.removeEventListener("click", uiClickOutsideHandler);
  }

  uiClickOutsideHandler = (e) => {
    // Early exit for clicks on UI controls
    if (
      e.target.closest(".settings-button") ||
      e.target.closest("#showMerchantListButton") ||
      e.target.closest("#showWordsListButton")
    ) {
      return;
    }

    // Get current UI states
    const settingsOpen = settingsDiv?.parentNode;
    const merchantsOpen = merchantListDiv?.parentNode;
    const wordsOpen = wordsListDiv?.parentNode;
    const blockedUsersOpen = blockedUsersDiv?.parentNode;
    const whitelistOpen = window.whitelistDiv?.parentNode;

    // Check if click was outside all UIs
    const clickedOutside =
      (!settingsOpen || !settingsDiv.contains(e.target)) &&
      (!merchantsOpen || !merchantListDiv.contains(e.target)) &&
      (!wordsOpen || !wordsListDiv.contains(e.target)) &&
      (!blockedUsersOpen || !blockedUsersDiv.contains(e.target)) &&
      (!whitelistOpen || !window.whitelistDiv.contains(e.target));

    if (clickedOutside) {
      cleanup();

      // Explicit cleanup of UI elements
      if (settingsDiv?.parentNode) settingsDiv.remove();
      if (merchantListDiv?.parentNode) merchantListDiv.remove();
      if (wordsListDiv?.parentNode) wordsListDiv.remove();
      if (blockedUsersDiv?.parentNode) blockedUsersDiv.remove();
      if (window.whitelistDiv?.parentNode) window.whitelistDiv.remove();

      // Reset states
      isSettingsOpen = false;
      activeSubUI = null;

      // Remove handler
      document.removeEventListener("click", uiClickOutsideHandler);
      uiClickOutsideHandler = null;
    }
  };

  // Add with delay to prevent immediate trigger
  setTimeout(() => {
    document.addEventListener("click", uiClickOutsideHandler);
  }, 100);
}

function createSuggestionClickHandler() {
  // Remove old handler if exists
  if (suggestionClickHandler) {
    document.removeEventListener("click", suggestionClickHandler);
  }

  suggestionClickHandler = (e) => {
    const list = document.getElementById("wordSuggestionList");
    const input = document.getElementById("newWordInput");

    if (!list?.contains(e.target) && !input?.contains(e.target)) {
      list?.remove();
    }
  };

  document.addEventListener("click", suggestionClickHandler);
  return suggestionClickHandler;
}
function handleWordSelection(e) {
  e.preventDefault();
  e.stopPropagation();

  const wordSuggestionList = document.getElementById("wordSuggestionList");
  const scrollPosition = wordSuggestionList.scrollTop; // Save scroll position

  const word = e.target.textContent.trim();
  const newWordInput = document.getElementById("newWordInput");
  const currentValue = newWordInput.value.trim();

  newWordInput.value = currentValue ? `${currentValue} ${word}` : word;
  suggestedWords = suggestedWords.filter((w) => w !== word);

  updateSuggestionList();
  newWordInput.focus();

  // Restore scroll position after list update
  const updatedList = document.getElementById("wordSuggestionList");
  if (updatedList) {
    updatedList.scrollTop = scrollPosition;
  }
}
function setupScrollHandling() {
  let isScrollingUI = false;
  let lastActiveUI = null;
  let touchStartY = 0;

  // Hilfsfunktion zum Pr√ºfen ob ein Element scrollbar ist
  const isScrollable = (element) => {
    return element.scrollHeight > element.clientHeight;
  };

  // Hilfsfunktion zum Pr√ºfen ob ein Element am Anfang/Ende des Scrollbereichs ist
  const isAtScrollLimit = (element, delta) => {
    if (delta > 0) {
      return (
        element.scrollTop + element.clientHeight >= element.scrollHeight - 1
      );
    } else {
      return element.scrollTop <= 0;
    }
  };

  function handleScroll(e) {
    // Pr√ºfe ob der Mauszeiger √ºber einem UI-Element ist
    const isOverUI =
      e.target.closest(
        "#mdm-settings-popup, #merchantListDiv, #wordsListDiv, #wordSuggestionList"
      ) ||
      settingsDiv?.contains(e.target) ||
      merchantListDiv?.contains(e.target) ||
      wordsListDiv?.contains(e.target);

    if (isOverUI) {
      // Finde das scrollbare √ºbergeordnete Element
      const scrollableContainer = e.target.closest(
        "#mdm-settings-content, #merchantList, #wordsList, #wordSuggestionList"
      );

      if (scrollableContainer && isScrollable(scrollableContainer)) {
        // Nutze natives Browser-Scrolling (kein preventDefault)
        // Browser scrollt automatisch mit korrekter Geschwindigkeit

        // Nur wenn am Scroll-Limit, verhindere Seiten-Scroll
        const deltaY = e.deltaY || e.detail || -(e.wheelDelta || 0);
        if (isAtScrollLimit(scrollableContainer, deltaY)) {
          e.preventDefault();
          e.stopPropagation();
        }
        // Sonst: Lass natives Scrolling zu
      } else {
        // Nicht scrollbar: verhindere Seiten-Scroll
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }

  // Event-Listener f√ºr das Mausrad mit passiver Option auf false (damit preventDefault funktioniert)
  document.addEventListener("wheel", handleScroll, { passive: false });

  function handleTouchStart(e) {
    const touch = e.touches[0];
    touchStartY = touch.clientY;

    const uiElements = [
      settingsDiv,
      merchantListDiv,
      wordsListDiv,
      document.getElementById("wordSuggestionList"),
    ];

    isScrollingUI = uiElements.some((el) => {
      if (!el?.parentNode) return false;
      const rect = el.getBoundingClientRect();
      return (
        touch.clientX >= rect.left &&
        touch.clientX <= rect.right &&
        touch.clientY >= rect.top &&
        touch.clientY <= rect.bottom
      );
    });
  }

  function handleTouchMove(e) {
    if (!isScrollingUI) return;

    const scrollableElement = e.target.closest(
      "#mdm-settings-content, #merchantList, #wordsList"
    );

    if (scrollableElement && isScrollable(scrollableElement)) {
      // Erlaube natives Touch-Scrolling f√ºr scrollbare Elemente
      // Pr√ºfe ob am Anfang oder Ende des Scrollbereichs
      const touch = e.touches[0];
      const deltaY = touchStartY - touch.clientY;

      if (isAtScrollLimit(scrollableElement, deltaY)) {
        // Am Limit: Verhindere Seiten-Scroll
        e.preventDefault();
      }
      // Sonst: Lass natives Scrolling zu (kein preventDefault)
    } else {
      // Blockiere Scrollen au√üerhalb der Listen
      e.preventDefault();
    }
  }

  function handleMouseEnter() {
    isScrollingUI = true;
    lastActiveUI = this;
  }

  function handleMouseLeave() {
    isScrollingUI = false;
    lastActiveUI = null;
  }

  function setupUIElement(element) {
    if (!element?.parentNode) return;

    element.addEventListener("mouseenter", handleMouseEnter);
    element.addEventListener("mouseleave", handleMouseLeave);
  }

  function setupAllElements() {
    [
      settingsDiv,
      merchantListDiv,
      wordsListDiv,
      document.getElementById("wordSuggestionList"),
    ].forEach(setupUIElement);
  }

  // Initial Setup
  setupAllElements();

  // Event Listener
  if (IS_TOUCH_DEVICE) {
    document.addEventListener("touchstart", handleTouchStart, {
      passive: true,
    });
    document.addEventListener("touchmove", handleTouchMove, { passive: false });
  }

  observer.observe(document.body, {
    childList: true,
    subtree: true,
  });

  // Cleanup-Funktion
  return () => {
    if (IS_TOUCH_DEVICE) {
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchmove", handleTouchMove);
    }
    document.removeEventListener("wheel", handleScroll);
    [
      settingsDiv,
      merchantListDiv,
      wordsListDiv,
      document.getElementById("wordSuggestionList"),
    ].forEach((el) => {
      if (el?.parentNode) {
        el.removeEventListener("mouseenter", handleMouseEnter);
        el.removeEventListener("mouseleave", handleMouseLeave);
      }
    });
    observer.disconnect();
  };
}

// --- Delete-Operationen ---
function handleWordDelete(e) {
  e.preventDefault();
  e.stopPropagation();

  const deleteButton = e.target.closest(".delete-word");
  if (!deleteButton) return;

  const wordToDelete = deleteButton.dataset.word;
  const wordItem = deleteButton.closest(".word-item");

  // Update excludeWords array
  excludeWords = excludeWords.filter((word) => word !== wordToDelete);
  saveExcludeWords(excludeWords);

  const normalized = normalizeForSearch(wordToDelete);
  if (normalized && wordAddedAt[normalized]) {
    delete wordAddedAt[normalized];
    GM_setValue("wordAddedAt", wordAddedAt);
  }

  // Get search state and counts
  const searchInput = document.getElementById("wordSearch");
  const searchTerm = searchInput?.value.trim().toLowerCase();
  const totalItems = document.querySelectorAll(".word-item").length;

  // Calculate visible items for search
  let visibleCount = 0;
  if (searchTerm) {
    const visibleItems = Array.from(
      document.querySelectorAll(".word-item")
    ).filter((item) => {
      const itemWord = item.querySelector("span").textContent.toLowerCase();
      const isVisible =
        itemWord.includes(searchTerm) &&
        itemWord !== wordToDelete.toLowerCase();
      return isVisible;
    });
    visibleCount = visibleItems.length;
  }

  // Remove item and update UI
  wordItem.remove();
  processArticles();

  // Update counter in heading
  const heading = wordsListDiv.querySelector("h4");
  if (heading) {
    const newTotal = totalItems - 1;
    heading.textContent = searchTerm
      ? `Ausgeblendete W√∂rter (${visibleCount}/${newTotal})`
      : `Ausgeblendete W√∂rter (${newTotal})`;
  }
}
// H√§ndler-L√∂schung Handler
function handleMerchantDelete(e) {
  e.preventDefault();
  e.stopPropagation();

  const deleteButton = e.target.closest(".delete-merchant");
  if (!deleteButton) return;

  const idToDelete = deleteButton.dataset.id;
  const merchantItem = deleteButton.closest(".merchant-item");

  // Update merchants array
  const merchantsData = loadExcludeMerchants();
  const updatedMerchants = merchantsData.filter((m) => m.id !== idToDelete);
  saveExcludeMerchants(updatedMerchants);

  if (merchantAddedAt[idToDelete]) {
    delete merchantAddedAt[idToDelete];
    GM_setValue("merchantAddedAt", merchantAddedAt);
  }

  // Get search state and counts
  const searchInput = document.getElementById("merchantSearch");
  const searchTerm = searchInput?.value.trim().toLowerCase();
  const totalItems = document.querySelectorAll(".merchant-item").length;

  // Calculate visible items for search
  let visibleCount = 0;
  if (searchTerm) {
    const visibleItems = Array.from(
      document.querySelectorAll(".merchant-item")
    ).filter((item) => {
      const merchantName = item.querySelector("span").textContent.toLowerCase();
      const isVisible =
        merchantName.includes(searchTerm) &&
        item.querySelector(".delete-merchant").dataset.id !== idToDelete;
      return isVisible;
    });
    visibleCount = visibleItems.length;
  }

  // Remove item and update UI
  merchantItem.remove();
  processArticles();

  // Update counter in heading
  const heading = merchantListDiv.querySelector("h4");
  if (heading) {
    const newTotal = totalItems - 1;
    heading.textContent = searchTerm
      ? `Ausgeblendete H√§ndler (${visibleCount}/${newTotal})`
      : `Ausgeblendete H√§ndler (${newTotal})`;
  }
}

// === Layout & UI-Hilfen ===
// Sub-UI Position berechnen
function getSubUIPosition() {
  const settingsRect = settingsDiv?.getBoundingClientRect();

  if (!settingsRect) return "";

  if (IS_TOUCH_DEVICE) {
    return `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10002;
        `;
  } else {
    const gap = 10;
    const subUIWidth = 300; // Standard-Breite der Sub-UIs
    const viewportWidth = window.innerWidth;

    // Pr√ºfe ob rechts genug Platz ist
    let left = settingsRect.right + gap;
    if (left + subUIWidth > viewportWidth) {
      // Nicht genug Platz rechts ‚Üí √∂ffne links vom Settings-Fenster
      left = settingsRect.left - subUIWidth - gap;

      // Wenn auch links nicht genug Platz ‚Üí zentriere horizontal
      if (left < gap) {
        left = Math.max(gap, (viewportWidth - subUIWidth) / 2);
      }
    }

    // Top-Position - Mitte des Main-UI wird zur Mitte des Sub-UI
    const mainUIHeight = settingsRect.height;
    const mainUICenter = settingsRect.top + (mainUIHeight / 2);

    return `
            position: fixed;
            top: ${mainUICenter}px;
            left: ${left}px;
            transform: translateY(-50%);
            z-index: 10002;
        `;
  }
}

// Funktion zum Aktualisieren der Sub-UI Positionen
function updateSubUIPositions() {
  // Skip position updates on mobile
  if (IS_TOUCH_DEVICE) return;

  // Settings-UI Position ermitteln
  const settingsDiv =
    document.getElementById("mdm-settings-popup") ||
    document.querySelector('[id^="mdm-settings"]');
  if (!settingsDiv) return;

  const settingsRect = settingsDiv.getBoundingClientRect();
  const gap = 10;

  // Berechne Mitte des Main-UI
  const mainUIHeight = settingsRect.height;
  const mainUICenter = settingsRect.top + (mainUIHeight / 2);

  // Left-Position berechnen
  const subUIWidth = 300;
  const viewportWidth = window.innerWidth;
  let left = settingsRect.right + gap;
  if (left + subUIWidth > viewportWidth) {
    left = settingsRect.left - subUIWidth - gap;
    if (left < gap) {
      left = Math.max(gap, (viewportWidth - subUIWidth) / 2);
    }
  }

  const subUIs = [
    document.getElementById("wordsListDiv"),
    document.getElementById("merchantListDiv"),
  ];

  // Aktualisiere Position f√ºr jedes vorhandene Sub-UI
  subUIs.forEach((ui) => {
    if (ui?.parentNode) {
      ui.style.position = "fixed";
      ui.style.top = `${mainUICenter}px`;
      ui.style.left = `${left}px`;
      ui.style.transform = "translateY(-50%)";
      ui.style.zIndex = "10002";
    }
  });

  // Whitelist-UI Position aktualisieren
  if (window.whitelistDiv?.parentNode) {
    window.whitelistDiv.style.position = "fixed";
    window.whitelistDiv.style.top = `${mainUICenter}px`;
    window.whitelistDiv.style.left = `${left}px`;
    window.whitelistDiv.style.transform = "translateY(-50%)";
    window.whitelistDiv.style.zIndex = "10002";
  }

  // Blockierte Benutzer UI Position aktualisieren
  if (blockedUsersDiv?.parentNode) {
    blockedUsersDiv.style.position = "fixed";
    blockedUsersDiv.style.top = `${mainUICenter}px`;
    blockedUsersDiv.style.left = `${left}px`;
    blockedUsersDiv.style.transform = "translateY(-50%)";
    blockedUsersDiv.style.zIndex = "10002";
  }
}

// H√§ndler zur Liste hinzuf√ºgen
function addMerchantToList(merchant, merchantList) {
  const div = document.createElement("div");
  div.className = "merchant-item";
  div.style.cssText =
    "display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; padding: 5px; background: #f0f0f0; border-radius: 3px;";
  div.innerHTML = `
        <span style="font-weight: bold;">${merchant.name}</span>
        <button class="delete-merchant" data-id="${merchant.id}" style="background: none; border: none; cursor: pointer; color: #666;">
            <i class="fas fa-times"></i>
        </button>
    `;

  // Insert at beginning of list
  merchantList.insertBefore(div, merchantList.firstChild);
}

// Helper function to manage Sub-UI states
function switchSubUI(newUI) {
  // If trying to open the same UI that's already active, close it
  if (activeSubUI === newUI) {
    closeActiveSubUI();
    return false;
  }

  // Close any active Sub-UI first
  if (activeSubUI) {
    closeActiveSubUI();
  }

  // Set new active UI
  activeSubUI = newUI;

  // Update button texts
  const merchantButton = document.getElementById("showMerchantListButton");
  const wordsButton = document.getElementById("showWordsListButton");
  const whitelistButton = document.getElementById("showWhitelistButton");
  const usersButton = document.getElementById("showBlockedUsersButton");

  if (merchantButton) {
    merchantButton.innerHTML =
      activeSubUI === "merchant"
        ? '<i class="fas fa-times"></i> H√§ndlerfilter schlie√üen'
        : '<i class="fas fa-store"></i> H√§ndlerfilter verwalten';
  }

  if (wordsButton) {
    wordsButton.innerHTML =
      activeSubUI === "words"
        ? '<i class="fas fa-times"></i> Wortfilter schlie√üen'
        : '<i class="fas fa-list"></i> Wortfilter verwalten';
  }

  if (whitelistButton) {
    whitelistButton.innerHTML =
      activeSubUI === "whitelist"
        ? '<i class="fas fa-times"></i> Whitelist schlie√üen'
        : '<i class="fas fa-shield-alt"></i> Whitelist verwalten';
  }

  if (usersButton) {
    usersButton.innerHTML =
      activeSubUI === "users"
        ? '<i class="fas fa-times"></i> Benutzerfilter schlie√üen'
        : '<i class="fas fa-user-slash"></i> Benutzerfilter verwalten';
  }

  return true;
}

function closeActiveSubUI() {
  if (activeSubUI === "merchant") {
    merchantListDiv?.remove();
  } else if (activeSubUI === "words") {
    wordsListDiv?.remove();
  } else if (activeSubUI === "whitelist") {
    window.whitelistDiv?.remove();
  } else if (activeSubUI === "users") {
    blockedUsersDiv?.remove();
  }

  // Reset button texts
  const merchantButton = document.getElementById("showMerchantListButton");
  const wordsButton = document.getElementById("showWordsListButton");
  const whitelistButton = document.getElementById("showWhitelistButton");
  const usersButton = document.getElementById("showBlockedUsersButton");

  if (merchantButton) {
    merchantButton.innerHTML =
      '<i class="fas fa-store"></i> H√§ndlerfilter verwalten';
    merchantButton.removeAttribute("data-processing");
  }

  if (wordsButton) {
    wordsButton.innerHTML = '<i class="fas fa-list"></i> Wortfilter verwalten';
  }

  if (whitelistButton) {
    whitelistButton.innerHTML =
      '<i class="fas fa-shield-alt"></i> Whitelist verwalten';
  }

  if (usersButton) {
    usersButton.innerHTML =
      '<i class="fas fa-user-slash"></i> Benutzerfilter verwalten';
  }

  activeSubUI = null;
}

//#endregion

//#region --- 5. Deal-Verarbeitung ---
// ===== Hauptfunktionen =====

// Cache f√ºr bereits verarbeitete Deals mit maximaler Gr√∂√üe
const MAX_CACHE_SIZE = 500; // Max 500 Deals im Cache
const processedDealsCache = new Map();

// Hash √ºber Filter-Inhalte f√ºr Cache-Invalidierung
let excludeWordsHash = 0;
let blockedUsersHash = 0; // Tracking f√ºr blockedUsers-√Ñnderungen

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

// Timeout-Tracking f√ºr Vue3 Re-Checks (verhindert mehrfache Timeouts pro Deal)
const vue3RecheckScheduled = new Set();
const vue3RecheckTimeouts = new Map(); // Speichert Timeout-IDs zum Abbrechen

// DEBUG: Cache global verf√ºgbar machen (nur f√ºr Debugging)
if (typeof unsafeWindow !== "undefined") {
  unsafeWindow.processedDealsCache = processedDealsCache;
} else {
  window.processedDealsCache = processedDealsCache;
}

function addToDealCache(key, value) {
  // Wenn Cache zu gro√ü, √§ltesten Eintrag entfernen
  if (processedDealsCache.size >= MAX_CACHE_SIZE) {
    const firstKey = processedDealsCache.keys().next().value;
    processedDealsCache.delete(firstKey);

    if (DEBUG.performance.caching) {
      console.log(`[${getDebugTimestamp()}] [MDM Cache] Eviction:`, {
        evictedKey: firstKey,
        reason: "MAX_CACHE_SIZE reached",
        cacheSize: processedDealsCache.size,
      });
      perfTracker.log("caching", "eviction", {
        evictedKey: firstKey,
        reason: "MAX_CACHE_SIZE reached",
        cacheSize: processedDealsCache.size,
      });
    }
  }
  processedDealsCache.set(key, value);
  perfTracker.update("caching.size", processedDealsCache.size);
}

// Artikel verarbeiten und filtern
function processArticles(forceRun = false) {
  // Pr√ºfe ob sich Filter ge√§ndert haben (wichtig f√ºr Early Exit)
  let blockedUsersObj = GM_getValue("blockedUsers", {});
  const currentBlockedUsersHash = simpleHash(Object.keys(blockedUsersObj).sort().join('|'));
  const blockedUsersChanged = currentBlockedUsersHash !== blockedUsersHash;

  // Pr√ºfe ob sich Wortfilter ge√§ndert haben
  const currentExcludeWordsHash = simpleHash(excludeWords.join('|'));
  const excludeWordsChanged = currentExcludeWordsHash !== excludeWordsHash;

  const filtersChanged = blockedUsersChanged || excludeWordsChanged;

  if (filtersChanged) {
    // Filter haben sich ge√§ndert - Cache leeren und Hash aktualisieren
    if (blockedUsersChanged) {
      blockedUsersHash = currentBlockedUsersHash;
    }
    if (excludeWordsChanged) {
      excludeWordsHash = currentExcludeWordsHash;
    }
    processedDealsCache.clear();
    if (DEBUG.wordFilter) {
      console.log('[MDM WordFilter] üîÑ Filter changed, cache cleared:', {
        blockedUsersChanged,
        excludeWordsChanged,
        newBlockedUsersHash: blockedUsersHash,
        newExcludeWordsHash: excludeWordsHash
      });
    }
  }

  // EARLY EXIT: Redundante Batches vermeiden (nur wenn Optimierungen aktiv)
  // Pr√ºfung VOR dem Abruf der deals, um DOM-Query zu sparen
  const now = Date.now();
  const currentDealsInDOM = document.querySelectorAll(
    "article.thread--deal, article.thread--voucher"
  ).length;

  if (
    !forceRun && // ‚ö° forceRun √ºberspringt Early Exit (z.B. nach User-Block)
    !DEBUG.disableOptimizations && // üîç Optimierungen k√∂nnen deaktiviert werden
    currentDealsInDOM === lastProcessArticlesDealCount && // Keine neuen Deals geladen
    !merchantLinksChangedSinceLastBatch && // Keine Merchant-Links-√Ñnderungen
    !filtersChanged // Keine Filter-√Ñnderungen (Wortfilter, User-Blocklist)
  ) {
    // Early Exit: Nur verarbeiten wenn sich etwas RELEVANT √§ndert
    // Zeitstempel-Updates ("L√§uft ab in...") sind irrelevant ‚Üí Skip
    // Zeit spielt KEINE Rolle - nur dealCount und merchantLinks z√§hlen
    if (DEBUG.delayDebug || DEBUG.wordFilter) {
      console.log(
        `[${getDebugTimestamp()}] ‚ö†Ô∏è [EARLY EXIT] Batch SKIPPED:`,
        {
          forceRun,
          dealCount: currentDealsInDOM,
          lastDealCount: lastProcessArticlesDealCount,
          merchantLinksChanged: merchantLinksChangedSinceLastBatch,
          filtersChanged,
          timeSinceLastBatch: `${Math.round((now-lastProcessArticlesTime)/1000)}s`,
          reason: 'No relevant changes (dealCount + merchantLinks + filters unchanged)'
        }
      );
    }
    return; // Sofort abbrechen - keine DOM-Traversal, keine Filter
  }

  // Log wenn wir NICHT skippen
  if (DEBUG.wordFilter) {
    console.log(
      `[${getDebugTimestamp()}] ‚úÖ [PROCESSING] Batch EXECUTING:`,
      {
        forceRun,
        dealCount: currentDealsInDOM,
        dealCountChanged: currentDealsInDOM !== lastProcessArticlesDealCount,
        merchantLinksChanged: merchantLinksChangedSinceLastBatch,
        filtersChanged,
        timeSinceLastBatch: `${Math.round((now-lastProcessArticlesTime)/1000)}s`
      }
    );
  }

  // Reset f√ºr diesen Run
  merchantLinksChangedSinceLastBatch = false;
  lastProcessArticlesTime = now;
  lastProcessArticlesDealCount = currentDealsInDOM;

  if (DEBUG.delayDebug) {
    console.log(
      `[${getDebugTimestamp()}] ‚úÖ [DELAY DEBUG] Batch EXECUTING:`,
      {
        dealCount: currentDealsInDOM,
        timeSinceLastBatch: `${Math.round((now-lastProcessArticlesTime)/1000)}s`
      }
    );
  }

  if (DEBUG.priceFilter) {
    console.log(`[${getDebugTimestamp()}] [MDM PriceFilter] üîÑ processArticles() called, maxPrice=`, maxPrice);
  }

  perfTracker.start("processArticles");
  perfTracker.update("processArticles.calls", 1);
  perfTracker.resetBatch();

  // Batch-Tracking f√ºr Vue3-Defers und Performance-Messung
  let vue3DeferredCount = 0;
  const batchStartTime = performance.now();
  let firstTitleUpdateTime = null;

  // Tracking f√ºr Delayed Re-Check Optimierung
  let dealsWithoutMerchantId = 0;

  // MerchantFilter Batch-Tracking
  let merchantFilterCheckedCount = 0;
  let merchantFilterHiddenCount = 0;
  const merchantFilterPerDealDebug = false; // Lokale Variable f√ºr sehr detaillierte Logs

  // Observer tempor√§r deaktivieren um DOM-Mutations-Loops zu vermeiden
  if (typeof combinedObserver !== 'undefined' && combinedObserver) {
    combinedObserver.disconnect();
  }

  // Log nur beim ersten Aufruf pro Batch (nicht bei jedem Observer-Callback)
  if (DEBUG.hideMatchingMerchantNames && perfTracker.metrics.processArticles.calls === 1) {
    console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] processArticles batch started - Feature state:`, {
      enabled: window.hideMatchingMerchantNames,
      debugEnabled: DEBUG.hideMatchingMerchantNames
    });
  }

  // Lade blockierte Benutzer f√ºr die Filterung (Object-Format)
  blockedUsersObj = GM_getValue("blockedUsers", {});
  const blockedUsers = Object.keys(blockedUsersObj); // Nur normalized keys

  if (DEBUG.userBlocking) {
    console.log('[MDM UserBlock] [processArticles] Loaded blocked users:', {
      blockedUsersObj,
      blockedUsers,
      count: blockedUsers.length
    });

    console.log(
      '[MDM UserBlock] Processing articles, blocked users:',
      blockedUsers
    );
  }

  const deals = document.querySelectorAll(
    "article.thread--deal, article.thread--voucher"
  );

  if (DEBUG.performance.processing) {
    perfTracker.log("processing", "start", { dealCount: deals.length });
  }

  perfTracker.update("processArticles.articlesProcessed", deals.length);

  // Cache-Gr√∂√üe begrenzen wenn zu viele Eintr√§ge
  if (processedDealsCache.size > MAX_CACHE_SIZE * 1.5) {
    processedDealsCache.clear();
    if (DEBUG.performance.caching) {
      console.log(`[${getDebugTimestamp()}] [MDM Cache] Full clear:`, {
        reason: "Cache exceeded 1.5x MAX_SIZE",
        previousSize: processedDealsCache.size
      });
      perfTracker.log("caching", "full-clear", {
        reason: "Cache exceeded 1.5x MAX_SIZE",
      });
    }
  }

  // Cache status logging entfernt - nur bei DEBUG.performance.caching n√∂tig

  // Batch DOM-Updates f√ºr bessere Performance
  const dealsToHide = [];
  const dealsToShow = [];

  deals.forEach((deal) => {
    const dealId = deal.getAttribute("id") || "";
    const isCurrentlyHidden = deal.classList.contains("mydealz-manager-hidden");

    if (DEBUG.priceFilter) {
      console.log(`[MDM] üîç Processing deal:`, {
        dealId,
        isHidden: isCurrentlyHidden,
        dataHidden: deal.getAttribute("data-hidden-by-mydealz-manager")
      });
    }

    // Pr√ºfe ob Deal manuell versteckt wurde (hat Vorrang)
    if (hiddenDeals.includes(dealId)) {
      if (!isCurrentlyHidden) {
        dealsToHide.push({ deal, reason: "manually-hidden" });
      }
      return;
    }

    // Pr√ºfe ob Deal von blockiertem Benutzer
    if (blockedUsers.length > 0) {
      // blockedUsers enth√§lt bereits normalized keys (lowercase)

      if (DEBUG.userBlocking) {
        console.log("[MDM UserBlock] [processArticles] Checking deal:", {
          dealId,
          blockedUsersCount: blockedUsers.length,
          blockedUsersList: blockedUsers
        });
      }

      let username = null;

      // Methode 0: data-vue3 JSON (funktioniert auch vor Vue-Rendering)
      const vueDiv = deal.querySelector('.js-vue3[data-vue3]');
      if (vueDiv) {
        try {
          const vueDataAttr = vueDiv.getAttribute('data-vue3');
          if (vueDataAttr) {
            // HTML-Entities dekodieren
            const decodedJson = vueDataAttr
              .replace(/&quot;/g, '"')
              .replace(/&amp;/g, '&')
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>');
            const vueData = JSON.parse(decodedJson);

            // Username aus dem JSON extrahieren (Pfad: thread.user.username)
            const threadData = vueData?.props?.thread;
            if (threadData?.user?.username) {
              username = threadData.user.username;
              if (DEBUG.userBlocking) {
                console.log("[MDM UserBlock] [processArticles] Method 0 (data-vue3 JSON):", {
                  dealId,
                  username,
                  found: true,
                  source: "thread.user.username"
                });
              }
            }
          }
        } catch (e) {
          if (DEBUG.userBlocking) {
            console.log("[MDM UserBlock] [processArticles] Method 0 (data-vue3 JSON) - Parse failed:", {
              dealId,
              error: e.message
            });
          }
        }
      }

      // Methode 1: data-md-author Attribut (nur nach Vue-Rendering verf√ºgbar)
      if (!username) {
        username = deal.getAttribute("data-md-author");
        if (username) {
          if (DEBUG.userBlocking) {
            console.log("[MDM UserBlock] [processArticles] Method 1 (data-md-author):", {
              dealId,
              username,
              found: true
            });
          }
        }
      }

      // Methode 2: User-Link
      if (!username) {
        const userLink = deal.querySelector('a[data-t="userLink"]');
        if (userLink) {
          username = userLink.textContent.trim();
          if (DEBUG.userBlocking) {
            console.log("[MDM UserBlock] [processArticles] Method 2 (userLink):", {
              dealId,
              username,
              found: true
            });
          }
        }
      }

      // Methode 3: Span-Text "Ver√∂ffentlicht von"
      if (!username) {
        const userSpan = deal.querySelector(
          ".overflow--ellipsis.size--all-xs.size--fromW3-s"
        );
        if (userSpan) {
          const match = userSpan.textContent.match(
            /Ver√∂ffentlicht von\s+(\S+)/i
          );
          if (match && match[1]) {
            username = match[1];
            if (DEBUG.userBlocking) {
              console.log("[MDM UserBlock] [processArticles] Method 3 (span text):", {
                dealId,
                username,
                found: true
              });
            }
          }
        }
      }

      if (username) {
        const normalizedUsername = username.toLowerCase();
        if (DEBUG.userBlocking) {
          console.log("[MDM UserBlock] [processArticles] Username comparison:", {
            dealId,
            username,
            normalizedUsername,
            blockedUsers,
            isBlocked: blockedUsers.includes(normalizedUsername)
          });
        }

        if (blockedUsers.includes(normalizedUsername)) {
          console.log("[MDM UserBlock] [processArticles] ‚úÖ HIDING deal from blocked user:", {
            dealId,
            username: normalizedUsername,
          });
          dealsToHide.push({ deal, reason: `blocked-user:${normalizedUsername}` });
          return;
        } else {
          if (DEBUG.userBlocking) {
            console.log("[MDM UserBlock] [processArticles] ‚ùå NOT hiding deal, user not in blocklist:", {
              dealId,
              normalizedUsername,
              blockedUsers
            });
          }
          // User ist NICHT geblockt - wenn Deal wegen THIS USER versteckt wurde, wieder anzeigen
          if (isCurrentlyHidden) {
            const hideReason = deal.getAttribute("data-hide-reason") || "";
            // NUR anzeigen wenn Deal wegen DIESEM User versteckt wurde, NICHT bei anderen Gr√ºnden
            if (hideReason === `blocked-user:${normalizedUsername}`) {
              dealsToShow.push({ deal, reason: "user-unblocked" });
              return;
            }
          }
        }
      } else {
        console.log("[MDM UserBlock] [processArticles] ‚ö†Ô∏è NO username found for deal:", dealId);
      }
    } else {
      if (DEBUG.userBlocking) {
        console.log("[MDM UserBlock] [processArticles] ‚ö†Ô∏è blockedUsers list is EMPTY");
      }
      // Keine blockierten User - wenn Deal wegen "blocked-user" versteckt war, wieder anzeigen
      if (isCurrentlyHidden && deal.getAttribute("data-hidden-by-mydealz-manager") === "true") {
        const hideReason = deal.getAttribute("data-hide-reason") || "";
        // NUR anzeigen wenn Deal wegen blockiertem User versteckt wurde, NICHT bei anderen Gr√ºnden (word-filter etc.)
        if (hideReason.startsWith("blocked-user:")) {
          dealsToShow.push({ deal, reason: "no-blocked-users" });
          return;
        }
      }
    }

    // Cold Deals Pr√ºfung ZUERST (muss hier sein wegen DOM-Timing)
    if (hideColdDeals) {
      const tempElement =
        deal.querySelector(".cept-vote-temp .overflow--wrap-off") ||
        deal.querySelector(".vote-temp .overflow--wrap-off");
      if (tempElement) {
        const temperatureText = tempElement.textContent.trim();
        const temperatureMatch = temperatureText.match(/([-+]?\d+)¬∞/);
        const temperature = temperatureMatch
          ? parseInt(temperatureMatch[1])
          : null;

        if (temperature !== null && temperature < 0) {
          dealsToHide.push({ deal, reason: `cold-deal:${temperature}¬∞` });
          return;
        }
      }
    }

    // H√§ndler-Pr√ºfung ZUERST (muss hier sein wegen DOM-Timing)
    if (
      excludeMerchantsCache.ids.size ||
      excludeMerchantsCache.normalizedNames.size
    ) {
      const merchantInfo = getArticleMerchantInfo(deal);
      const { merchantId, merchantName } = merchantInfo;

      merchantFilterCheckedCount++;

      if (DEBUG.merchantFilter && merchantFilterPerDealDebug) {
        console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] Checking deal:`, {
          dealId,
          merchantId,
          merchantName,
          normalizedMerchantName: merchantName ? normalizeForSearch(merchantName) : "",
          filteredMerchantIDs: Array.from(excludeMerchantsCache.ids),
          filteredMerchantNames: Array.from(excludeMerchantsCache.normalizedNames)
        });
      }

      if (merchantId && excludeMerchantsCache.ids.has(String(merchantId))) {
        merchantFilterHiddenCount++;
        if (DEBUG.merchantFilter) {
          console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] ‚õî Hiding deal due to merchant match:`, {
            dealId,
            merchantId,
            merchantName,
            matchType: "id",
            matchValue: merchantId
          });
        }
        dealsToHide.push({ deal, reason: `merchant-id:${merchantId}` });
        return;
      }

      const normalizedMerchantName = merchantName
        ? normalizeForSearch(merchantName)
        : "";
      if (
        normalizedMerchantName &&
        excludeMerchantsCache.normalizedNames.has(normalizedMerchantName)
      ) {
        merchantFilterHiddenCount++;
        if (DEBUG.merchantFilter) {
          console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] ‚õî Hiding deal due to merchant match:`, {
            dealId,
            merchantId,
            merchantName,
            matchType: "name",
            matchValue: normalizedMerchantName
          });
        }
        dealsToHide.push({ deal, reason: `merchant-name:${merchantName}` });
        return;
      }

      // Tracking: Deal ohne merchantId z√§hlen (f√ºr Delayed Re-Check Optimierung)
      if (!merchantId) {
        dealsWithoutMerchantId++;
      }
    }

    // WICHTIG: Vue3-Check ZUERST! Verhindert, dass Titel-√Ñnderungen von Vue √ºberschrieben werden
    // Vue rendert Deals asynchron - wir m√ºssen warten, bis der Render-Prozess abgeschlossen ist
    const vue3Container = deal.querySelector('.js-vue3[data-handler="vue3"]');
    if (vue3Container && vue3Container.children.length === 0) {
      // Vue3 hat noch nicht gerendert - wir m√ºssen warten!
      vue3DeferredCount++; // Batch-Counter erh√∂hen statt einzeln zu loggen

      // Detailliertes per-Deal-Log nur unter DEBUG.performance.observer
      if (DEBUG.performance.observer) {
        console.log(`[${getDebugTimestamp()}] [MDM] ‚è≥ Vue3 container empty (deal ${vue3DeferredCount}):`, dealId);
      }

      // Timeout setzen f√ºr Re-Check nach 500ms
      if (!vue3RecheckScheduled.has(dealId)) {
        vue3RecheckScheduled.add(dealId);
        const timeoutId = setTimeout(() => {
          vue3RecheckScheduled.delete(dealId);
          vue3RecheckTimeouts.delete(dealId);
          // Re-processing-Log nur unter DEBUG.performance.observer
          if (DEBUG.performance.observer) {
            console.log(`[${getDebugTimestamp()}] [MDM] üîÑ Re-processing after Vue3 render:`, dealId);
          }
          processArticles();
        }, 500);
        vue3RecheckTimeouts.set(dealId, timeoutId);
      }

      // Deal NICHT verarbeiten - beim n√§chsten Durchlauf (wenn Vue fertig) neu pr√ºfen
      dealsToShow.push({ deal, reason: "vue3-not-rendered-yet" });
      return;
    }

    // Vue3 ist fertig - Timeout abbrechen falls vorhanden
    if (vue3RecheckScheduled.has(dealId)) {
      const timeoutId = vue3RecheckTimeouts.get(dealId);
      if (timeoutId) {
        clearTimeout(timeoutId);
        // Timeout-Cancel-Log nur unter DEBUG.performance.observer
        if (DEBUG.performance.observer) {
          console.log(`[${getDebugTimestamp()}] [MDM] ‚èπÔ∏è Vue3 ready, cancelled timeout:`, dealId);
        }
      }
      vue3RecheckScheduled.delete(dealId);
      vue3RecheckTimeouts.delete(dealId);
    }

    // WICHTIG: H√§ndlernamen-Feature MUSS VOR Wortfilter laufen!
    // Grund: Der Wortfilter soll die GE√ÑNDERTEN Titel sehen, nicht die Originale
    let titleWasChanged = false;

    if (window.hideMatchingMerchantNames && !ORIGINAL_TITLES.has(dealId)) {
      // WICHTIG: Speichere Originaltitel auch f√ºr Deals OHNE Merchant-Info
      // Dies ist essentiell, damit der Wortfilter konsistent auf Originaltitel arbeiten kann
      const titleLink = deal.querySelector(".thread-title a");
      if (titleLink && !ORIGINAL_TITLES.has(dealId)) {
        ORIGINAL_TITLES.set(dealId, titleLink.textContent);
      }

      // Priorit√§t 1: Suche merchantLink mit ID im GESAMTEN Deal
      const merchantLink = deal.querySelector('a[data-t="merchantLink"]');

      // Priorit√§t 2: Fallback f√ºr H√§ndler ohne ID - Suche im "Verf√ºgbar bei" Span
      let fallbackMerchantSpan = null;
      if (!merchantLink) {
        // Suche nach "Verf√ºgbar bei <span>h√§ndlername</span>" Struktur
        const merchantInfoSpans = deal.querySelectorAll('.color--text-TranslucentSecondary.size--all-xs span');
        for (const span of merchantInfoSpans) {
          const text = span.textContent?.trim();
          // Pr√ºfe ob es ein H√§ndlername sein k√∂nnte (z.B. "deblock.com")
          if (text && (text.includes('.') || text.length > 3)) {
            fallbackMerchantSpan = span;
            break;
          }
        }
      }

      // Debug: Alle Links und Merchant-Infos analysieren
      if (DEBUG.hideMatchingMerchantNames && (merchantLink || fallbackMerchantSpan)) {
        const titleLink = deal.querySelector(".thread-title a");
        const allLinksInDeal = deal.querySelectorAll('a');
        const allDataTLinks = deal.querySelectorAll('a[data-t]');
        const merchantLinks = deal.querySelectorAll('a[data-t="merchantLink"]');

        console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Deal analysis:`, {
          dealId,
          hasLink: !!merchantLink,
          merchantName: merchantLink?.textContent?.trim() || "none",
          hasFallbackSpan: !!fallbackMerchantSpan,
          fallbackMerchantName: fallbackMerchantSpan?.textContent?.trim() || "none",
          title: titleLink?.textContent,
          allLinksInDeal: allLinksInDeal.length,
          allDataTLinks: allDataTLinks.length,
          merchantLinksCount: merchantLinks.length,
          dataTAttributes: Array.from(allDataTLinks).map(l => l.getAttribute('data-t'))
        });
      }

      // Verarbeite Titel wenn H√§ndlerinfo verf√ºgbar ist
      if (merchantLink || fallbackMerchantSpan) {
        const titleElement = deal.querySelector(".thread-title");
        if (titleElement) {
          const merchantName = merchantLink
            ? merchantLink.textContent.trim()
            : fallbackMerchantSpan.textContent.trim();

          const titleLink = titleElement.querySelector("a");
          if (titleLink) {
            // Originaltitel wurde bereits oben gespeichert, hole ihn von dort
            const originalTitle = ORIGINAL_TITLES.get(dealId) || titleLink.textContent;
            const newTitle = removeMerchantNameFromTitle(originalTitle, merchantName);

            if (originalTitle !== newTitle) {
              titleLink.textContent = newTitle;
              titleLink.setAttribute("title", newTitle);
              titleWasChanged = true; // Flag setzen: Titel wurde ge√§ndert!

              // Timing: Erster Title-Update in diesem Batch
              if (firstTitleUpdateTime === null) {
                firstTitleUpdateTime = performance.now();
              }

              if (DEBUG.hideMatchingMerchantNames) {
                console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Title updated:`, {
                  dealId,
                  before: originalTitle,
                  after: newTitle,
                  titleWasChanged: true
                });
              }

              perfTracker.update("domUpdates.titleChanges", 1);
              perfTracker.currentBatch.domUpdates.titleChanges++;

              // WICHTIG: Cache-Key f√ºr diesen Deal invalidieren, damit Wortfilter neu evaluiert wird
              // Der Wortfilter wird dann in der Haupt-Loop (deals.forEach) mit dem Originaltitel arbeiten
              const cacheKey = `${dealId}_${excludeWordsHash}_${maxPrice}_${window.hideMatchingMerchantNames ? 1 : 0}`;
              if (processedDealsCache.has(cacheKey)) {
                processedDealsCache.delete(cacheKey);
                if (DEBUG.hideMatchingMerchantNames) {
                  console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Cache invalidiert f√ºr:`, dealId);
                }
              }
            } else if (DEBUG.hideMatchingMerchantNames) {
              console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] No title change needed:`, {
                dealId,
                title: originalTitle
              });
            }
          }
        } else if (DEBUG.criticalErrors) {
          console.warn('[MDM Critical] ‚ö† hideMatchingMerchantNames: Selector ".thread-title" returned no element for deal:', dealId);
        }
      }
    } else if (window.hideMatchingMerchantNames && ORIGINAL_TITLES.has(dealId)) {
      // Feature ist AN, aber Deal wurde bereits verarbeitet - SKIP (kein Log n√∂tig)
      // Der Titel wurde bereits beim ersten Durchlauf ge√§ndert
    } else if (!window.hideMatchingMerchantNames && ORIGINAL_TITLES.has(dealId)) {
      // Feature deaktiviert: Originaltitel wiederherstellen
      if (DEBUG.hideMatchingMerchantNames) {
        console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Feature is DISABLED, restoring original title for:`, dealId);
      }
      const titleLink = deal.querySelector(".thread-title a");
      if (titleLink) {
        const originalTitle = ORIGINAL_TITLES.get(dealId);
        titleLink.textContent = originalTitle;
        titleLink.setAttribute("title", originalTitle);
        if (DEBUG.hideMatchingMerchantNames) {
          console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] Restored original title:`, originalTitle);
        }
      }
    }

    // PREIS-FILTER: Immer ZUERST pr√ºfen, unabh√§ngig vom Cache!
    // Preise √§ndern sich nicht und sollten immer sofort gefiltert werden
    let priceCheckPassed = false; // Flag: Wurde Preis-Check durchgef√ºhrt?

    if (maxPrice > 0) {
      // Vue3 ist an dieser Stelle bereits fertig gerendert (Check wurde oben durchgef√ºhrt)
      const priceElement = deal.querySelector(".thread-price");

      if (!priceElement) {
        if (DEBUG.priceFilter) {
          console.warn(`[${getDebugTimestamp()}] [MDM PriceFilter] ‚ö†Ô∏è .thread-price missing:`, {
            dealId
          });
        }
        // Kein Preis gefunden - aber TROTZDEM Wortfilter anwenden!
        // NICHT sofort anzeigen - weitermachen mit Cache/shouldExcludeArticle
        priceCheckPassed = true; // Preis-Check √ºberspringen, aber Wortfilter anwenden
      } else {
        // Preis-Element gefunden - jetzt auswerten
        priceCheckPassed = true;
        const priceText = priceElement.textContent.trim();

        if (DEBUG.priceFilter) {
          console.log(`[${getDebugTimestamp()}] [MDM PriceFilter] üí∞ Checking price:`, {
            dealId,
            priceText,
            maxPrice
          });
        }

        // Preis extrahieren
        if (!priceText.includes("%") && !priceText.startsWith("-") && priceText.includes("‚Ç¨")) {
          const euroFormatMatch = priceText.match(/([\d.,]+)\s*‚Ç¨/);
          if (euroFormatMatch) {
            let extractedPrice = euroFormatMatch[1];
            extractedPrice = extractedPrice.replace(/\./g, "");
            extractedPrice = extractedPrice.replace(",", ".");
            const priceValue = parseFloat(extractedPrice);

            if (!isNaN(priceValue) && priceValue > maxPrice) {
              if (DEBUG.priceFilter) {
                console.log(`[${getDebugTimestamp()}] [MDM PriceFilter] üö´ HIDING - price exceeds:`, {
                  dealId,
                  price: priceValue,
                  maxPrice,
                  diff: priceValue - maxPrice
                });
              }
              dealsToHide.push({ deal, reason: "price-exceeded" });
              return;
            }
          }
        }
      }
    }

    // Cache-Pr√ºfung
    // WICHTIG: hideMatchingMerchantNames muss im Cache-Key sein, da es Titel √§ndert!
    // excludeWordsHash stellt sicher dass Cache invalidiert wird wenn Filter ge√§ndert werden (nicht nur Anzahl)
    const cacheKey = `${dealId}_${excludeWordsHash}_${maxPrice}_${window.hideMatchingMerchantNames ? 1 : 0}`;
    const cachedResult = processedDealsCache.get(cacheKey);

    if (DEBUG.priceFilter) {
      console.log("[MDM PriceFilter] üîë Cache check for deal:", {
        dealId,
        cacheKey,
        isInCache: cachedResult !== undefined,
        maxPrice,
        excludeWordsCount: excludeWords.length,
        excludeWordsHash
      });
    }

    if (cachedResult !== undefined) {
      // Cache HIT - verwende gecachtes Ergebnis
      perfTracker.update("caching.hits", 1);
      perfTracker.currentBatch.caching.hits++;
      perfTracker.currentBatch.caching.dealIds.hits.push(dealId);

      if (DEBUG.performance.caching && (cachedResult || titleWasChanged)) {
        // Nur loggen wenn Deal ausgeblendet wird ODER Titel ge√§ndert wurde
        const titleLink = deal.querySelector(".thread-title a");
        console.log(`[${getDebugTimestamp()}] [MDM Cache] Cache HIT:`, {
          url: window.location.href,
          dealId,
          cacheKey,
          result: cachedResult ? "EXCLUDED" : "SHOWN",
          currentTitle: titleLink?.textContent,
          titleWasChanged
        });
      }

      if (cachedResult) {
        dealsToHide.push({ deal, reason: "cached-word-filter" });
        return;
      } else {
        dealsToShow.push({ deal, reason: "cached-no-match" });
      }
    } else {
      // Cache MISS - neu evaluieren
      perfTracker.update("caching.misses", 1);
      perfTracker.currentBatch.caching.misses++;
      perfTracker.currentBatch.caching.dealIds.misses.push(dealId);

      if (DEBUG.priceFilter) {
        console.log("[MDM PriceFilter] üéØ Cache MISS - calling shouldExcludeArticle for deal:", dealId);
      }

      // Nur bei neuem Deal oder ge√§nderten Filtern evaluieren
      // WICHTIG: Erstelle normalisierten Titel f√ºr konsistente Filter-Anwendung
      // KRITISCH: Wenn hideMatchingMerchantNames aktiv ist, nutze ORIGINAL_TITLES!
      const titleLink = deal.querySelector(".thread-title a");
      let titleForFilter;

      if (window.hideMatchingMerchantNames && ORIGINAL_TITLES.has(dealId)) {
        // Nutze Originaltitel, damit H√§ndlernamen im Wortfilter erkannt werden
        titleForFilter = ORIGINAL_TITLES.get(dealId);
      } else {
        // Nutze sichtbaren Titel
        titleForFilter = titleLink?.textContent || "";
      }

      const normalizedTitleForFilter = normalizeForSearch(titleForFilter);

      const shouldExclude = shouldExcludeArticle(deal, normalizedTitleForFilter);

      if (DEBUG.performance.caching && shouldExclude) {
        // Nur loggen wenn Deal ausgeblendet wird
        console.log(`[${getDebugTimestamp()}] [MDM Cache] MISS ‚Üí EXCLUDED:`, {
          dealId,
          titleForFilter,
          usedOriginalTitle: window.hideMatchingMerchantNames && ORIGINAL_TITLES.has(dealId),
          visibleTitle: titleLink?.textContent,
          normalizedTitle: normalizedTitleForFilter,
          cacheKey
        });
      }

      addToDealCache(cacheKey, shouldExclude);

      if (shouldExclude) {
        dealsToHide.push({ deal, reason: "word-filter" });
        return;
      }

      dealsToShow.push({ deal, reason: "no-filter-match" });
    }
  });

  // Batch DOM-Updates: Alle auf einmal anwenden f√ºr bessere Performance
  dealsToHide.forEach((item) => {
    if (item.deal) {
      hideDeal(item.deal, item.reason);
    } else {
      hideDeal(item, "legacy");
    }
  });
  dealsToShow.forEach((item) => {
    if (item.deal) {
      showDeal(item.deal, item.reason);
    } else {
      showDeal(item, "legacy");
    }
  });

  // processSucheinstellungen() wird nur EINMAL in init() aufgerufen,
  // NICHT in jedem processArticles()-Durchlauf (verhindert Endlosschleife/Reloads)

  const duration = perfTracker.end("processArticles");
  perfTracker.update("processArticles.totalTime", duration);

  // Log aggregierte Batch-Daten
  perfTracker.logBatch();

  if (DEBUG.performance.processing) {
    perfTracker.log("processing", "completed", {
      duration: `${duration.toFixed(2)}ms`,
      articlesProcessed: deals.length,
      avgTimePerArticle:
        deals.length > 0 ? `${(duration / deals.length).toFixed(3)}ms` : "0ms",
      batchSize: { hidden: dealsToHide.length, shown: dealsToShow.length },
    });
  }

  // UI-Updates NACH DOM-√Ñnderungen aber VOR Observer-Reconnect
  addSettingsButton();
  addHideButtons();

  // Observer wieder aktivieren
  if (typeof combinedObserver !== 'undefined' && combinedObserver) {
    observeDealMutations(combinedObserver);
  }

  // MerchantFilter Batch-Zusammenfassung
  if (DEBUG.merchantFilter && merchantFilterCheckedCount > 0) {
    console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] ‚úÖ Batch done ‚Äì checked ${merchantFilterCheckedCount} deals, hidden ${merchantFilterHiddenCount}`);
  }

  // DELAYED RE-CHECK f√ºr Merchant-Filter
  // Problem: Bei Tab-Wechsel/Reload laden merchantIds asynchron NACH processArticles
  // L√∂sung: Nach 2 Sekunden erneut pr√ºfen ob Deals mit merchantId jetzt versteckt werden m√ºssen
  // Optimierung: Nur planen wenn tats√§chlich Deals ohne merchantId existieren
  const currentDealCount = deals.length;
  const timeSinceLastRecheck = Date.now() - lastSuccessfulMerchantRecheck;

  if (
    dealsWithoutMerchantId > 0 &&
    (excludeMerchantsCache.ids.size > 0 || excludeMerchantsCache.normalizedNames.size > 0) &&
    !delayedMerchantRecheckScheduled &&
    // Intelligente Guards: Nur bei neuen Deals ODER nach Cooldown
    (
      currentDealCount > lastKnownDealCount || // Neue Deals im DOM
      timeSinceLastRecheck > 10000 // 10s Cooldown
    )
  ) {
    lastKnownDealCount = currentDealCount;
    delayedMerchantRecheckScheduled = true;

    setTimeout(() => {
      // Pr√ºfe alle sichtbaren Deals nochmal
      const visibleDeals = document.querySelectorAll(
        'article.thread--deal:not(.mydealz-manager-hidden), article.thread--voucher:not(.mydealz-manager-hidden)'
      );

      if (DEBUG.merchantFilter) {
        console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] üîé Delayed Re-Check start ‚Äì checking ${visibleDeals.length} deals`);
      }

      let recheckHiddenCount = 0;
      visibleDeals.forEach((deal) => {
        const dealId = deal.getAttribute("id") || "";
        const merchantInfo = getArticleMerchantInfo(deal);
        const { merchantId, merchantName } = merchantInfo;

        // Pr√ºfe ob dieser Deal jetzt eine merchantId hat und gefiltert werden soll
        if (merchantId && excludeMerchantsCache.ids.has(String(merchantId))) {
          if (DEBUG.merchantFilter) {
            console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] ‚õî Hiding deal due to merchant match (delayed):`, {
              dealId,
              merchantId,
              merchantName,
              matchType: "id",
              matchValue: merchantId
            });
          }
          hideDeal(deal, `delayed-merchant-id:${merchantId}`);
          recheckHiddenCount++;
        } else if (merchantName) {
          const normalizedMerchantName = normalizeForSearch(merchantName);
          if (excludeMerchantsCache.normalizedNames.has(normalizedMerchantName)) {
            if (DEBUG.merchantFilter) {
              console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] ‚õî Hiding deal due to merchant match (delayed):`, {
                dealId,
                merchantId,
                merchantName,
                matchType: "name",
                matchValue: normalizedMerchantName
              });
            }
            hideDeal(deal, `delayed-merchant-name:${merchantName}`);
            recheckHiddenCount++;
          }
        }
      });

      // Logging: Nur bei tats√§chlichem Erfolg (additionallyHidden > 0)
      if (DEBUG.merchantFilter && recheckHiddenCount > 0) {
        console.log(`[${getDebugTimestamp()}] [MDM MerchantFilter] ‚úÖ Delayed Re-Check done ‚Äì checked ${visibleDeals.length} deals, hidden ${recheckHiddenCount}`);
      }

      // Flag zur√ºcksetzen - erm√∂glicht neue Re-Checks f√ºr zuk√ºnftige Batches
      lastSuccessfulMerchantRecheck = Date.now();
      delayedMerchantRecheckScheduled = false;
    }, 2000); // 2 Sekunden Delay
  }

  // === Batch-Ende Logging ===

  // Aggregiertes Vue3-Defer-Logging (ersetzt viele Einzel-Logs)
  if (DEBUG.performance.lazyRenderSummary && vue3DeferredCount > 0) {
    console.log(
      `[${getDebugTimestamp()}] [MDM] Deals mit verz√∂gerter Anzeige: ${vue3DeferredCount} Deal(s) werden sp√§ter erneut gepr√ºft.`
    );
  }

  // Performance-Messung: Zeit bis zum ersten Title-Update
  if (DEBUG.performance.processing && deals.length > 0) {
    const timeToFirstUpdate = firstTitleUpdateTime !== null
      ? (firstTitleUpdateTime - batchStartTime).toFixed(2)
      : 'N/A';

    console.log(`[${getDebugTimestamp()}] [MDM Performance] Batch completed:`, {
      totalDeals: deals.length,
      vue3Deferred: vue3DeferredCount,
      timeToFirstTitleUpdate_ms: timeToFirstUpdate
    });
  }
}

// ===== Filterlogik =====
// Ausschlusspr√ºfung f√ºr Artikel
function shouldExcludeArticle(article, normalizedTitleForFilter = null) {
  const titleElement = article.querySelector(".thread-title");
  if (!titleElement) {
    return { shouldExclude: false, reason: "no-title-element" };
  }

  if (DEBUG.priceFilter) {
    console.log("[MDM PriceFilter] üîç Checking article:", {
      articleId: article.id,
      maxPrice: maxPrice,
      maxPriceType: typeof maxPrice,
      willCheckPrice: maxPrice > 0,
      reason: maxPrice > 0 ? "Preis-Check wird durchgef√ºhrt" : "‚ö†Ô∏è maxPrice ist 0 - KEIN Preis-Check!"
    });
  }

  if (maxPrice > 0) {
    perfTracker.start("priceFilter");
    perfTracker.update("filtering.priceFilter.calls", 1);

    const priceSelectors = [".thread-price", ".text--color-greyShade", ".color--text-NeutralSecondary"];
    let foundPrice = false;
    let checkedSelectors = [];

    for (const selector of priceSelectors) {
      const priceElement = article.querySelector(selector);
      if (!priceElement) {
        checkedSelectors.push({ selector, found: false });
        if (DEBUG.priceFilterVerbose) {
          console.log(`[MDM PriceFilter] ‚ùå Selector '${selector}' not found in article ${article.id}`);
        }
        continue;
      }

      checkedSelectors.push({ selector, found: true });
      foundPrice = true;

      const priceText = priceElement.textContent.trim();

      if (DEBUG.priceFilterVerbose) {
        console.log("[MDM PriceFilter] ‚úÖ Found price element:", {
          articleId: article.id,
          selector,
          text: priceText,
        });
      }

      if (priceText.includes("%")) {
        if (DEBUG.priceFilterVerbose) console.log("[MDM PriceFilter] ‚è≠Ô∏è Skipped: contains %");
        continue;
      }
      if (priceText.startsWith("-")) {
        if (DEBUG.priceFilterVerbose) console.log("[MDM PriceFilter] ‚è≠Ô∏è Skipped: starts with -");
        continue;
      }
      if (!priceText.includes("‚Ç¨")) {
        if (DEBUG.priceFilterVerbose) console.log("[MDM PriceFilter] ‚è≠Ô∏è Skipped: no ‚Ç¨ symbol");
        continue;
      }

      const euroFormatMatch = priceText.match(/([\d.,]+)\s*‚Ç¨/);
      if (euroFormatMatch) {
        let extractedPrice = euroFormatMatch[1];

        if (DEBUG.priceFilterVerbose) {
          console.log("[MDM PriceFilter] üìä Extracting price:", {
            articleId: article.id,
            rawMatch: euroFormatMatch[1],
            step1_removeDots: extractedPrice.replace(/\./g, ""),
            step2_replaceComma: extractedPrice.replace(/\./g, "").replace(",", ".")
          });
        }

        extractedPrice = extractedPrice.replace(/\./g, "");
        extractedPrice = extractedPrice.replace(",", ".");

        const priceValue = parseFloat(extractedPrice);

        if (DEBUG.priceFilterVerbose) {
          console.log("[MDM PriceFilter] üí∞ Price comparison:", {
            articleId: article.id,
            extractedString: extractedPrice,
            parsedValue: priceValue,
            maxPrice: maxPrice,
            exceeds: priceValue > maxPrice,
            isValid: !isNaN(priceValue)
          });
        }

        if (!isNaN(priceValue) && priceValue > maxPrice) {
          perfTracker.update("filtering.priceFilter.hits", 1);
          perfTracker.currentBatch.filtering.priceExceeded++;

          if (DEBUG.priceFilter) {
            console.log("[MDM PriceFilter] üö´ HIDING: Price exceeds max:", {
              articleId: article.id,
              price: priceValue,
              maxPrice: maxPrice,
              difference: priceValue - maxPrice
            });
          }

          const duration = perfTracker.end("priceFilter");
          perfTracker.update("filtering.priceFilter.totalTime", duration);

          return true;
        } else if (DEBUG.priceFilterVerbose) {
          console.log("[MDM PriceFilter] ‚úÖ KEEPING: Price is OK:", {
            articleId: article.id,
            price: priceValue,
            maxPrice: maxPrice
          });
        }
      } else if (DEBUG.priceFilterVerbose) {
        console.log("[MDM PriceFilter] ‚ö†Ô∏è No price match in text:", priceText);
      }
    }

    if (!foundPrice) {
      if (DEBUG.priceFilter) {
        console.warn(
          "[MDM PriceFilter] ‚ö†Ô∏è NO PRICE FOUND for article:", article.id
        );
        console.warn("[MDM PriceFilter] Checked selectors:", checkedSelectors);
      }
      if (DEBUG.criticalErrors) {
        console.warn(
          "[MDM Critical] ‚ö† priceFilter: ALLE Preis-Selektoren fehlgeschlagen!"
        );
        console.warn("[MDM Critical] Checked selectors:", checkedSelectors);
        console.warn("[MDM Critical] Article ID:", article.id);
      }
    }

    const duration = perfTracker.end("priceFilter");
    perfTracker.update("filtering.priceFilter.totalTime", duration);
  }

  const titleLink = titleElement.querySelector("a");

  // KRITISCH: Wenn hideMatchingMerchantNames aktiv ist, muss der Wortfilter auf den ORIGINALTITEL
  // angewendet werden, nicht auf den bereits bereinigten Titel!
  // Ansonsten werden Deals mit bereits entferntem H√§ndlernamen nicht gefiltert.
  const dealId = article.id || article.getAttribute("data-thread-id");
  let rawTitle;

  if (window.hideMatchingMerchantNames && dealId && ORIGINAL_TITLES.has(dealId)) {
    // Nutze Originaltitel f√ºr Wortfilter, damit H√§ndlernamen erkannt werden
    rawTitle = ORIGINAL_TITLES.get(dealId);
  } else {
    // Nutze sichtbaren Titel
    rawTitle = titleLink?.getAttribute("title") || titleElement.innerText;
  }

  // WICHTIG: Nutze √ºbergebenen normalizedTitleForFilter wenn vorhanden, sonst neu erstellen
  // Dies stellt sicher, dass der Wortfilter den GLEICHEN Titel sieht wie die Cache-Logik
  const normalizedTitle = normalizedTitleForFilter || normalizeForSearch(rawTitle);

  if (DEBUG.wordFilter) {
    console.log("[MDM WordFilter] shouldExcludeArticle START:", {
      articleId: article.id,
      dealId,
      rawTitle,
      normalizedTitle,
      usedOriginalTitle: window.hideMatchingMerchantNames && dealId && ORIGINAL_TITLES.has(dealId),
      normalizedTitleForFilterProvided: !!normalizedTitleForFilter,
      titleAttribute: titleLink?.getAttribute("title"),
      textContent: titleLink?.textContent,
      innerText: titleElement.innerText,
      totalFilters: excludeWordCache.length,
      hideMatchingMerchantNamesActive: window.hideMatchingMerchantNames
    });
  }

  if (!normalizedTitle) {
    return false;
  }

  // WHITELIST-PR√úFUNG: Wenn Titel Whitelist-Wort enth√§lt, NICHT ausblenden
  if (whitelistCache.length > 0) {
    if (DEBUG.wordFilter) {
      console.log("[MDM Whitelist] Checking whitelist:", {
        whitelistWords: whitelistCache.join(", ")
      });
    }
    for (const whitelistWord of whitelistCache) {
      if (normalizedTitle.includes(whitelistWord)) {
        if (DEBUG.wordFilter) {
          console.log("[MDM Whitelist] ‚úì Deal PROTECTED:", {
            title: normalizedTitle,
            matchedWord: whitelistWord,
          });
        }
        return false; // Deal NICHT ausblenden
      }
    }
    if (DEBUG.wordFilter) {
      console.log("[MDM Whitelist] No whitelist match");
    }
  }

  if (excludeWordCache.length > 0) {
    perfTracker.start("wordFilter");
    perfTracker.update("filtering.wordFilter.calls", 1);

    if (DEBUG.wordFilterVerbose) {
      console.log("[MDM WordFilter] Testing filters:", {
        totalFilters: excludeWordCache.length,
        sampleFilters: excludeWordCache.slice(0, 5).map(e => `"${e.original}" (${e.type})`).join(", ") + "..."
      });
    }

    let matched = false;
    let matchedFilter = null;
    for (const entry of excludeWordCache) {
      if (entry.matcher(normalizedTitle)) {
        matched = true;
        matchedFilter = entry;
        perfTracker.update("filtering.wordFilter.hits", 1);
        perfTracker.currentBatch.filtering.wordMatches++;

        // DEBUG: Match gefunden
        if (DEBUG.wordFilter) {
          console.log("[MDM WordFilter] ‚úÇÔ∏è MATCH - Deal HIDDEN:", {
            dealId: article.id,
            title: rawTitle,
            filter: entry.original,
            type: entry.type
          });
        }
        break;
      }
    }

    const duration = perfTracker.end("wordFilter");
    perfTracker.update("filtering.wordFilter.totalTime", duration);

    if (matched) return true;
  }

  return false;
}

// ===== Deal-Management =====
// Deal ausblenden
function hideDeal(deal, reason = "unknown") {
  if (!deal) return;

  const dealId = deal.getAttribute("id") || "unknown";
  const wasAlreadyHidden = deal.classList.contains("mydealz-manager-hidden");

  deal.classList.add("mydealz-manager-hidden");
  deal.style.setProperty("display", "none", "important");
  deal.setAttribute("data-hidden-by-mydealz-manager", "true");
  deal.setAttribute("data-hide-reason", reason); // Grund speichern

  if (DEBUG.wordFilter && !wasAlreadyHidden) {
    // √úberpr√ºfe ob das Verstecken tats√§chlich funktioniert hat
    const computedStyle = window.getComputedStyle(deal);
    const isActuallyHidden = computedStyle.display === "none";

    console.log(`[${getDebugTimestamp()}] [MDM Hide] ‚úÇÔ∏è Deal wird VERSTECKT:`, {
      dealId,
      reason,
      wasAlreadyHidden,
      inlineStyle: deal.style.display,
      computedDisplay: computedStyle.display,
      isActuallyHidden,
      hasClass: deal.classList.contains("mydealz-manager-hidden"),
      hasAttribute: deal.getAttribute("data-hidden-by-mydealz-manager")
    });

    // Warnung wenn Deal NICHT versteckt ist trotz Aufruf
    if (!isActuallyHidden) {
      console.warn(`[${getDebugTimestamp()}] [MDM Hide] ‚ö†Ô∏è WARNUNG: Deal wurde NICHT versteckt trotz hideDeal():`, {
        dealId,
        reason,
        inlineStyle: deal.style.display,
        computedDisplay: computedStyle.display,
        allClasses: Array.from(deal.classList),
        possibleCSSConflict: true
      });
    }
  }

  perfTracker.update("domUpdates.hideActions", 1);
  perfTracker.currentBatch.domUpdates.hidden++;
}

function showDeal(deal, reason = "unknown") {
  if (!deal) return;

  const dealId = deal.getAttribute("id") || "unknown";
  const wasHidden = deal.classList.contains("mydealz-manager-hidden");

  deal.classList.remove("mydealz-manager-hidden");
  deal.style.removeProperty("display");
  deal.style.opacity = "";
  deal.setAttribute("data-hidden-by-mydealz-manager", "false");

  if (DEBUG.wordFilter && wasHidden) {
    console.log(`[${getDebugTimestamp()}] [MDM Show] üëÅÔ∏è Deal wird ANGEZEIGT:`, {
      dealId,
      reason,
      wasHidden,
      displayStyle: deal.style.display
    });
  }

  perfTracker.update("domUpdates.showActions", 1);
  perfTracker.currentBatch.domUpdates.shown++;
}

// Funktion zum Speichern der Sucheinstellungen
function processSucheinstellungen() {
  // Wenn Feature deaktiviert ist, l√∂sche gespeicherte Einstellungen
  if (!window.rememberSort) {
    // Pr√ºfen und entfernen der gespeicherten Einstellungen
    if (localStorage.getItem(PREFERRED_SORT_KEY)) {
      localStorage.removeItem(PREFERRED_SORT_KEY);
    }
    if (localStorage.getItem(PREFERRED_TIMEFRAME_KEY)) {
      localStorage.removeItem(PREFERRED_TIMEFRAME_KEY);
    }
    return;
  }

  // Pr√ºfen, ob wir auf einer Suchseite sind
  if (window.location.pathname.includes("/search")) {
    // Parameter aus URL auslesen
    const params = new URLSearchParams(window.location.search);
    const currentSort = params.get("sortBy");
    const currentTimeframe = params.get("time_frame");

    // Wenn Sortierung vorhanden ist, speichern
    if (currentSort) {
      localStorage.setItem(PREFERRED_SORT_KEY, currentSort);
    }

    // Wenn Zeitraum vorhanden ist, speichern
    if (currentTimeframe) {
      localStorage.setItem(PREFERRED_TIMEFRAME_KEY, currentTimeframe);
    }

    // Wenn keine Sortierung/Zeitraum gesetzt ist, aber gespeicherte Einstellungen existieren
    const savedSort = localStorage.getItem(PREFERRED_SORT_KEY);
    const savedTimeframe = localStorage.getItem(PREFERRED_TIMEFRAME_KEY);

    // NUR redirecten wenn BEIDE Parameter fehlen (frische Suche vom Formular)
    // Wenn nur einer fehlt, hat der User ihn bewusst entfernt
    if (
      (savedSort || savedTimeframe) &&
      !params.has("sortBy") &&
      !params.has("time_frame")
    ) {
      // Neue URL mit den gespeicherten Einstellungen erstellen
      let newUrl = window.location.href;
      const separator = newUrl.includes("?") ? "&" : "?";
      const additionalParams = [];

      if (savedSort) {
        additionalParams.push("sortBy=" + savedSort);
      }

      if (savedTimeframe) {
        additionalParams.push("time_frame=" + savedTimeframe);
      }

      if (additionalParams.length > 0) {
        newUrl += separator + additionalParams.join("&");
        window.location.href = newUrl;
      }
    }
  }

  // Suchformulare abfangen und anpassen
  const searchForms = document.querySelectorAll('form[action*="/search"]');
  searchForms.forEach((form) => {
    // Pr√ºfen, ob das Formular bereits verarbeitet wurde
    if (form.dataset.sortingModified === "true") return;

    // Markieren, dass das Formular verarbeitet wurde
    form.dataset.sortingModified = "true";

    // Event-Listener f√ºr das Absenden des Formulars hinzuf√ºgen
    form.addEventListener("submit", function (e) {
      // Nur fortfahren, wenn Feature aktiviert ist
      if (!window.rememberSort) return;

      const savedSort = localStorage.getItem(PREFERRED_SORT_KEY);
      const savedTimeframe = localStorage.getItem(PREFERRED_TIMEFRAME_KEY);

      if (savedSort || savedTimeframe) {
        // Sortierung hinzuf√ºgen
        if (savedSort) {
          let sortByInput = form.querySelector('input[name="sortBy"]');
          if (!sortByInput) {
            sortByInput = document.createElement("input");
            sortByInput.type = "hidden";
            sortByInput.name = "sortBy";
            form.appendChild(sortByInput);
          }
          sortByInput.value = savedSort;
        }

        // Zeitraum hinzuf√ºgen
        if (savedTimeframe) {
          let timeframeInput = form.querySelector('input[name="time_frame"]');
          if (!timeframeInput) {
            timeframeInput = document.createElement("input");
            timeframeInput.type = "hidden";
            timeframeInput.name = "time_frame";
            form.appendChild(timeframeInput);
          }
          timeframeInput.value = savedTimeframe;
        }
      }
    });
  });
}

// Funktion zum Ausblenden von User-Deals
function handleUserBlock(article) {
  console.log("[MDM UserBlock] ===== handleUserBlock CALLED =====");
  console.log("[MDM UserBlock] article:", article);
  console.log("[MDM UserBlock] article.id:", article?.id);
  console.log("[MDM UserBlock] DEBUG.userBlocking:", DEBUG.userBlocking);

  if (DEBUG.userBlocking) {
    console.log("[MDM UserBlock] handleUserBlock called", {
      article: article?.id,
    });
  }

  let displayName = null;
  let foundVia = null;

  // Methode 1: data-md-author Attribut (zuverl√§ssigste Methode, Original-Case)
  displayName = article.getAttribute("data-md-author");
  console.log("[MDM UserBlock] Method 1 result:", { displayName, foundVia: displayName ? "data-md-author" : null });

  if (displayName) {
    foundVia = "data-md-author";
    if (DEBUG.userBlocking) {
      console.log(
        "[MDM UserBlock] ‚úì Username found via data-md-author:",
        displayName
      );
    }
  } else if (DEBUG.criticalErrors) {
    console.warn(
      "[MDM Critical] ‚ö† data-md-author attribute not found on article"
    );
  }

  // Methode 2: Span mit "Ver√∂ffentlicht von" Text
  if (!displayName) {
    const userSpan = article.querySelector(
      ".overflow--ellipsis.size--all-xs.size--fromW3-s"
    );
    if (userSpan) {
      const match = userSpan.textContent.match(/Ver√∂ffentlicht von\s+(\S+)/i);
      if (match && match[1]) {
        displayName = match[1];
        foundVia = "span-text";
        if (DEBUG.userBlocking) {
          console.log(
            "[MDM UserBlock] ‚úì Username found via span text:",
            displayName
          );
        }
      } else if (DEBUG.criticalErrors) {
        console.warn(
          "[MDM Critical] ‚ö† Span found but regex did not match. Text:",
          userSpan.textContent
        );
      }
    } else if (DEBUG.criticalErrors) {
      console.warn(
        '[MDM Critical] ‚ö† Selector ".overflow--ellipsis.size--all-xs.size--fromW3-s" returned no element'
      );
    }
  }

  // Methode 3: User-Link im Header
  if (!displayName) {
    const userLink = article.querySelector('a[data-t="userLink"]');
    if (userLink) {
      displayName = userLink.textContent.trim();
      foundVia = "userLink";
      if (DEBUG.userBlocking) {
        console.log("[MDM UserBlock] ‚úì Username found via userLink:", displayName);
      }
    } else if (DEBUG.criticalErrors) {
      console.warn(
        '[MDM Critical] ‚ö† Selector "a[data-t="userLink"]" returned no element'
      );
    }
  }

  if (!displayName) {
    console.error(
      "[MDM Critical] ‚ùå ALLE Selektoren fehlgeschlagen! Kann Username nicht finden."
    );
    console.error("[MDM Critical] Article ID:", article.id);
    console.error(
      "[MDM Critical] Article HTML (first 500 chars):",
      article.innerHTML.substring(0, 500)
    );
    if (DEBUG.userBlocking) {
      console.log("[MDM UserBlock] Article attributes:", {
        id: article.id,
        "data-md-author": article.getAttribute("data-md-author"),
        "data-md-state": article.getAttribute("data-md-state"),
      });
    }
    alert("Benutzerinformation konnte nicht gefunden werden.");
    return;
  }

  // Normalisiere f√ºr Vergleich/Speicher-Key
  const normalizedUsername = displayName.toLowerCase();

  console.log('[MDM UserBlock] Username normalized:', {
    displayName,
    normalizedUsername
  });

  // Best√§tigungsdialog mit Original-Case
  console.log('[MDM UserBlock] Showing confirm dialog for:', displayName);
  const userConfirmed = confirm(`M√∂chtest du wirklich alle Deals von "${displayName}" ausblenden?`);
  console.log('[MDM UserBlock] User confirmed:', userConfirmed);

  if (!userConfirmed) {
    console.log("[MDM UserBlock] User cancelled blocking");
    return;
  }

  // Lade blockierte Benutzer (Object-Format)
  const blockedUsers = GM_getValue("blockedUsers", {});
  console.log("[MDM UserBlock] Current blocked users:", blockedUsers);

  // Pr√ºfe ob User bereits blockiert (case-insensitive)
  if (!blockedUsers[normalizedUsername]) {
    console.log("[MDM UserBlock] User NOT in blocklist, adding now:", normalizedUsername);

    // Speichere mit displayName + normalizedUsername
    blockedUsers[normalizedUsername] = {
      displayName: displayName,
      normalizedUsername: normalizedUsername,
      timestamp: Date.now()
    };

    if (DEBUG.userBlocking) {
      console.log("[MDM UserBlock] Saving blockedUsers:", blockedUsers);
    }

    // Sofort speichern
    GM_setValue("blockedUsers", blockedUsers);

    if (DEBUG.userBlocking) {
      console.log("[MDM UserBlock] blockedUsers saved to GM storage");
    }

    // Timestamp f√ºr UI
    userAddedAt[normalizedUsername] = { timestamp: formatTimestamp(), isLegacy: false };
    GM_setValue("userAddedAt", userAddedAt);

    if (DEBUG.userBlocking) {
      console.log("[MDM UserBlock] User added to blocklist successfully:", normalizedUsername);
    }
  } else {
    if (DEBUG.userBlocking) {
      console.log("[MDM UserBlock] User ALREADY in blocklist:", normalizedUsername);
    }
  }

  // Sofort Filter anwenden (forceRun=true um Early Exit zu √ºberspringen)
  if (DEBUG.userBlocking) {
    console.log('[MDM UserBlock] Calling processArticles(), blocked users:', Object.keys(blockedUsers));
  }
  processArticles(true);
}

//#endregion

//#region --- 6. Initialisierung und Setup ---
function init() {
  // Verhindert mehrfache Ausf√ºhrung - init() soll nur einmal pro Seitenladung laufen
  if (initHasRun) {
    return;
  }
  initHasRun = true;

  if (DEBUG.initialization) {
    console.log("[MDM] üöÄ init() called");
  }

  // ===== 1. Grundeinstellungen und gespeicherte Daten laden =====
  // loadSettings() l√§dt ALLE Daten: excludeWords, whitelistWords, merchants, maxPrice, hideColdDeals, hiddenDeals, etc.
  loadSettings();

  // --- K√ºrzlich versteckte Deals ---
  recentHiddenDeals = GM_getValue("recentHiddenDeals", []);

  // --- Sortierung merken ---
  processSucheinstellungen();

  // ===== 2. Feature-Flags und UI-Status =====

  // --- H√§ndlernamen ---
  window.hideMatchingMerchantNames = hideMatchingMerchantNames;

  // ===== 5. System-Initialisierung =====

  // --- UI ---
  initializeUI();
  initObserver();

  // --- Scroll Handling (nur einmal global initialisieren) ---
  setupScrollHandling();

  // WICHTIG: Initiales Filtern nach Skript-Start mit forceRun=true
  // Dadurch wird der Early Exit umgangen und ALLE Deals werden garantiert gefiltert
  // auch wenn Vue3 noch asynchron rendert oder Deals verz√∂gert geladen werden
  setTimeout(() => {
    processArticles(true);
  }, 500);
}

//#endregion

//#region --- 7. Backup und Wiederherstellung ---
// ===== Backup-Funktionen =====
// --- Datei-Erstellung ---
function createBackupFile(backup, deviceName) {
  const blob = new Blob([JSON.stringify(backup, null, 2)], {
    type: "application/json",
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");

  // Neues Datumsformat
  const now = new Date();
  const timestamp = now
    .toISOString()
    .replace("T", "_") // T durch _ ersetzen
    .split(".")[0] // Millisekunden entfernen
    .replace(/:/g, ".") // : durch . ersetzen
    .replace(/-/g, "-"); // - behalten

  a.href = url;
  a.download = `mydealz_backup_${deviceName}_${timestamp}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

// --- Backup-Prozess ---
function backupData() {
  try {
    // 1. Daten laden
    const currentWords = loadExcludeWords();
    const currentWhitelist = loadWhitelistWords();
    const currentMerchants = loadExcludeMerchants();
    const currentBlockedUsers = GM_getValue("blockedUsers", []);

    if (DEBUG.backup) {
      console.log("[MDM Backup] Creating backup with data:", {
        words: currentWords.length,
        whitelist: currentWhitelist.length,
        merchants: currentMerchants.length,
        blockedUsers: currentBlockedUsers.length,
        blockedUsersList: currentBlockedUsers,
      });
    }

    // 2. Backup-Objekt erstellen
    const backup = {
      excludeWords: currentWords,
      whitelistWords: currentWhitelist,
      merchantsData: currentMerchants,
      blockedUsers: currentBlockedUsers,
      maxPrice: maxPrice,
      hideColdDeals: hideColdDeals,
    };

    if (DEBUG.backup) {
      console.log("[MDM Backup] Backup object created:", backup);
    }

    // 3. Ger√§te-Erkennung
    let deviceType = "Desktop";
    if (IS_TOUCH_DEVICE) {
      // √úberpr√ºfe, ob es ein mobiles Ger√§t ist
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes("iphone") || userAgent.includes("ipad")) {
        deviceType = "iOS";
      } else if (userAgent.includes("android")) {
        deviceType = "Android";
      } else {
        deviceType = "Tablet/Touch";
      }
    }

    // 4. Ger√§tenamen-Verwaltung
    const DEVICE_NAME_KEY = "mdm_device_name";
    const customDeviceName =
      localStorage.getItem(DEVICE_NAME_KEY) || GM_getValue(DEVICE_NAME_KEY, "");

    // 5. Backup-Erstellung
    if (!customDeviceName) {
      // Neuen Ger√§tenamen abfragen
      const newName = prompt(
        "Wie m√∂chtest du dieses Ger√§t nennen?\n" +
          "Dies hilft dir, Backups von verschiedenen Ger√§ten zu unterscheiden.",
        deviceType
      );

      if (newName !== null) {
        const deviceName = newName.trim() || deviceType;
        // In beiden Speichern ablegen
        localStorage.setItem(DEVICE_NAME_KEY, deviceName);
        GM_setValue(DEVICE_NAME_KEY, deviceName);

        // Mit dem neuen Namen das Backup erstellen
        createBackupFile(backup, deviceName);
      }
    } else {
      // Mit dem vorhandenen Namen das Backup erstellen
      createBackupFile(backup, customDeviceName);
    }
  } catch (error) {
    console.error("Backup error:", error);
    alert("Fehler beim Erstellen des Backups: " + error.message);
  }
}

// ===== Wiederherstellungs-Funktionen =====
// --- Daten-Wiederherstellung ---
function restoreData(event) {
  // 1. Datei-Validierung
  const file = event.target.files[0];
  if (!file || file.type !== "application/json") {
    console.error("Invalid file:", file);
    alert("Bitte w√§hlen Sie eine g√ºltige JSON-Datei aus.");
    return;
  }

  // 2. Datei-Verarbeitung
  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      // 3. Daten-Parsing
      const restoredData = JSON.parse(e.target.result);

      if (DEBUG.backup) {
        console.log("[MDM Restore] Restored data:", restoredData);
        console.log(
          "[MDM Restore] Blocked users in backup:",
          restoredData.blockedUsers
        );
      }

      // 4. Aktuelle Daten laden
      const currentWords = new Set(loadExcludeWords());
      const currentMerchants = new Map(
        loadExcludeMerchants().map((m) => [m.id, m])
      );
      const currentBlockedUsers = new Set(GM_getValue("blockedUsers", []));
      if (DEBUG.backup) {
        console.log(
          "[MDM Restore] Current blocked users:",
          Array.from(currentBlockedUsers)
        );
      }
      console.log(
        "[MDM Restore] Current blocked users:",
        Array.from(currentBlockedUsers)
      );

      // 5. Z√§hler f√ºr neue Eintr√§ge initialisieren
      const changes = {
        words: 0,
        whitelist: 0,
        merchants: 0,
        users: 0,
      };

      // 6. Daten zusammenf√ºhren
      const currentWhitelist = new Set(loadWhitelistWords());

      // --- W√∂rter ---
      restoredData.excludeWords.forEach((word) => {
        if (!currentWords.has(word)) {
          currentWords.add(word);
          changes.words++;
        }
      });
      const mergedWords = Array.from(currentWords);

      // --- Whitelist ---
      if (restoredData.whitelistWords) {
        restoredData.whitelistWords.forEach((word) => {
          if (!currentWhitelist.has(word)) {
            currentWhitelist.add(word);
            changes.whitelist++;
          }
        });
      }
      const mergedWhitelist = Array.from(currentWhitelist);

      // --- H√§ndler ---
      restoredData.merchantsData.forEach((merchant) => {
        if (!currentMerchants.has(merchant.id)) {
          currentMerchants.set(merchant.id, merchant);
          changes.merchants++;
        }
      });
      const mergedMerchants = Array.from(currentMerchants.values());

      // --- Blockierte Benutzer (falls im Backup vorhanden) ---
      if (restoredData.blockedUsers) {
        restoredData.blockedUsers.forEach((user) => {
          if (!currentBlockedUsers.has(user)) {
            currentBlockedUsers.add(user);
            changes.users++;
          }
        });
      }

      // 7. Daten speichern
      // --- Wortfilter ---
      saveExcludeWords(mergedWords);
      excludeWords = mergedWords;

      // --- Whitelist ---
      saveWhitelistWords(mergedWhitelist);
      whitelistWords = mergedWhitelist;

      // --- H√§ndlerfilter ---
      saveExcludeMerchants(mergedMerchants);

      // --- Blockierte Benutzer ---
      const mergedBlockedUsers = Array.from(currentBlockedUsers);
      GM_setValue("blockedUsers", mergedBlockedUsers);

      // --- Einstellungen ---
      if (typeof restoredData.maxPrice === "number" && maxPrice === 0) {
        saveMaxPrice(restoredData.maxPrice);
      }

      if (typeof restoredData.hideColdDeals === "boolean" && !hideColdDeals) {
        hideColdDeals = restoredData.hideColdDeals;
        GM_setValue("hideColdDeals", hideColdDeals);
      }

      // 8. UI aktualisieren
      if (isSettingsOpen) {
        updateUITheme();
      }
      processArticles();

      // 9. Zusammenfassende Meldung erstellen
      let message =
        "Backup wurde erfolgreich wiederhergestellt.\n\nNeue Eintr√§ge:";

      if (changes.words > 0) {
        message += `\n‚Ä¢ ${changes.words} neue W√∂rter`;
      }
      if (changes.whitelist > 0) {
        message += `\n‚Ä¢ ${changes.whitelist} neue Whitelist-W√∂rter`;
      }
      if (changes.merchants > 0) {
        message += `\n‚Ä¢ ${changes.merchants} neue H√§ndler`;
      }
      if (changes.users > 0) {
        message += `\n‚Ä¢ ${changes.users} neue blockierte Benutzer`;
      }

      if (
        changes.words === 0 &&
        changes.merchants === 0 &&
        changes.users === 0
      ) {
        message += "\nKeine neuen Eintr√§ge gefunden.";
      }

      alert(message);
    } catch (error) {
      console.error("Restore error:", error);
      alert("Fehler beim Wiederherstellen des Backups: " + error.message);
    }
  };

  reader.readAsText(file);
}

//#endregion

//#region --- 8. Hilfsfunktionen ---
// ===== Text-Verarbeitung =====
// --- H√§ndlernamen-Verarbeitung ---
function removeMerchantNameFromTitle(title, merchant) {
  if (!title || !merchant) return title;

  // Normalisiere H√§ndlernamen und hole Konfiguration
  const merchantName = merchant.toLowerCase().replace("...", "");
  const normalizedMerchantName = normalizeForSearch(merchant.replace("...", ""));

  // Wenn der H√§ndlername CamelCase ist (z.B. FrankfurterRundschau, BerlinerMorgenpost)
  // erstelle eine Version mit Leerzeichen (z.B. "Frankfurter Rundschau", "Berliner Morgenpost")
  if (/^[A-Z][a-z]+(?:[A-Z][a-z]+)+$/.test(merchant)) {
    // Teile den CamelCase Namen an Gro√übuchstaben
    const spacedVersion = merchant.split(/(?=[A-Z])/).join(" ");

    // Pr√ºfe ob die Version mit Leerzeichen im Titel vorkommt
    const spacedRegex = new RegExp(`\\b${spacedVersion}\\b`, "i");
    if (title.match(spacedRegex)) {
      title = title.replace(spacedRegex, "");
      return title.trim();
    }
  }

  // NEU: Minimum L√§nge f√ºr Domain-basierte Entfernung
  const MIN_DOMAIN_LENGTH = 4;
  if (merchantName.includes(".")) {
    const domainWithoutExt = merchantName.split(".")[0];
    if (domainWithoutExt.length < MIN_DOMAIN_LENGTH) {
      return title;
    }
  }

  // Spezialfall f√ºr eSIM.sm - wir wollen "eSIM" nicht entfernen, da es ein Produktname ist
  if (merchantName === "esim.sm" && title.toLowerCase().includes("auf esim")) {
    return title;
  }

  // Extrahiere den Basis-Namen aus dem H√§ndlernamen, wenn es sich um eine Domain handelt
  let baseShopName = merchantName;
  if (merchantName.includes("-shop")) {
    baseShopName = merchantName.split("-shop")[0];
  } else if (merchantName.includes(".")) {
    // Extrahiere den Basisnamen aus Domains wie CDKeys.com -> CDKeys
    baseShopName = merchantName.split(".")[0];
  }

  // REMOVED: Old parentheses logic that returned early.
  // Now handled by the global pattern system below which processes ALL occurrences.

  // H√§ndler-spezifische Transformationen definieren
  const getMerchantConfig = (merchant) => {
    switch (merchant) {
      case "Netto Marken-Discount":
        return {
          abbreviations: ["netto md"],
          replacements: [
            // Entfernt "Netto Marken Discount -" nach lokaler Angabe
            {
              from: /(\[\s*lokal[^\]]+\])\s*netto\s+marken[-\s]discount\s*-\s*/i,
              to: "$1 ",
            },
            // Entfernt "bei Netto Marken-Discount gibt es"
            {
              from: /\s+bei\s+netto\s+marken[-\s]discount\s+gibt\s+es\s*/i,
              to: " ",
            },
            // Standardf√§lle f√ºr Netto
            {
              from: /(?<!\[.+)\s*(?:bei\s+)?netto\s+marken[-\s]discount[-\s]*/i,
              to: " ",
            },
          ],
          keepBrands: [],
        };
      case "Kaufland":
        return {
          abbreviations: [],
          replacements: [
            { from: /kaufland[\s-]card/i, to: "K-Card" },
            // Entfernt "bei Kaufland" auch in der Mitte
            { from: /\s+bei\s+kaufland(?:\s*-\s*)/i, to: " - " },
          ],
          keepBrands: ["Card"],
        };
      case "Amazon":
        return {
          abbreviations: [],
          replacements: [
            // Besonders behandelte Muster f√ºr Amazon Prime
            { from: /\[amazon\s+prime\]/i, to: "[Prime]" },
            { from: /\[amazon\s+(prime\s+\w+)\]/i, to: "[$1]" },
            // Ersetze "Amazon Prime" mit "Prime" (au√üerhalb von Klammern)
            { from: /\bamazon\s+prime\b/i, to: "Prime" },
            // Erhalte "Prime Video", "Prime Gaming" usw.
            { from: /\bamazon\s+(prime\s+\w+)\b/i, to: "$1" },
          ],
          keepBrands: ["Prime"],
        };
      case "Best Secret":
        return {
          abbreviations: ["BestSecret"],
          replacements: [],
          keepBrands: [],
        };
      case "TradePub.com":
        return {
          abbreviations: ["tradepub", "Tradepub"],
          replacements: [
            { from: /\s+bei\s+tradepub\.com(?:\s+|$)/i, to: " " },
            { from: /^tradepub\.com:\s*/i, to: "" },
            { from: /^\(tradepub\)\s*/i, to: "" },
            // Neues Pattern f√ºr (Tradepub) mit Gro√ü-/Kleinschreibung
            { from: /^\((?:Tradepub|TRADEPUB|tradepub)\)\s*/i, to: "" },
          ],
          keepBrands: [],
        };
      case "Netto":
        return {
          abbreviations: ["netto mit hund"],
          replacements: [
            // Entfernt "[Netto mit Hund]" Format
            { from: /\[netto\s+mit\s+hund\]\s*/i, to: "" },
          ],
          keepBrands: [],
        };
      case "A.T.U":
        return {
          abbreviations: ["atu", "a.t.u"],
          replacements: [
            {
              from: /(Sale)\s+bei\s+(?:ATU|A\.T\.U)(\s*;\s*)(Ab)/i,
              to: "$1$2$3",
            },
          ],
          keepBrands: [],
        };
      case "Uber Eats":
        return {
          abbreviations: ["ubereats"],
          replacements: [
            // Spezifisches Pattern f√ºr "[UberEats Member Days]" Format
            { from: /\[UberEats\s+(Member\s+Days)\]/i, to: "[$1]" },
          ],
          keepBrands: ["Member Days"],
        };
      case "Steam":
        return {
          abbreviations: [],
          replacements: [
            // Behandle [Steam/Something] und [Steam / Something] Format am Anfang
            { from: /\[\s*Steam\s*\/\s*([^\]]+)\]/i, to: "[$1]" },
            // Generische Steam-Patterns
            { from: /\[Steam\]\s*/i, to: "" },
            { from: /\s+auf\s+Steam$/i, to: "" },
            { from: /\s+bei\s+Steam$/i, to: "" },
          ],
          keepBrands: [],
        };
      case "Zalando":
        return {
          abbreviations: [],
          replacements: [
            // Spezifisches Pattern f√ºr "[Zalando Plus]" Format
            { from: /\[Zalando\s+(Plus)\]/i, to: "[$1]" },
            // Standardmuster
            { from: /\[Zalando\]\s*/i, to: "" },
            { from: /\s+bei\s+Zalando$/i, to: "" },
            { from: /\s+auf\s+Zalando$/i, to: "" },
          ],
          keepBrands: ["Plus"],
        };
      default:
        return { abbreviations: [], replacements: [], keepBrands: [] };
    }
  };

  const config = getMerchantConfig(merchant);

  // F√ºhre erst spezielle Ersetzungen durch
  let result = title;
  config.replacements.forEach(({ from, to }) => {
    result = result.replace(from, to);
  });

  // Spezielle Muster f√ºr [H√§ndler| Format]
  result = result.replace(
    new RegExp(
      `\\[${merchantName.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}\\|\\s*`,
      "i"
    ),
    "["
  );

  // Wenn wir einen Basis-Namen extrahiert haben, auch diesen behandeln
  if (baseShopName !== merchantName) {
    result = result.replace(
      new RegExp(
        `\\[${baseShopName.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}\\|\\s*`,
        "i"
      ),
      "["
    );
  }

  // Erstelle Domain-Varianten f√ºr den H√§ndlernamen und den Basis-Namen
  const createDomainVariants = (name) => [
    `${name}.com`,
    `${name}.de`,
    `${name}.co.uk`,
    `${name}-shop.com`,
    `${name}-shop.de`,
  ];

  const domainVariants = createDomainVariants(merchantName);

  // F√ºge auch Domain-Varianten f√ºr den Basis-Namen hinzu
  if (baseShopName !== merchantName) {
    domainVariants.push(...createDomainVariants(baseShopName));
  }

  // Entferne explizit [Domain]-Muster am Anfang des Titels
  const handleBracketedDomain = (shopName) => {
    const escapedName = shopName.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    result = result.replace(new RegExp(`\\[${escapedName}\\.com\\]`, "i"), "");
    result = result.replace(new RegExp(`\\[${escapedName}\\.de\\]`, "i"), "");
    result = result.replace(
      new RegExp(`\\[${escapedName}\\.co\\.uk\\]`, "i"),
      ""
    );
  };

  // Wende auf beide Namen an
  handleBracketedDomain(merchantName);
  if (baseShopName !== merchantName) {
    handleBracketedDomain(baseShopName);
  }

  // Erstelle Varianten des H√§ndlernamens
  const merchantVariants = [
    merchantName,
    normalizedMerchantName, // Normalisierte Version (√∂‚Üío, √º‚Üíu, √§‚Üía)
    merchantName.replace(/\s+/g, "-"),
    merchantName.replace(/\-/g, " "),
    normalizedMerchantName.replace(/\s+/g, "-"),
    normalizedMerchantName.replace(/\-/g, " "),
    ...config.abbreviations,
    ...domainVariants,
  ];

  // Den Basisnamen auch zu den Varianten hinzuf√ºgen
  if (baseShopName !== merchantName) {
    const normalizedBaseName = normalizeForSearch(baseShopName);
    merchantVariants.push(baseShopName);
    merchantVariants.push(normalizedBaseName);
    merchantVariants.push(baseShopName.replace(/\s+/g, "-"));
    merchantVariants.push(baseShopName.replace(/\-/g, " "));
    merchantVariants.push(normalizedBaseName.replace(/\s+/g, "-"));
    merchantVariants.push(normalizedBaseName.replace(/\-/g, " "));
  }

  // Und, in umgekehrter Richtung, wenn der H√§ndlername bereits eine Domain ist
  if (merchantName.includes(".") || merchantName.includes("-shop")) {
    // Entferne TLD und m√∂gliche Zus√§tze wie "-shop"
    let baseName = merchantName
      .split(".")[0] // Entferne TLD (.com, .de, etc.)
      .replace(/-shop$/, "") // Entferne m√∂gliches "-shop" am Ende
      .replace(/[^\w\s-]/g, ""); // Entferne alle Sonderzeichen au√üer Bindestriche und Leerzeichen

    // Extrahiere nur den Kernnamen (z.B. "deblock" aus "verf√ºgbar bei deblock.com")
    const words = baseName.split(/\s+/);
    const coreName = words[words.length - 1]; // Letztes Wort (z.B. "deblock")

    merchantVariants.push(baseName);
    merchantVariants.push(normalizeForSearch(baseName));
    merchantVariants.push(coreName);
    merchantVariants.push(normalizeForSearch(coreName));
    // F√ºge auch Varianten mit unterschiedlicher Gro√ü-/Kleinschreibung hinzu
    merchantVariants.push(baseName.toLowerCase());
    merchantVariants.push(coreName.toLowerCase());
    merchantVariants.push(baseName.toUpperCase());

    // NEU: Erstelle Umlaut-Varianten (druckerzubehoer ‚Üí druckerzubeh√∂r)
    const denormalizeUmlauts = (str) => {
      return str
        .replace(/oe/g, '√∂').replace(/OE/g, '√ñ')
        .replace(/ue/g, '√º').replace(/UE/g, '√ú')
        .replace(/ae/g, '√§').replace(/AE/g, '√Ñ');
    };

    if (baseName.match(/oe|ue|ae/i)) {
      merchantVariants.push(denormalizeUmlauts(baseName));
      merchantVariants.push(denormalizeUmlauts(baseName).toLowerCase());
    }
    if (coreName.match(/oe|ue|ae/i)) {
      merchantVariants.push(denormalizeUmlauts(coreName));
      merchantVariants.push(denormalizeUmlauts(coreName).toLowerCase());
    }
  }

  // Entferne H√§ndlernamen
  merchantVariants.forEach((variant) => {
    // F√ºr besseres Matching: Erstelle auch normalisierte Version der Variante
    const normalizedVariant = normalizeForSearch(variant);
    const variantsToCheck = [variant];
    if (normalizedVariant !== variant.toLowerCase()) {
      variantsToCheck.push(normalizedVariant);
    }

    variantsToCheck.forEach((currentVariant) => {
      // Spezialfall f√ºr Domain-Formate wie "target.com"
      if (currentVariant.includes(".")) {
        // Genereller Ansatz, um "target.com" zu entfernen
        const baseDomain = currentVariant.split(".")[0];
        const escapedBase = baseDomain.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        const escapedVariant = currentVariant.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");

      // Entferne "[domain.com]" Format am Anfang
      result = result.replace(
        new RegExp(`\\[${escapedVariant}\\]\\s*`, "i"),
        ""
      );

      // Entferne auch dom√§nenspezifische Top-Level-Domains - das ist der Teil, der fehlt
      result = result.replace(
        new RegExp(`\\[${escapedBase}\\.com\\]\\s*`, "i"),
        ""
      );
      result = result.replace(
        new RegExp(`\\[${escapedBase}\\.de\\]\\s*`, "i"),
        ""
      );
      result = result.replace(
        new RegExp(`\\[${escapedBase}\\.co\\.uk\\]\\s*`, "i"),
        ""
      );

      // Spezifisches Pattern f√ºr "bei Target.com f√ºr" - umfassendere L√∂sung
      result = result.replace(
        new RegExp(`\\s+bei\\s+${escapedBase}\\.com\\s+f√ºr`, "i"),
        " f√ºr"
      );

      // Fallback-Pattern, um alle "bei domain.tld" Formate zu entfernen
      result = result.replace(
        new RegExp(`\\s+bei\\s+${escapedBase}\\.[a-z.]+(?:\\s+|$)`, "i"),
        " "
      );
      }

      // F√ºr Namen mit Punkten, verwende spezifischere Ersetzungsmuster
      const needsSpecialBoundary = currentVariant.includes(".");
      const escapedVariant = currentVariant.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
      const wordBoundaryPattern = needsSpecialBoundary
        ? escapedVariant
        : `\\b${escapedVariant}\\b`;

      if (needsSpecialBoundary) {
      } else {
      // Handle parentheses with multiple entries separated by slashes first
      const parenthesesPattern = new RegExp(
        `\\(([^/]*?\\s*)?${escapedVariant}\\s*/\\s*([^)]+)\\)`,
        "i"
      );
      if (result.match(parenthesesPattern)) {
        const match = result.match(parenthesesPattern);
        const before = match[1] ? match[1].trim() : "";
        const after = match[2].trim();
        const newContent = [before, after].filter(Boolean).join(" / ");
        result = result.replace(parenthesesPattern, `(${newContent})`);
      }

      // Standard patterns for merchant names without punctuation - ALLE mit globalem Flag
      result = result
        .replace(new RegExp(`\\s+bei\\s+${wordBoundaryPattern}\\s+`, "gi"), " ")
        .replace(
          new RegExp(`\\s+(?:bei\\s+)?${escapedVariant}(?:[-‚Äì]|\\s)*$`, "gi"),
          ""
        )
        .replace(new RegExp(`\\s+auf\\s+${escapedVariant}$`, "gi"), "")
        .replace(new RegExp(`\\s+auf\\s+${escapedVariant}(?=\\s|$)`, "gi"), "");
      }

      result = result
        // WICHTIG: Runden-Klammern-Pattern ZUERST, bevor andere Patterns die Struktur zerst√∂ren!
        // H√§ndler in runden Klammern √úBERALL im Titel (GLOBAL - alle Vorkommen)
        // Beispiel 1: "(Lidl)" -> "" (komplett weg, weil nur H√§ndlername)
        // Beispiel 2: "(mit Lidl App)" -> "(mit App)" (H√§ndler weg, Rest bleibt)
        // Beispiel 3: "(Aliexpress M√ºnzdeal)" -> "(M√ºnzdeal)" (nur H√§ndler weg, Rest bleibt)
        .replace(new RegExp(`\\(([^)]*)\\b${escapedVariant}\\b([^)]*)\\)`, "gi"), (match, before, after) => {
          const cleanedBefore = before.trim();
          const cleanedAfter = after.trim();

          // Wenn nichts √ºbrig bleibt, entferne die komplette Klammer
          if (!cleanedBefore && !cleanedAfter) {
            return "";
          }

          // Kombiniere was √ºbrig bleibt
          const parts = [cleanedBefore, cleanedAfter].filter(Boolean);
          // FIX: Gib die Klammern MIT dem √ºbrig gebliebenen Inhalt zur√ºck
          return `(${parts.join(" ")})`;
        })

        // Entferne leere Klammern die durch vorherige Operationen entstanden sind
        .replace(/\(\s*\)/g, "")

        // Die restlichen Standardmuster - ALLE mit globalem Flag (g) f√ºr multiple Vorkommen
        .replace(new RegExp(`\\(${escapedVariant}:\\s*`, "gi"), "(")
        .replace(new RegExp(`${escapedVariant}:\\s*`, "gi"), "")

        // H√§ndler am Anfang (mit optionalem Punkt danach)
        .replace(new RegExp(`^${escapedVariant}\\s*\\.?\\s*[-‚Äì]?\\s*`, "gi"), "")

        // FIX: H√§ndler in eckigen Klammern mit optionalen Leerzeichen
        .replace(new RegExp(`\\[\\s*${escapedVariant}\\s*\\]\\s*`, "gi"), "")

        // NEU: H√§ndler-Komposita in eckigen Klammern (z.B. "[Lidl-Angebote]")
        .replace(new RegExp(`\\[\\s*${escapedVariant}[-\\s]?[^\\]]*\\]\\s*`, "gi"), "")

        // H√§ndler mit Punkt als Trenner
        .replace(new RegExp(`^${escapedVariant}\\.\\s*`, "gi"), "")
        .replace(new RegExp(`\\s+${escapedVariant}\\.\\s+`, "gi"), " ")
        .replace(new RegExp(`\\s+${escapedVariant}\\.\\s*$`, "gi"), "")

        // H√§ndler in Klammern mit fehlenden Klammern
        .replace(new RegExp(`^${escapedVariant}\\)\\s*`, "gi"), "")
        .replace(new RegExp(`\\(${escapedVariant}$`, "gi"), "")

        // NEU: H√§ndler mitten im Titel (mit Wortgrenzen)
        // Beispiel: "(CB) K√§rcher Waschsauger" -> "(CB) Waschsauger"
        .replace(new RegExp(`\\b${escapedVariant}\\b\\s+`, "gi"), "")

        // NEU: "bei H√§ndler" + Domain-TLD am Ende (z.B. "bei Druckerzubeh√∂r.de")
        .replace(new RegExp(`\\s+bei\\s+${escapedVariant}\\.(de|com|co\\.uk)\\s*$`, "gi"), "")
        .replace(new RegExp(`\\s+bei\\s+${escapedVariant}\\.(de|com|co\\.uk)(?=\\s)`, "gi"), "")

        // NEU: H√§ndler vor @domain.tld (z.B. "Packungen Tassimo @ Tassimo.de")
        .replace(new RegExp(`\\b${escapedVariant}\\b\\s*@\\s*${escapedVariant}\\.(de|com|co\\.uk)`, "gi"), "@$2.$1")
        .replace(new RegExp(`\\s+@\\s*${escapedVariant}\\.(de|com|co\\.uk)`, "gi"), "");
    }); // Ende variantsToCheck.forEach
  }); // Ende merchantVariants.forEach

  const finalResult = result.replace(/\s+/g, " ").trim();

  // Nur loggen wenn sich tats√§chlich was ge√§ndert hat
  if (DEBUG.hideMatchingMerchantNames && title !== finalResult) {
    console.log(`[${getDebugTimestamp()}] [MDM MerchantNames] ‚úÇÔ∏è Removed '`+merchant+`':`, {
      from: title,
      to: finalResult
    });
  }

  return finalResult;
}

function shortenMerchantName(title) {
  // Special cases for merchant names
  const replacements = {
    "Kaufland Card": "K-Card",
    Kaufland: "",
    // Add more special cases here if needed
  };

  let newTitle = title;
  for (const [merchant, replacement] of Object.entries(replacements)) {
    // Case insensitive replace with word boundaries
    const regex = new RegExp(`\\b${merchant}\\b`, "i");
    newTitle = newTitle.replace(regex, replacement);
  }

  return newTitle.trim();
}

// ===== UI-Management =====
// --- Cleanup & Reset ---
function cleanup() {
  // Remove settings UI and always reset state
  if (settingsDiv?.parentNode) settingsDiv.remove();
  isSettingsOpen = false;

  // Add word suggestion list cleanup
  const suggestionList = document.getElementById("wordSuggestionList");
  if (suggestionList) {
    suggestionList.remove();
  }

  // Close all sub-UIs with state logging
  if (merchantListDiv?.parentNode) {
    merchantListDiv.remove();
  }
  if (wordsListDiv?.parentNode) {
    wordsListDiv.remove();
  }
  if (blockedUsersDiv?.parentNode) {
    blockedUsersDiv.remove();
  }
  if (window.whitelistDiv?.parentNode) {
    window.whitelistDiv.remove();
  }

  // Reset UI states with logging
  if (activeSubUI) {
    const buttonMappings = {
      merchant: {
        id: "showMerchantListButton",
        html: '<i class="fas fa-store"></i> H√§ndlerfilter verwalten',
      },
      words: {
        id: "showWordsListButton",
        html: '<i class="fas fa-list"></i> Wortfilter verwalten',
      },
      whitelist: {
        id: "showWhitelistButton",
        html: '<i class="fas fa-shield-alt"></i> Whitelist verwalten',
      },
      users: {
        id: "showBlockedUsersButton",
        html: '<i class="fas fa-user-slash"></i> Benutzerfilter verwalten',
      },
    };

    const buttonConfig = buttonMappings[activeSubUI];
    if (buttonConfig) {
      const btn = document.getElementById(buttonConfig.id);
      if (btn) {
        btn.innerHTML = buttonConfig.html;
        btn.removeAttribute("data-processing");
      }
    }
  }

  activeSubUI = null;
  dealThatOpenedSettings = null; // Reset auch den aktiven Deal

  // Clean up handlers
  document.removeEventListener("click", suggestionClickHandler);
  document.removeEventListener("click", uiClickOutsideHandler);
  window.removeEventListener("unload", cleanup);
  uiClickOutsideHandler = null;

  // Reset suggestion state
  suggestedWords = [];
}

//#endregion

//#region --- 9. Theming und UI-Darstellung ---
// Farbkonstanten f√ºr Light/Dark Mode
const THEME_COLORS = {
  light: {
    background: "#ffffff",
    border: "rgba(3,12,25,0.23)",
    text: "#333333",
    buttonBg: "#f5f5f5",
    buttonBorder: "#d0d0d0",
    inputBg: "#ffffff",
    itemBg: "#f8f8f8",
  },
  dark: {
    background: "#1d1f20",
    border: "rgb(107, 109, 109)",
    text: "#ffffff",
    buttonBg: "#2d2d2d",
    buttonBorder: "#3d3d3d",
    inputBg: "#1d1f20",
    itemBg: "#2a2a2a",
  },
};

// Theme Observer erstellen
const themeObserver = new MutationObserver(() => {
  requestAnimationFrame(() => {
    const colors = getThemeColors();
    updateAllUIThemes(colors);
  });
});

// Observer f√ºr beide Elemente einrichten
const targetNodes = [document.documentElement, document.body];
targetNodes.forEach((node) => {
  themeObserver.observe(node, {
    attributes: true,
    attributeFilter: ["class", "data-theme"],
  });
});

// System Theme Observer
const systemThemeObserver = window.matchMedia("(prefers-color-scheme: dark)");
systemThemeObserver.addEventListener("change", () => {
  requestAnimationFrame(() => {
    const colors = getThemeColors();
    updateAllUIThemes(colors);
  });
});

// Hide Button Theme Observer
const hideButtonThemeObserver = new MutationObserver(() => {
  const colors = getThemeColors();

  requestAnimationFrame(() => {
    document.querySelectorAll(".custom-hide-button").forEach((button) => {
      if (button) {
        button.style.cssText = `
                    position: absolute !important;
                    left: 50% !important;
                    top: 50% !important;
                    transform: translate(-50%, -50%) !important;
                    z-index: 10002 !important;
                    background: ${colors.background} !important;
                    border: 1px solid ${colors.border} !important;
                    border-radius: 50% !important;
                    cursor: pointer !important;
                    padding: 4px !important;
                    width: 28px !important;
                    height: 28px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    pointer-events: all !important;
                    box-shadow: none !important;
                    font-size: 12px !important;
                `;
      }
    });

    // Update settings UI wenn offen
    if (isSettingsOpen) {
      updateUITheme();
    }
  });
});

// Start observing theme changes
hideButtonThemeObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["class"],
});

// Theme Update Funktionen
function updateAllUIThemes() {
  const colors = getThemeColors();

  // Update buttons
  document.querySelectorAll(".custom-hide-button").forEach((button) => {
    if (button) {
      button.style.setProperty("background", colors.background, "important");
      button.style.setProperty("border-color", colors.border, "important");
    }
  });

  // Update open UIs
  if (isSettingsOpen || activeSubUI) {
    updateUITheme();
  }
}
//#endregion

//#region --- 10. Button-Management ---

function addSettingsButton() {
  const deals = document.querySelectorAll(
    "article.thread--deal, article.thread--voucher"
  );

  deals.forEach((deal) => {
    if (deal.hasAttribute("data-settings-added")) return;

    const footer = deal.querySelector(
      ".threadListCard-footer, .threadCardLayout-footer"
    );
    if (!footer) return;

    // Create settings button
    const settingsBtn = document.createElement("button");
    settingsBtn.className =
      "flex--shrink-0 button button--type-text button--mode-secondary button--square";
    settingsBtn.title = "mydealz Manager Einstellungen";
    settingsBtn.setAttribute("data-t", "mdmSettings");
    settingsBtn.style.cssText = `
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            padding: 6px !important;
            border: none !important;
            background: transparent !important;
            cursor: pointer !important;
            margin: 0 4px !important;
            min-width: 32px !important;
            min-height: 32px !important;
            position: relative !important;
            z-index: 2 !important;
        `;

    settingsBtn.innerHTML = `
            <span class="flex--inline boxAlign-ai--all-c">
                <svg width="20" height="20" class="icon icon--gear">
                    <use xlink:href="/assets/img/ico_707ed.svg#gear"></use>
                </svg>
            </span>
        `;

    // Insert at correct position (before comments button)
    const commentsBtn = footer.querySelector('[href*="comments"]');
    if (commentsBtn) {
      commentsBtn.parentNode.insertBefore(settingsBtn, commentsBtn);
    } else {
      footer.prepend(settingsBtn);
    }

    deal.setAttribute("data-settings-added", "true");

    settingsBtn.onclick = (e) => {
      // Visuelles Feedback SOFORT
      e.target.style.opacity = "0.5";

      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();

      if (isSettingsOpen) {
        if (dealThatOpenedSettings === deal) {
          cleanup();
          e.target.style.opacity = "";
        } else {
          cleanup();
          dealThatOpenedSettings = deal;
          createSettingsUI();
          e.target.style.opacity = "";
        }
      } else {
        dealThatOpenedSettings = deal;
        createSettingsUI();
        e.target.style.opacity = "";
      }

      return false;
    };
  });
}

function addHideButtons() {
  const deals = document.querySelectorAll("article:not([data-button-added])");

  if (DEBUG.criticalErrors) {
    console.log("[MDM HideButtons] Starting addHideButtons():", {
      totalDeals: document.querySelectorAll("article").length,
      dealsWithoutButton: deals.length,
      hiddenDeals: document.querySelectorAll("article[data-hidden-by-mydealz-manager='true']").length
    });
  }

  deals.forEach((deal) => {
    if (deal.hasAttribute("data-button-added")) return;

    const dealId = deal.getAttribute("id");

    // SKIP deals die vom Script ausgeblendet wurden
    if (deal.getAttribute("data-hidden-by-mydealz-manager") === "true") {
      if (DEBUG.criticalErrors) {
        console.log("[MDM HideButtons] SKIP hidden deal:", dealId);
      }
      return;
    }

    // Check for expired status
    const isExpired = deal
      .querySelector(".color--text-TranslucentSecondary .size--all-s")
      ?.textContent.includes("Abgelaufen");

    // Get temperature container
    const voteTemp = deal.querySelector(".cept-vote-temp");
    if (!voteTemp) {
      if (DEBUG.criticalErrors) {
        console.log("[MDM HideButtons] No voteTemp for deal:", dealId);
      }
      return;
    }

    // Remove popover
    const popover = voteTemp.querySelector(".popover-origin");
    if (popover) popover.remove();

    // Find temperature span for expired deals
    const tempSpan = isExpired ? voteTemp.querySelector("span") : null;
    const targetElement = isExpired ? tempSpan : voteTemp;

    if (!targetElement) {
      if (DEBUG.criticalErrors) {
        console.log("[MDM HideButtons] No targetElement for deal:", dealId);
      }
      return;
    }

    if (DEBUG.criticalErrors) {
      console.log("[MDM HideButtons] Adding button to deal:", dealId);
    }

    const hideButtonContainer = document.createElement("div");
    hideButtonContainer.style.cssText = `
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 10001;
            pointer-events: none;
        `;

    const hideButton = document.createElement("button");
    hideButton.innerHTML = "‚ùå";
    hideButton.className = "vote-button overflow--visible custom-hide-button";
    hideButton.title = "Deal verbergen";
    hideButton.style.cssText = `
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            z-index: 10002 !important;
            background: ${getThemeColors().background} !important;
            border: 1px solid ${getThemeColors().border} !important;
            border-radius: 50% !important;
            cursor: pointer !important;
            padding: 4px !important;
            width: 28px !important;
            height: 28px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            pointer-events: all !important;
            box-shadow: none !important;
            font-size: 12px !important;
        `;

    // Position relative to container
    if (!targetElement.style.position) {
      targetElement.style.position = "relative";
    }

    if (IS_TOUCH_DEVICE) {
      let buttonVisible = false;
      const dealId = deal.getAttribute("id");

      // Add scroll handler to hide button
      const scrollHandler = () => {
        if (buttonVisible) {
          buttonVisible = false;
          hideButtonContainer.style.display = "none";
        } else if (hideButtonContainer.style.display === "block") {
        }
      };

      // Add scroll listener
      window.addEventListener("scroll", scrollHandler, { passive: true });

      targetElement.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!buttonVisible) {
            buttonVisible = true;
            hideButtonContainer.style.display = "block";
          } else {
            const dealId = deal.getAttribute("id");

            hiddenDeals.push(dealId);
            saveHiddenDeals();
            hideDeal(deal);
            window.removeEventListener("scroll", scrollHandler);
          }
        },
        true
      );

      targetElement.addEventListener(
        "touchend",
        () => {
          if (!buttonVisible) {
            hideButtonContainer.style.display = "none";
          }
        },
        true
      );
    } else {
      targetElement.addEventListener(
        "mouseenter",
        () => {
          hideButtonContainer.style.display = "block";
        },
        true
      );

      targetElement.addEventListener(
        "mouseleave",
        () => {
          hideButtonContainer.style.display = "none";
        },
        true
      );

      hideButton.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const dealId = deal.getAttribute("id");

        hiddenDeals.push(dealId);
        saveHiddenDeals();
        hideDeal(deal);
        return false;
      };
    }

    hideButtonContainer.appendChild(hideButton);
    targetElement.appendChild(hideButtonContainer);
    deal.setAttribute("data-button-added", "true");

    if (DEBUG.criticalErrors) {
      console.log("[MDM HideButtons] Button successfully added to deal:", dealId);
    }
  });

  if (DEBUG.criticalErrors) {
    console.log("[MDM HideButtons] Finished addHideButtons():", {
      totalDealsAfter: document.querySelectorAll("article").length,
      dealsWithButton: document.querySelectorAll("article[data-button-added]").length
    });
  }
}

function getMerchantButtonText(merchantName) {
  return `Alle Deals von ${merchantName}`;
}

function addMerchantPageHideButton() {
  const urlParams = new URLSearchParams(window.location.search);
  const merchantId = urlParams.get("merchant-id");
  const merchantBanner = document.querySelector(MERCHANT_PAGE_SELECTOR);
  const merchantName = document
    .querySelector(".merchant-banner__title")
    ?.textContent.trim();

  if (!merchantId || !merchantBanner || !merchantName) return;

  const hideButtonContainer = document.createElement("div");
  hideButtonContainer.style.cssText = `
        display: inline-flex;
        align-items: center;
        margin-left: 10px;
    `;

  const hideButton = document.createElement("button");
  hideButton.style.cssText = `
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        background: #f0f0f0;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
        font-size: 14px;
    `;

  const buttonText = getMerchantButtonText(merchantName);
  hideButton.innerHTML = `
        <span style="display: inline-flex; align-items: center; gap: 8px; white-space: nowrap;">
            <i class="fas fa-store-slash"></i>
            <span>${buttonText}</span>
        </span>
    `;
  hideButton.title = `${buttonText} ausblenden`;

  hideButton.addEventListener("click", () => {
    const merchantsData = loadExcludeMerchants();
    if (!merchantsData.some((m) => m.id === merchantId)) {
      merchantsData.unshift({ id: merchantId, name: merchantName });
      saveExcludeMerchants(merchantsData);
      processArticles();
    }
  });

  hideButtonContainer.appendChild(hideButton);
  merchantBanner.appendChild(hideButtonContainer);
}

//#endregion

//#region --- 11. Skript-Initialisierung ---
// ===== WICHTIG: DEBUG-Config ZUERST laden =====
Object.assign(DEBUG, loadDebugConfig());

registerDebugMenu();

// Initial Debug Check
if (
  DEBUG.performance.enabled ||
  DEBUG.userBlocking ||
  DEBUG.backup ||
  DEBUG.hideMatchingMerchantNames ||
  DEBUG.priceFilter ||
  DEBUG.criticalErrors ||
  DEBUG.wordFilter
) {
  console.log("[MDM] Script loaded with DEBUG flags:", DEBUG);
}

// Initial beim Start aufrufen
registerMenuCommands();

// Start script - nach DOM ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init);
} else {
  init();
}

// Aufr√§umen bestehender Daten beim Skriptstart
(function cleanupMerchantData() {
  const merchants = loadExcludeMerchants();
  saveExcludeMerchants(merchants);
})();

// DOM-Ready Handler
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init);
} else {
  init();
}

//#endregion

//#region --- 12. Spezialisierte Komponenten ---
function initializeUI() {
  // Initial UI Setup
  processArticles();
  addSettingsButton();
  addHideButtons();
  addMerchantPageHideButton();
}

// Observer Initialisierung
function initObserver() {
  combinedObserver.disconnect();
  observer.disconnect();

  observerTargets.delete(observer);
  observerTargets.delete(combinedObserver);

  observeDealMutations(observer);
  observeDealMutations(combinedObserver);

  requestAnimationFrame(() => {
    processArticles();
    addSettingsButton();
    addHideButtons();
  });
}

function registerMenuCommands() {
  // Alte Men√ºs erst abmelden
  if (menuCommandId !== undefined) {
    GM_unregisterMenuCommand(menuCommandId);
  }

  // Men√ºeintrag zum √ñffnen der Einstellungen registrieren
  menuCommandId = GM_registerMenuCommand(
    "mydealz Manager Einstellungen",
    () => {
      // Einstellungen f√ºr aktuellen Deal √∂ffnen
      dealThatOpenedSettings = document.querySelector(
        "article.thread--deal, article.thread--voucher"
      );
      createSettingsUI();
    }
  );
}

//#endregion

//#region --- 13. Debug-System (Persistierung & Men√º) ---

// ===== Debug-Config aus GM Storage laden =====
function loadDebugConfig() {
  return {
    hideMatchingMerchantNames: GM_getValue(
      "debug.hideMatchingMerchantNames",
      false
    ),
    priceFilter: GM_getValue("debug.priceFilter", false),
    priceFilterVerbose: GM_getValue("debug.priceFilterVerbose", false),
    merchantFilter: GM_getValue("debug.merchantFilter", false),
    merchantInfoVerbose: GM_getValue("debug.merchantInfoVerbose", false),
    userBlocking: GM_getValue("debug.userBlocking", false),
    backup: GM_getValue("debug.backup", false),
    criticalErrors: GM_getValue("debug.criticalErrors", false),
    wordFilter: GM_getValue("debug.wordFilter", false),
    wordFilterVerbose: GM_getValue("debug.wordFilterVerbose", false),
    performance: {
      enabled: GM_getValue("debug.performance.enabled", false),
      observer: GM_getValue("debug.performance.observer", false),
      processing: GM_getValue("debug.performance.processing", false),
      filtering: GM_getValue("debug.performance.filtering", false),
      caching: GM_getValue("debug.performance.caching", false),
      domManipulation: GM_getValue("debug.performance.domManipulation", false),
      timing: GM_getValue("debug.performance.timing", false),
      summary: GM_getValue("debug.performance.summary", false),
      lazyRenderSummary: GM_getValue("debug.performance.lazyRenderSummary", false),
    },
  };
}

// ===== Debug-Flag umschalten und speichern =====
function toggleDebugFlag(flagPath, label) {
  const keys = flagPath.split(".");
  let current = DEBUG;

  // Navigate to parent object
  for (let i = 0; i < keys.length - 1; i++) {
    current = current[keys[i]];
  }

  const lastKey = keys[keys.length - 1];
  const newValue = !current[lastKey];
  current[lastKey] = newValue;

  // Save to GM storage
  GM_setValue(`debug.${flagPath}`, newValue);

  const status = newValue ? "‚úÖ AN" : "‚ùå AUS";
  console.log(`[MDM Debug] ${label}: ${status}`);

  // Show notification
  if (typeof GM_notification !== "undefined") {
    GM_notification({
      text: `${label}: ${status}`,
      title: "mydealz Manager Debug",
      timeout: 2000,
    });
  }
}

// ===== Alle Debug-Flags umschalten =====
function toggleAllDebugFlags() {
  // Check if any flag is currently enabled
  const anyEnabled =
    DEBUG.wordFilter ||
    DEBUG.wordFilterVerbose ||
    DEBUG.priceFilter ||
    DEBUG.priceFilterVerbose ||
    DEBUG.merchantFilter ||
    DEBUG.merchantInfoVerbose ||
    DEBUG.userBlocking ||
    DEBUG.backup ||
    DEBUG.criticalErrors ||
    DEBUG.hideMatchingMerchantNames ||
    DEBUG.performance.enabled ||
    DEBUG.performance.observer ||
    DEBUG.performance.processing ||
    DEBUG.performance.filtering ||
    DEBUG.performance.caching ||
    DEBUG.performance.domManipulation ||
    DEBUG.performance.timing ||
    DEBUG.performance.summary ||
    DEBUG.performance.lazyRenderSummary;

  const newState = !anyEnabled;

  // Set all simple boolean flags
  const simpleFlags = [
    "hideMatchingMerchantNames",
    "priceFilter",
    "priceFilterVerbose",
    "merchantFilter",
    "merchantInfoVerbose",
    "userBlocking",
    "backup",
    "criticalErrors",
    "wordFilter",
    "wordFilterVerbose",
  ];

  simpleFlags.forEach((flag) => {
    DEBUG[flag] = newState;
    GM_setValue(`debug.${flag}`, newState);
  });

  // Set all performance flags
  const perfFlags = [
    "enabled",
    "observer",
    "processing",
    "filtering",
    "caching",
    "domManipulation",
    "timing",
    "summary",
    "lazyRenderSummary",
  ];

  perfFlags.forEach((flag) => {
    DEBUG.performance[flag] = newState;
    GM_setValue(`debug.performance.${flag}`, newState);
  });

  const status = newState ? "‚úÖ ALLE AN" : "‚ùå ALLE AUS";
  console.log(`[MDM Debug] ${status}`);
  console.log("[MDM Debug] Aktuelle Flags:", DEBUG);

  // Show notification
  if (typeof GM_notification !== "undefined") {
    GM_notification({
      text: status,
      title: "mydealz Manager Debug",
      timeout: 2000,
    });
  }
}

// ===== Debug-Panel UI erstellen =====
function openDebugPanel() {
  // Pr√ºfe ob Panel bereits existiert
  if (document.getElementById("mdm-debug-panel")) {
    document.getElementById("mdm-debug-panel").remove();
  }

  const panel = document.createElement("div");
  panel.id = "mdm-debug-panel";
  panel.innerHTML = `
        <div id="mdm-debug-header">
            <span style="display: flex; align-items: center; gap: 8px;">
                <span style="cursor: move; opacity: 0.5;">‚ãÆ‚ãÆ</span>
                <span>üêõ Debug-Einstellungen</span>
            </span>
            <button id="mdm-debug-close" style="
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                padding: 0;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
            ">√ó</button>
        </div>
        <div id="mdm-debug-content">
            <div style="margin-bottom: 15px; padding: 10px; background: #f0f0f0; border-radius: 4px;">
                <button id="mdm-debug-toggle-all" style="
                    width: 100%;
                    padding: 8px;
                    background: #007bff;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                ">üîÑ Alle Flags umschalten</button>
            </div>

            <div class="mdm-debug-section">
                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #666;">Standard Debug-Flags</h4>
                <div class="mdm-debug-toggle" data-flag="wordFilter">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.wordFilter ? "checked" : ""
                        }>
                        <span>üêõ Word Filter</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="priceFilter">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.priceFilter ? "checked" : ""
                        }>
                        <span>üí∞ Price Filter</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="merchantFilter">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.merchantFilter ? "checked" : ""
                        }>
                        <span>üè™ Merchant Filter</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="userBlocking">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.userBlocking ? "checked" : ""
                        }>
                        <span>üë§ User Blocking</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="backup">
                    <label>
                        <input type="checkbox" ${DEBUG.backup ? "checked" : ""}>
                        <span>üíæ Backup/Restore</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="criticalErrors">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.criticalErrors ? "checked" : ""
                        }>
                        <span>‚ö†Ô∏è Critical Errors</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="hideMatchingMerchantNames">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.hideMatchingMerchantNames ? "checked" : ""
                        }>
                        <span>üè™ Merchant Names</span>
                    </label>
                </div>
            </div>

            <div class="mdm-debug-section" style="margin-top: 20px;">
                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #666;">Performance Monitoring</h4>
                <div class="mdm-debug-toggle" data-flag="performance.enabled">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.enabled ? "checked" : ""
                        }>
                        <span>üìä Performance (Master)</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.observer">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.observer ? "checked" : ""
                        }>
                        <span>üîç Observer</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.processing">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.processing ? "checked" : ""
                        }>
                        <span>‚öôÔ∏è Processing</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.filtering">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.filtering ? "checked" : ""
                        }>
                        <span>üîé Filtering</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.caching">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.caching ? "checked" : ""
                        }>
                        <span>üíæ Caching</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.domManipulation">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.domManipulation ? "checked" : ""
                        }>
                        <span>üé® DOM Manipulation</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.timing">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.timing ? "checked" : ""
                        }>
                        <span>‚è±Ô∏è Timing</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.summary">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.summary ? "checked" : ""
                        }>
                        <span>üìà Summary</span>
                    </label>
                </div>
                <div class="mdm-debug-toggle" data-flag="performance.lazyRenderSummary">
                    <label>
                        <input type="checkbox" ${
                          DEBUG.performance.lazyRenderSummary ? "checked" : ""
                        }>
                        <span>‚è≥ Kurzprotokoll verz√∂gerte Deals</span>
                    </label>
                </div>
            </div>
        </div>
    `;

  document.body.appendChild(panel);

  // Event-Listener f√ºr Schlie√üen-Button
  document.getElementById("mdm-debug-close").addEventListener("click", () => {
    panel.remove();
  });

  // Event-Listener f√ºr Toggle-All Button
  document
    .getElementById("mdm-debug-toggle-all")
    .addEventListener("click", () => {
      toggleAllDebugFlags();
      // Panel neu aufbauen um aktualisierte Werte anzuzeigen
      panel.remove();
      openDebugPanel();
    });

  // Event-Listener f√ºr alle Checkboxen
  panel.querySelectorAll(".mdm-debug-toggle").forEach((toggle) => {
    const checkbox = toggle.querySelector('input[type="checkbox"]');
    const flagPath = toggle.dataset.flag;

    checkbox.addEventListener("change", () => {
      toggleDebugFlag(flagPath, flagPath);
    });
  });

  // Drag-Funktionalit√§t
  const header = document.getElementById("mdm-debug-header");
  let isDragging = false;
  let currentX;
  let currentY;
  let initialX;
  let initialY;

  header.addEventListener("mousedown", (e) => {
    if (e.target.id === "mdm-debug-close") return;
    isDragging = true;
    initialX = e.clientX - panel.offsetLeft;
    initialY = e.clientY - panel.offsetTop;
  });

  document.addEventListener("mousemove", (e) => {
    if (isDragging) {
      e.preventDefault();
      currentX = e.clientX - initialX;
      currentY = e.clientY - initialY;
      panel.style.left = currentX + "px";
      panel.style.top = currentY + "px";
      panel.style.transform = "none";
    }
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
  });
}

// ===== Tampermonkey Debug-Men√º registrieren =====
function registerDebugMenu() {
  // Debug-Men√º nur registrieren wenn SHOW_DEBUG_MENU = true
  if (!SHOW_DEBUG_MENU) {
    return;
  }

  GM_registerMenuCommand("üêõ Debug: Logs / Toggles...", () => {
    openDebugPanel();
  });

  GM_registerMenuCommand("üîÑ Debug: ALLE AN/AUS", () => {
    toggleAllDebugFlags();
    if (typeof GM_notification !== "undefined") {
      const anyEnabled =
        DEBUG.wordFilter ||
        DEBUG.priceFilter ||
        DEBUG.userBlocking ||
        DEBUG.backup ||
        DEBUG.criticalErrors ||
        DEBUG.hideMatchingMerchantNames ||
        DEBUG.performance.enabled;
      GM_notification({
        text: anyEnabled
          ? "‚úÖ Alle Debug-Flags aktiviert"
          : "‚ùå Alle Debug-Flags deaktiviert",
        title: "mydealz Manager Debug",
        timeout: 2000,
      });
    }
  });
}

// ===== Debug-Panel CSS =====
const debugPanelStyle = document.createElement("style");
debugPanelStyle.textContent = `
    #mdm-debug-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: fit-content;
        min-width: 280px;
        max-width: 90vw;
        max-height: 80vh;
        background: #ffffff;
        border: 2px solid #007bff;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        display: flex;
        flex-direction: column;
        color: #333333;
    }

    /* Dark Theme Support */
    @media (prefers-color-scheme: dark) {
        #mdm-debug-panel {
            background: #1d1f20;
            border-color: rgb(107, 109, 109);
            color: #ffffff;
        }

        .mdm-debug-toggle {
            background: #2a2a2a !important;
        }

        .mdm-debug-toggle:hover {
            background: #3a3a3a !important;
        }

        #mdm-debug-panel h4 {
            color: #999999 !important;
        }

        #mdm-debug-panel button:not(#mdm-debug-toggle-all):not(#mdm-debug-close) {
            color: #ffffff;
        }

        #mdm-debug-content > div:first-child {
            background: #2a2a2a !important;
        }
    }

    html.dark #mdm-debug-panel,
    body.dark #mdm-debug-panel {
        background: #1d1f20;
        border-color: rgb(107, 109, 109);
        color: #ffffff;
    }

    html.dark .mdm-debug-toggle,
    body.dark .mdm-debug-toggle {
        background: #2a2a2a !important;
    }

    html.dark .mdm-debug-toggle:hover,
    body.dark .mdm-debug-toggle:hover {
        background: #3a3a3a !important;
    }

    html.dark #mdm-debug-panel h4,
    body.dark #mdm-debug-panel h4 {
        color: #999999 !important;
    }

    html.dark #mdm-debug-content > div:first-child,
    body.dark #mdm-debug-content > div:first-child {
        background: #2a2a2a !important;
    }

    #mdm-debug-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        background: #007bff;
        color: white;
        border-radius: 6px 6px 0 0;
        cursor: move;
        user-select: none;
        font-weight: bold;
    }

    #mdm-debug-content {
        padding: 15px;
        overflow-y: auto;
        flex: 1;
    }

    .mdm-debug-section {
        margin-bottom: 15px;
    }

    .mdm-debug-toggle {
        display: flex;
        align-items: center;
        padding: 8px 10px;
        margin-bottom: 5px;
        background: #f8f9fa;
        border-radius: 4px;
        transition: background 0.2s;
    }

    .mdm-debug-toggle:hover {
        background: #e9ecef;
    }

    .mdm-debug-toggle label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        flex: 1;
        white-space: nowrap;
    }

    .mdm-debug-toggle input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        flex-shrink: 0;
    }

    #mdm-debug-toggle-all:hover {
        background: #0056b3;
    }
`;
document.head.appendChild(debugPanelStyle);

//#endregion

//#region --- 14. Dokumentation ---
/*
===================================================================================
--- Funktions√ºbersicht mydealz Manager ---
===================================================================================

detectMultipleInstances() - Erkennt parallele Ausf√ºhrungen des Scripts (ab 1.13.x)
getThemeColors() - Liefert Theme-spezifische Farben basierend auf aktuellem Theme
processArticles() - Verarbeitet und filtert alle Deals
shouldExcludeArticle() - Pr√ºft ob ein Deal ausgeblendet werden soll
createSettingsUI() - Erstellt das Haupteinstellungsfenster
addSettingsButton() - F√ºgt Einstellungs-Button zu Deals hinzu
addHideButtons() - F√ºgt X-Button zum Ausblenden hinzu
backupData() - Erstellt Backup der Einstellungen
restoreData() - Stellt Backup-Daten wieder her
decodeHtml() - Konvertiert HTML-Entities
cleanup() - R√§umt UI-Elemente auf
syncStorage() - Synchronisiert GM und localStorage
saveExcludeWords() - Speichert Wortfilter
loadExcludeWords() - L√§dt Wortfilter
saveExcludeMerchants() - Speichert H√§ndlerfilter
loadExcludeMerchants() - L√§dt H√§ndlerfilter
saveMaxPrice() - Speichert Maximalpreis
createMerchantListUI() - Zeigt H√§ndlerliste
createExcludeWordsUI() - Zeigt Wortfilterliste
updateActiveLists() - Aktualisiert Listen im UI
handleMerchantDelete() - L√∂scht H√§ndler aus Filter
handleWordDelete() - L√∂scht Wort aus Filter
setupScrollHandling() - Konfiguriert Scroll-Verhalten
updateUITheme() - Aktualisiert UI-Farben
init() - Initialisiert das Script
removeMerchantNameFromTitle() - Entfernt H√§ndlernamen aus Deal-Titeln
throttle() - Begrenzt die Ausf√ºhrungsh√§ufigkeit von Funktionen
getWordsFromTitle() - Extrahiert relevante W√∂rter aus Deal-Titeln
hideDeal() - Blendet einen Deal aus
initUIContainers() - Initialisiert UI-Container
updateSuggestionList() - Aktualisiert Wortvorschl√§ge
handleWordSelection() - Verarbeitet Wortauswahl
setupClickOutsideHandler() - Konfiguriert Au√üenbereich-Klicks
createSuggestionClickHandler() - Erstellt Handler f√ºr Wortvorschl√§ge
registerMenuCommands() - Registriert Script-Manager Men√ºeintr√§ge
saveHiddenDeals() - Speichert ausgeblendete Deals
initializeUI() - Initialisiert Benutzeroberfl√§che
initObserver() - Initialisiert DOM-Beobachter
addMerchantPageHideButton() - F√ºgt H√§ndler-Ausblenden-Button hinzu

===================================================================================
*/
//#endregion
